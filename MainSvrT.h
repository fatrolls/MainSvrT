#pragma once

#include "resource.h"

/*
   This file has been generated by IDA.
   It contains local type definitions from
   the type library 'MainSvrT 2006.exe'
*/

#define __int8 char
#define __int16 short
#define __int32 int
#define __int64 long long

class _EXCEPTION_RECORD;
class $6D7329FAD13C403F17A910B84CCFB7BF;
class $BA519187DB4FB038EDB1959BB4D2DF27;
class CItem;
class CPlayer;
class CRWLock;
class CSkill;
class CCellMap;
class _RTL_CRITICAL_SECTION_DEBUG;
class _OVERLAPPED;
class CIOObject_vtbl;
class lisp::_object;
class lisp::_object_vtbl;
class CTile;
class CSMap;
class CBuff;
class CBuff_vtbl;
class QUESTITEMDROP;
class MSKILL;
class CInitMonster;
class CMonster;
class std::_Tree_nod<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >::_Node;
class std::pair<unsigned long const, CSkill*>;
class CSkill_vtbl;
class std::_Tree_nod<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >::_Node;
class stMember;
class std::pair<int const, stMember*>;
class CAlliance;
class CGuild;
class std::_Tree_nod<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::_Node;
class std::_Tree_nod<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >::_Node;
class CSpec;
class CSpec_vtbl;
class std::pair<enum Symbol const, CSpec*>;
class CPrefix;
class std::pair<int const, CItem*>;
class TRADEITEM;
class CItemMoney;
class CTrade;
class CItemTransform;
class CItemStandard;
class std::_Tree_nod<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::_Node;
class std::pair<int const, ITEMINFO>;
class std::_Tree_nod<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::_Node;
class std::pair<int const, STALLITEMINFO>;
class std::_Tree_nod<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::_Node;
class std::pair<int const, MYQUEST>;
class EVENTLIST;
class MLMLIST;
class std::_Tree_nod<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::_Node;
class std::pair<int const, FRDINFO>;
class std::_Tree_nod<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Node;
class std::pair<int const, MAILINFO>;
class std::_Tree_nod<std::_Tmap_traits<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, TELPT, iless, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> > const, TELPT> >, 0> >::_Node;
class std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> > const, TELPT>;
class CSocket;
class std::pair<int const, CPlayer*>;
class std::pair<char const* const, CPlayer*>;
class std::pair<int const, CInitItem*>;
class std::pair<int const, CPrefix*>;
class ITEMDROPINFO;
class CGroup;
class ITEMGROUP;
class CItemGroup;
class std::pair<int const, CItemGroup*>;
class std::exception_vtbl;
class _CRYPT_PROVIDER_CERT;
class _CRYPT_PROVIDER_SGNR;
class _CRYPT_PROVIDER_PRIVDATA;
class _CRYPT_PROVUI_DATA;
class _CRYPT_PROVUI_FUNCS;
class _CRYPT_PROVIDER_FUNCTIONS;
class _PROVDATA_SIP;
class _CERT_USAGE_MATCH;
class exception_vtbl;
class std::locale::facet_vtbl;
class std::ios_base_vtbl;
class std::ios_base::_Iosarray;
class std::ios_base::_Fnarray;
class std::locale::_Locimp;
class std::locale;
class std::fpos<int>;
class std::basic_streambuf<unsigned short, std::char_traits<unsigned short> >_vtbl;
class std::basic_streambuf<char, std::char_traits<char> >_vtbl;
class type_info_vtbl;
class CMemory::tagEntry;
class CMemory::tagRegion;
class CMemory::tagHeader;
class _iobuf;
class std::pair<CPlayer* const, int>;
class CParty;
class std::pair<CParty* const, int>;
class CFindPath::NODE;
class std::pair<int const, CGuild*>;
class std::pair<int const, CSocket*>;
class std::pair<int const, CAlliance*>;
class std::pair<int const, CSMap*>;
class std::pair<char const* const, GOTO>;
class PORTAL;
class std::_List_nod<CCase*, std::allocator<CCase*> >::_Node;
class std::_List_nod<CCondition*, std::allocator<CCondition*> >::_Node;
class CCondition;
class CCondition_vtbl;
class std::_List_nod<CAction*, std::allocator<CAction*> >::_Node;
class CAction;
class CAction_vtbl;
class CCase;
class std::pair<int const, CQuest*>;
class std::pair<int const, CParty*>;
class std::pair<char const* const, CBase*>;
class std::pair<char const* const, enum Symbol>;
class std::pair<int const, CGroup*>;
class ITEMDETAIL;
class CGoods;
class std::pair<int const, CGoods*>;
class std::pair<int const, CGenNPC*>;
class std::pair<int const, CNPC*>;
class std::pair<int const, CInitNPC*>;
class std::pair<int const, CInitMonster*>;
class std::pair<int const, CGenMonster*>;
class std::pair<int const, CMonster*>;
class std::pair<int const, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >;
class std::pair<char const* const, int>;
class CDBPacket;
class CAuthPacket;
class std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >_vtbl;

/* 1 */
class _SCOPETABLE_ENTRY
{
	int EnclosingLevel;
	void* FilterFunc;
	void* HandlerFunc;
};

/* 2 */
#pragma pack(push, 1)
class _msExcept7
{
	int Magic;
	int Count;
	void* InfoPtr;
	int CountDtr;
	void* DtrPtr;
	int _unk[2];
};
#pragma pack(pop)

/* 3 */
#pragma pack(push, 1)
class _msExcInfo
{
	int Id;
	void* Proc;
};
#pragma pack(pop)

/* 4 */
#pragma pack(push, 1)
class FuncInfoV1
{
	int magicNumber;
	int maxState;
	void* pUnwindMap;
	int nTryBlocks;
	void* pTryBlockMap;
	int nIPMapEntries;
	void* pIPtoStateMap;
};
#pragma pack(pop)

/* 5 */
#pragma pack(push, 1)
class UnwindMapEntry
{
	int toState;
	void* action;
};
#pragma pack(pop)

/* 6 */
enum __TI_flags
{
	TI_IsConst = 0x1,
	TI_IsVolatile = 0x2,
	TI_IsUnaligned = 0x4,
	TI_IsPure = 0x8,
	TI_IsWinRT = 0x10,
};

/* 7 */
enum __CT_flags
{
	CT_IsSimpleType = 0x1,
	CT_ByReferenceOnly = 0x2,
	CT_HasVirtualBase = 0x4,
	CT_IsWinRTHandle = 0x8,
	CT_IsStdBadAlloc = 0x10,
};

/* 8 */
typedef class _SCOPETABLE_ENTRY* PSCOPETABLE_ENTRY;

/* 29 */
typedef void* PVOID;

/* 24 */
typedef unsigned int DWORD;

/* 9 */
class _EH3_EXCEPTION_REGISTRATION
{
	class _EH3_EXCEPTION_REGISTRATION* Next;
	PVOID ExceptionHandler;
	PSCOPETABLE_ENTRY ScopeTable;
	DWORD TryLevel;
};

/* 10 */
typedef class _EH3_EXCEPTION_REGISTRATION EH3_EXCEPTION_REGISTRATION;

/* 11 */
typedef class _EH3_EXCEPTION_REGISTRATION* PEH3_EXCEPTION_REGISTRATION;

/* 12 */
class CPPEH_RECORD
{
	DWORD old_esp;
	EXCEPTION_POINTERS* exc_ptr;
	class _EH3_EXCEPTION_REGISTRATION registration;
};

/* 14 */
typedef unsigned __int16 WORD;

/* 13 */
#pragma pack(push, 4)
class WSAData
{
	WORD wVersion;
	WORD wHighVersion;
	char szDescription[257];
	char szSystemStatus[129];
	unsigned __int16 iMaxSockets;
	unsigned __int16 iMaxUdpDg;
	char* lpVendorInfo;
};
#pragma pack(pop)

/* 16 */
typedef unsigned __int16 u_short;

/* 20 */
typedef unsigned __int8 u_char;

/* 19 */
#pragma pack(push, 4)
class in_addr::$C13EC994467D6E67044F092615EC7EA9::$01C175C1F0716DCA00314EDD79DBC0A0
{
	u_char s_b1;
	u_char s_b2;
	u_char s_b3;
	u_char s_b4;
};
#pragma pack(pop)

/* 21 */
#pragma pack(push, 4)
class in_addr::$C13EC994467D6E67044F092615EC7EA9::$4DE764E669F663DACA3CBFDE73714CB5
{
	u_short s_w1;
	u_short s_w2;
};
#pragma pack(pop)

/* 22 */
typedef unsigned int u_long;

/* 18 */
#pragma pack(push, 4)
union in_addr::$C13EC994467D6E67044F092615EC7EA9
{
	in_addr::$C13EC994467D6E67044F092615EC7EA9::$01C175C1F0716DCA00314EDD79DBC0A0 S_un_b;
	in_addr::$C13EC994467D6E67044F092615EC7EA9::$4DE764E669F663DACA3CBFDE73714CB5 S_un_w;
	u_long S_addr;
};
#pragma pack(pop)

/* 17 */
#pragma pack(push, 4)
class in_addr
{
	in_addr::$C13EC994467D6E67044F092615EC7EA9 S_un;
};
#pragma pack(pop)

/* 15 */
#pragma pack(push, 4)
class sockaddr_in
{
	__int16 sin_family;
	u_short sin_port;
	in_addr sin_addr;
	char sin_zero[8];
};
#pragma pack(pop)

/* 27 */
typedef unsigned __int8 BYTE;

/* 26 */
class _FLOATING_SAVE_AREA
{
	DWORD ControlWord;
	DWORD StatusWord;
	DWORD TagWord;
	DWORD ErrorOffset;
	DWORD ErrorSelector;
	DWORD DataOffset;
	DWORD DataSelector;
	BYTE RegisterArea[80];
	DWORD Cr0NpxState;
};

/* 25 */
typedef _FLOATING_SAVE_AREA FLOATING_SAVE_AREA;

/* 23 */
class _CONTEXT
{
	DWORD ContextFlags;
	DWORD Dr0;
	DWORD Dr1;
	DWORD Dr2;
	DWORD Dr3;
	DWORD Dr6;
	DWORD Dr7;
	FLOATING_SAVE_AREA FloatSave;
	DWORD SegGs;
	DWORD SegFs;
	DWORD SegEs;
	DWORD SegDs;
	DWORD Edi;
	DWORD Esi;
	DWORD Ebx;
	DWORD Edx;
	DWORD Ecx;
	DWORD Eax;
	DWORD Ebp;
	DWORD Eip;
	DWORD SegCs;
	DWORD EFlags;
	DWORD Esp;
	DWORD SegSs;
	BYTE ExtendedRegisters[512];
};

/* 31 */
typedef unsigned int UINT_PTR;

/* 30 */
typedef UINT_PTR SIZE_T;

/* 28 */
class _MEMORY_BASIC_INFORMATION
{
	PVOID BaseAddress;
	PVOID AllocationBase;
	DWORD AllocationProtect;
	SIZE_T RegionSize;
	DWORD State;
	DWORD Protect;
	DWORD Type;
};

/* 34 */
typedef _EXCEPTION_RECORD EXCEPTION_RECORD;

/* 33 */
typedef EXCEPTION_RECORD* PEXCEPTION_RECORD;

/* 37 */
typedef _CONTEXT CONTEXT;

/* 36 */
typedef CONTEXT* PCONTEXT;

/* 32 */
class _EXCEPTION_POINTERS
{
	PEXCEPTION_RECORD ExceptionRecord;
	PCONTEXT ContextRecord;
};

/* 35 */
class _EXCEPTION_RECORD
{
	DWORD ExceptionCode;
	DWORD ExceptionFlags;
	_EXCEPTION_RECORD* ExceptionRecord;
	PVOID ExceptionAddress;
	DWORD NumberParameters;
	UINT_PTR ExceptionInformation[15];
};

/* 38 */
class _FILETIME
{
	DWORD dwLowDateTime;
	DWORD dwHighDateTime;
};

/* 41 */
typedef char CHAR;

/* 40 */
typedef CHAR* PCHAR;

/* 42 */
typedef unsigned __int64 DWORD64;

/* 39 */
#pragma pack(push, 8)
class _IMAGEHLP_LINE64
{
	DWORD SizeOfclass;
	PVOID Key;
	DWORD LineNumber;
	PCHAR FileName;
	DWORD64 Address;
};
#pragma pack(pop)

/* 43 */
typedef $6D7329FAD13C403F17A910B84CCFB7BF _LDBL12;

/* 44 */
#pragma pack(push, 4)
class $6D7329FAD13C403F17A910B84CCFB7BF
{
	unsigned __int8 ld12[12];
};
#pragma pack(pop)

/* 45 */
typedef $BA519187DB4FB038EDB1959BB4D2DF27 _CRT_DOUBLE;

/* 46 */
#pragma pack(push, 8)
class $BA519187DB4FB038EDB1959BB4D2DF27
{
	double x;
};
#pragma pack(pop)

/* 47 */
class CBillingPacket;

/* 48 */
#pragma pack(push, 1)
class CIOBuffer
{
	char m_buffer[8000];
	unsigned int m_dwSize;
	int m_nRef;
	CIOBuffer* m_pNext;
};
#pragma pack(pop)

/* 49 */
class DeathMatch_Wait;

/* 50 */
#pragma pack(push, 1)
class CIOObject
{
	CIOObject_vtbl* __vftable /*VFT*/;
	int m_nRef;
	int m_nTimerRef;
	int m_nGeneralRef;
};
#pragma pack(pop)

/* 328 */
#pragma pack(push, 1)
class /*VFT*/ CIOObject_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
};
#pragma pack(pop)

/* 326 */
#pragma pack(push, 1)
union $9AF5D86B53771EA3DF4292C1987DE7F7
{
	unsigned int Offset;
	void* Pointer;
};
#pragma pack(pop)

/* 327 */
#pragma pack(push, 1)
class _OVERLAPPED
{
	unsigned int Internal;
	unsigned int InternalHigh;
	$9AF5D86B53771EA3DF4292C1987DE7F7 ___u2;
	unsigned int OffsetHigh;
	void* hEvent;
};
#pragma pack(pop)

/* 51 */
class CNMSocket;

/* 52 */
#pragma pack(push, 1)
class CIOSpinLock
{
	int lock;
};
#pragma pack(pop)

/* 53 */
#pragma pack(push, 1)
class std::locale::facet
{
	std::locale::facet_vtbl* __vftable /*VFT*/;
	unsigned int _Refs;
};
#pragma pack(pop)

/* 1564 */
#pragma pack(push, 1)
class /*VFT*/ std::locale::facet_vtbl
{
	void(__thiscall * ~facet)(std::locale::facet* this);
};
#pragma pack(pop)

/* 334 */
#pragma pack(push, 1)
class lisp::var
{
	lisp::_object* m_pObject;
};
#pragma pack(pop)

/* 282 */
enum Token : __int32
{
	T_END = 0x0,
	T_VARIABLE = 0x1,
	T_STRING = 0x2,
	T_NEWLINE = 0x3,
	T_EQUAL = 0x4,
	T_COMMA = 0x5,
	T_COLON = 0x6,
	T_OPEN = 0x7,
	T_CLOSE = 0x8,
	T_ERROR = 0x9,
};

/* 54 */
#pragma pack(push, 1)
class CConfig
{
	char m_szSymbol[512];
	_iobuf* m_fp;
	int m_nLine;
	lisp::var m_root;
	Token m_token;
};
#pragma pack(pop)

/* 2241 */
#pragma pack(push, 1)
class _iobuf
{
	char* _ptr;
	int _cnt;
	char* _base;
	int _flag;
	int _file;
	int _charbuf;
	int _bufsiz;
	char* _tmpfname;
};
#pragma pack(pop)

/* 333 */
#pragma pack(push, 1)
class lisp::_object
{
	lisp::_object_vtbl* __vftable /*VFT*/;
};
#pragma pack(pop)

/* 335 */
#pragma pack(push, 1)
class /*VFT*/ lisp::_object_vtbl
{
	const char* (__thiscall* GetString)(lisp::_object* this);
	int(__thiscall* GetInteger)(lisp::_object* this);
	unsigned int(__thiscall* GetUnsigned)(lisp::_object* this);
	lisp::var* (__thiscall* car)(lisp::_object* this);
	lisp::var* (__thiscall* cdr)(lisp::_object* this);
	bool(__thiscall* consp)(lisp::_object* this);
	bool(__thiscall* null)(lisp::_object* this);
	bool(__thiscall* stringp)(lisp::_object* this);
	bool(__thiscall* integerp)(lisp::_object* this);
	int(__thiscall* length)(lisp::_object* this);
};
#pragma pack(pop)

/* 1574 */
#pragma pack(push, 1)
class std::_Iosb<int>
{
};
#pragma pack(pop)

/* 55 */
#pragma pack(push, 1)
class std::ios_base : std::_Iosb<int>
{
	std::ios_base_vtbl* __vftable /*VFT*/;
	unsigned int _Stdstr;
	int _Mystate;
	int _Except;
	int _Fmtfl;
	int _Prec;
	int _Wide;
	std::ios_base::_Iosarray* _Arr;
	std::ios_base::_Fnarray* _Calls;
	std::locale* _Ploc;
};
#pragma pack(pop)

/* 1575 */
#pragma pack(push, 1)
class /*VFT*/ std::ios_base_vtbl
{
	void(__thiscall * ~ios_base)(std::ios_base* this);
};
#pragma pack(pop)

/* 1576 */
#pragma pack(push, 1)
class std::ios_base::_Iosarray
{
	std::ios_base::_Iosarray* _Next;
	int _Index;
	int _Lo;
	void* _Vp;
};
#pragma pack(pop)

/* 268 */
enum std::ios_base::event : __int32
{
	erase_event = 0x0,
	imbue_event = 0x1,
	copyfmt_event = 0x2,
};

/* 1577 */
#pragma pack(push, 1)
class std::ios_base::_Fnarray
{
	std::ios_base::_Fnarray* _Next;
	int _Index;
	void(__cdecl* _Pfn)(std::ios_base::event, std::ios_base*, int);
};
#pragma pack(pop)

/* 1578 */
#pragma pack(push, 1)
class std::_Locbase<int>
{
};
#pragma pack(pop)

/* 1581 */
#pragma pack(push, 1)
class std::locale : std::_Locbase<int>
{
	std::locale::_Locimp* _Ptr;
};
#pragma pack(pop)

/* 63 */
#pragma pack(push, 1)
class std::_String_base
{
};
#pragma pack(pop)

/* 315 */
#pragma pack(push, 1)
class std::_Allocator_base<char>
{
};
#pragma pack(pop)

/* 316 */
#pragma pack(push, 1)
class std::allocator<char> : std::_Allocator_base<char>
{
};
#pragma pack(pop)

/* 317 */
#pragma pack(push, 1)
class std::_String_val<char> : std::_String_base
{
	std::allocator<char> _Alval;
};
#pragma pack(pop)

/* 318 */
#pragma pack(push, 1)
union std::string::_Bxty
{
	char _Buf[16];
	char* _Ptr;
};
#pragma pack(pop)

/* 319 */
#pragma pack(push, 1)
class std::string : std::_String_val<char>
{
	__declspec(align(4)) std::string::_Bxty _Bx;
	unsigned int _Mysize;
	unsigned int _Myres;
};
#pragma pack(pop)

/* 1579 */
#pragma pack(push, 1)
class std::locale::_Locimp : std::locale::facet
{
	std::locale::facet** _Facetvec;
	unsigned int _Facetcount;
	int _Catmask;
	bool _Xparent;
	__declspec(align(4)) std::string _Name;
};
#pragma pack(pop)

/* 56 */
#pragma pack(push, 1)
class lisp::_string : lisp::_object
{
	const char* m_pString;
};
#pragma pack(pop)

/* 57 */
#pragma pack(push, 1)
class std::codecvt_base : std::locale::facet
{
};
#pragma pack(pop)

/* 58 */
#pragma pack(push, 1)
class __declspec(align(4)) type_info
{
	type_info_vtbl* __vftable /*VFT*/;
	void* _m_data;
	char _m_d_name[1];
};
#pragma pack(pop)

/* 1740 */
#pragma pack(push, 1)
class /*VFT*/ type_info_vtbl
{
	void(__thiscall * ~type_info)(type_info* this);
};
#pragma pack(pop)

/* 59 */
class _LocaleUpdate;

/* 60 */
class std::_Container_base;

/* 61 */
#pragma pack(push, 1)
class std::exception
{
	std::exception_vtbl* __vftable /*VFT*/;
	const char* _Ptr;
};
#pragma pack(pop)

/* 1188 */
#pragma pack(push, 1)
class /*VFT*/ std::exception_vtbl
{
	void(__thiscall * ~exception)(std::exception* this);
	const char* (__thiscall* what)(std::exception* this);
	void(__thiscall* _Doraise)(std::exception* this);
};
#pragma pack(pop)

/* 128 */
#pragma pack(push, 1)
class exception
{
	exception_vtbl* __vftable /*VFT*/;
	const char* _m_what;
	int _m_doFree;
};
#pragma pack(pop)

/* 62 */
#pragma pack(push, 1)
class std::logic_error : exception
{
	std::string _Str;
};
#pragma pack(pop)

/* 1559 */
#pragma pack(push, 1)
class /*VFT*/ exception_vtbl
{
	void(__thiscall * ~exception)(exception* this);
	const char* (__thiscall* what)(exception* this);
};
#pragma pack(pop)

/* 64 */
#pragma pack(push, 1)
class std::length_error : std::logic_error
{
};
#pragma pack(pop)

/* 343 */
#pragma pack(push, 1)
class CBase : CIOObject
{
	CBase* m_pNext;
	unsigned int m_bit;
	unsigned int m_dwAttr;
	int m_nId;
};
#pragma pack(pop)

/* 421 */
#pragma pack(push, 1)
class std::binary_function<enum Symbol, enum Symbol, bool>
{
};
#pragma pack(pop)

/* 422 */
#pragma pack(push, 1)
class std::less<enum Symbol> : std::binary_function<enum Symbol, enum Symbol, bool>
{
};
#pragma pack(pop)

/* 423 */
#pragma pack(push, 1)
class std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0>
{
	std::less<enum Symbol> comp;
};
#pragma pack(pop)

/* 424 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 425 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 426 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> > : std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 427 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 428 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 429 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 430 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<enum Symbol const, CSpec*> >
{
};
#pragma pack(pop)

/* 431 */
#pragma pack(push, 1)
class std::allocator<std::pair<enum Symbol const, CSpec*> > : std::_Allocator_base<std::pair<enum Symbol const, CSpec*> >
{
};
#pragma pack(pop)

/* 432 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >
{
	std::allocator<std::pair<enum Symbol const, CSpec*> > _Alval;
};
#pragma pack(pop)

/* 437 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> > : std::_Tree_val<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 438 */
#pragma pack(push, 1)
class std::map<enum Symbol, CSpec*> : std::_Tree<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >
{
};
#pragma pack(pop)

/* 65 */
#pragma pack(push, 1)
class CInitItem : CBase
{
	char m_szName[31];
	__declspec(align(2)) int m_nIndex;
	int m_nClass;
	int m_nSubClass;
	unsigned int m_dwCode;
	int m_nLevel;
	int m_bWear;
	int m_bUse;
	int m_bPlural;
	int m_nClsLimit;
	int m_nLvLimit;
	int m_nRange;
	int m_nBuy;
	int m_nSell;
	int m_nEndurance;
	std::map<enum Symbol, CSpec*> m_mapSpec;
	int m_nCycle;
	int m_nNumPerHour;
	int m_nTime;
	int m_nRestNum;
	unsigned int m_dwCoolTime;
	int m_nRace;
	int m_bPay;
	int m_nStBuff;
	int m_nStBuffValue;
	int m_nMaxProtect;
	int m_nEffect;
	unsigned int m_dwCountry;
	int m_bWarRelation;
};
#pragma pack(pop)

/* 433 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >::_Node* _Right;
	std::pair<enum Symbol const, CSpec*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 161 */
enum Symbol : __int32
{
	S_NULL = 0x0,
	S_NAME = 0x1,
	S_INDEX = 0x2,
	S_MAP = 0x3,
	S_AREA = 0x4,
	S_MAX = 0x5,
	S_RECT = 0x6,
	S_LEVEL = 0x7,
	S_RACE = 0x8,
	S_STR = 0x9,
	S_HTH = 0xA,
	S_INT = 0xB,
	S_WIS = 0xC,
	S_DEX = 0xD,
	S_HP = 0xE,
	S_MP = 0xF,
	S_HIT = 0x10,
	S_DODGE = 0x11,
	S_ATTACK = 0x12,
	S_MAGIC = 0x13,
	S_DEFENSE = 0x14,
	S_ABSORB = 0x15,
	S_ASPEED = 0x16,
	S_MSPEED = 0x17,
	S_RESIST = 0x18,
	S_RESIST_FIRE = 0x19,
	S_RESIST_ICE = 0x1A,
	S_RESIST_LITNING = 0x1B,
	S_RESIST_CURSE = 0x1C,
	S_RESIST_PALSY = 0x1D,
	S_KIND = 0x1E,
	S_XY = 0x1F,
	S_FILENAME = 0x20,
	S_AI = 0x21,
	S_RANGE = 0x22,
	S_SIGHT = 0x23,
	S_EXP = 0x24,
	S_ITEMGROUP = 0x25,
	S_CLASS = 0x26,
	S_LIMIT = 0x27,
	S_BUY = 0x28,
	S_ENDURANCE = 0x29,
	S_SPECIALTY = 0x2A,
	S_TELEPORT = 0x2B,
	S_IMAGE = 0x2C,
	S_ACTION = 0x2D,
	S_REFRESH = 0x2E,
	S_WEAR = 0x2F,
	S_USE = 0x30,
	S_PLURAL = 0x31,
	S_ITEM = 0x32,
	S_GROUP = 0x33,
	S_MONEY = 0x34,
	S_MOVE = 0x35,
	S_HTML = 0x36,
	S_SHAPE = 0x37,
	S_DIR = 0x38,
	S_DESC = 0x39,
	S_SELL = 0x3A,
	S_PRE = 0x3B,
	S_DELAY = 0x3C,
	S_LASTTIME = 0x3D,
	S_VALUE1 = 0x3E,
	S_VALUE2 = 0x3F,
	S_CASE = 0x40,
	S_IF = 0x41,
	S_THEN = 0x42,
	S_ELSE = 0x43,
	S_REWARD = 0x44,
	S_PARTY = 0x45,
	S_QUEST = 0x46,
	S_CONTRIBUTE = 0x47,
	S_SUPOINT = 0x48,
	S_SAVE = 0x49,
	S_CLEAR = 0x4A,
	S_NOTCLEAR = 0x4B,
	S_LINK = 0x4C,
	S_IN = 0x4D,
	S_OUT = 0x4E,
	S_LINKED = 0x4F,
	S_DROPRATE = 0x50,
	S_MAXLEVEL = 0x51,
	S_CHARMING = 0x52,
	S_SETGEM = 0x53,
	S_REPAIR = 0x54,
	S_GSTATE = 0x55,
	S_COOLTIME = 0x56,
	S_CYCLE = 0x57,
	S_CHANGEPREFIX = 0x58,
	S_BUFF = 0x59,
	S_COCOON = 0x5A,
	S_IMAGEEX = 0x5B,
	S_ITEMRAND = 0x5C,
	S_GUIDE = 0x5D,
	S_REDISTRIBUTE = 0x5E,
	S_CID = 0x5F,
	S_WARRELATION = 0x60,
	S_RAGE = 0x61,
	S_PAY = 0x62,
	S_PROTECT = 0x63,
	S_REVIVAL = 0x64,
	S_CODE = 0x65,
	S_STBUFF = 0x66,
	S_FROM = 0x67,
	S_TO = 0x68,
	S_MAXPROTECT = 0x69,
	S_EFFECT = 0x6A,
	S_SKILL = 0x6B,
	S_SCENARIO = 0x6C,
	S_COUNTRY = 0x6D,
	S_BSTATE = 0x6E,
	S_CITEM = 0x6F,
	S_MONSTERSKILL = 0x70,
	S_SIEGEGUNPT = 0x71,
	S_SIEGEGUNDIR = 0x72,
};

/* 436 */
#pragma pack(push, 1)
class std::pair<enum Symbol const, CSpec*>
{
	const Symbol first;
	CSpec* second;
};
#pragma pack(pop)

/* 434 */
#pragma pack(push, 1)
class CSpec
{
	CSpec_vtbl* __vftable /*VFT*/;
	int m_nValue1;
	int m_nValue2;
};
#pragma pack(pop)

/* 435 */
#pragma pack(push, 1)
class /*VFT*/ CSpec_vtbl
{
	void(__thiscall* ApplySpec)(CSpec* this, CPlayer*);
	void(__thiscall* FreeSpec)(CSpec* this, CPlayer*);
	int(__thiscall* Use)(CSpec* this, CPlayer*);
	int(__thiscall* Enchant)(CSpec* this, CPlayer*, CItem*);
};
#pragma pack(pop)

/* 346 */
#pragma pack(push, 1)
class PROPERTY_BASE
{
	int nBase[7];
};
#pragma pack(pop)

/* 347 */
#pragma pack(push, 1)
class PROPERTY_PT
{
	int nPt[7];
	int nHit;
	int nDodge;
	int nMinAttack;
	int nMaxAttack;
	int nMinMagic;
	int nMaxMagic;
	int nDefense[2];
	int nAbsorb;
	int nASpeed;
	int nResist[5];
	int nFatal;
	int nMortal;
};
#pragma pack(pop)

/* 348 */
#pragma pack(push, 1)
class PROPERTY_PER
{
	int nPer[7];
	int nHit;
	int nDodge;
	int nMinAttack;
	int nMaxAttack;
	int nMinMagic;
	int nMaxMagic;
	int nDefense[2];
	int nAbsorb;
	int nASpeed;
	int nFatal;
	int nMSpeed;
	int nBlock;
	int nHost;
};
#pragma pack(pop)

/* 351 */
#pragma pack(push, 1)
class tagPOINT
{
	int x;
	int y;
};
#pragma pack(pop)

/* 322 */
#pragma pack(push, 1)
class _RTL_CRITICAL_SECTION
{
	_RTL_CRITICAL_SECTION_DEBUG* DebugInfo;
	int LockCount;
	int RecursionCount;
	void* OwningThread;
	void* LockSemaphore;
	unsigned int SpinCount;
};
#pragma pack(pop)

/* 70 */
#pragma pack(push, 1)
class CIOCriticalSection
{
	_RTL_CRITICAL_SECTION m_critical_section;
	unsigned int m_dwEIP[2];
};
#pragma pack(pop)

/* 80 */
#pragma pack(push, 1)
class CLink
{
	CLink* m_pNext;
	CLink* m_pPrev;
};
#pragma pack(pop)

/* 352 */
#pragma pack(push, 1)
class __declspec(align(8)) CChar : CBase
{
	char m_szName[25];
	__declspec(align(4)) int m_nLevel;
	PROPERTY_BASE m_prtyBase;
	PROPERTY_PT m_prtyPt;
	PROPERTY_PER m_prtyPer;
	int m_nCurHP;
	int m_nCurMP;
	int m_nGState;
	__declspec(align(8)) __int64 m_nMState;
	int m_nMStateEx;
	__declspec(align(8)) __int64 m_nBState;
	int m_nRange;
	int m_nMap;
	CSMap* m_pMap;
	tagPOINT m_ptTile;
	tagPOINT m_ptPixel;
	int m_nZ;
	int m_nQIndex;
	int m_nDir;
	int m_nFindRef;
	int m_nTargetRef;
	CBuff* m_pTopBuff;
	CIOCriticalSection m_lockBuff;
	CIOCriticalSection m_lock;
	CLink m_link;
};
#pragma pack(pop)

/* 409 */
#pragma pack(push, 1)
class CPlayerSkill
{
	CPlayer* m_pOwner;
	int m_nClass;
	CSkill* m_pSkill[84];
	int m_nPtLitning;
	int m_nPtIce;
	int m_nPtFire;
	CSkill* m_pTranSkill[9];
};
#pragma pack(pop)

/* 388 */
#pragma pack(push, 1)
class std::binary_function<int, int, bool>
{
};
#pragma pack(pop)

/* 389 */
#pragma pack(push, 1)
class std::less<int> : std::binary_function<int, int, bool>
{
};
#pragma pack(pop)

/* 410 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 411 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 412 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 413 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> > : std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 414 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 415 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 416 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 417 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, CItem*> >
{
};
#pragma pack(pop)

/* 418 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CItem*> > : std::_Allocator_base<std::pair<int const, CItem*> >
{
};
#pragma pack(pop)

/* 419 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >
{
	std::allocator<std::pair<int const, CItem*> > _Alval;
};
#pragma pack(pop)

/* 444 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 445 */
#pragma pack(push, 1)
class std::map<int, CItem*> : std::_Tree<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >
{
};
#pragma pack(pop)

/* 446 */
#pragma pack(push, 1)
class std::_Allocator_base<TRADEITEM>
{
};
#pragma pack(pop)

/* 447 */
#pragma pack(push, 1)
class std::allocator<TRADEITEM> : std::_Allocator_base<TRADEITEM>
{
};
#pragma pack(pop)

/* 448 */
#pragma pack(push, 1)
class std::_Vector_val<TRADEITEM>
{
	std::allocator<TRADEITEM> _Alval;
};
#pragma pack(pop)

/* 450 */
#pragma pack(push, 1)
class std::vector<TRADEITEM> : std::_Vector_val<TRADEITEM>
{
	__declspec(align(4)) TRADEITEM* _Myfirst;
	TRADEITEM* _Mylast;
	TRADEITEM* _Myend;
};
#pragma pack(pop)

/* 461 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 462 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 463 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 464 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> > : std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 465 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 466 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 467 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 468 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, ITEMINFO> >
{
};
#pragma pack(pop)

/* 469 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, ITEMINFO> > : std::_Allocator_base<std::pair<int const, ITEMINFO> >
{
};
#pragma pack(pop)

/* 470 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >
{
	std::allocator<std::pair<int const, ITEMINFO> > _Alval;
};
#pragma pack(pop)

/* 474 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 475 */
#pragma pack(push, 1)
class std::map<int, ITEMINFO> : std::_Tree<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >
{
};
#pragma pack(pop)

/* 476 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 477 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 478 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 479 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> > : std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 480 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 481 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 482 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 483 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, STALLITEMINFO> >
{
};
#pragma pack(pop)

/* 484 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, STALLITEMINFO> > : std::_Allocator_base<std::pair<int const, STALLITEMINFO> >
{
};
#pragma pack(pop)

/* 485 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >
{
	std::allocator<std::pair<int const, STALLITEMINFO> > _Alval;
};
#pragma pack(pop)

/* 489 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 490 */
#pragma pack(push, 1)
class std::map<int, STALLITEMINFO> : std::_Tree<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >
{
};
#pragma pack(pop)

/* 491 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 492 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 493 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 494 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> > : std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 495 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 496 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 497 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 498 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, MYQUEST> >
{
};
#pragma pack(pop)

/* 499 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, MYQUEST> > : std::_Allocator_base<std::pair<int const, MYQUEST> >
{
};
#pragma pack(pop)

/* 500 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >
{
	std::allocator<std::pair<int const, MYQUEST> > _Alval;
};
#pragma pack(pop)

/* 504 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 505 */
#pragma pack(push, 1)
class std::map<int, MYQUEST> : std::_Tree<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >
{
};
#pragma pack(pop)

/* 508 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 509 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 510 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 511 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> > : std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 512 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 513 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 514 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 515 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, FRDINFO> >
{
};
#pragma pack(pop)

/* 516 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, FRDINFO> > : std::_Allocator_base<std::pair<int const, FRDINFO> >
{
};
#pragma pack(pop)

/* 517 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >
{
	std::allocator<std::pair<int const, FRDINFO> > _Alval;
};
#pragma pack(pop)

/* 521 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 522 */
#pragma pack(push, 1)
class std::map<int, FRDINFO> : std::_Tree<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >
{
};
#pragma pack(pop)

/* 523 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 524 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 525 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 526 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> > : std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 527 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 528 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 529 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 530 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, MAILINFO> >
{
};
#pragma pack(pop)

/* 531 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, MAILINFO> > : std::_Allocator_base<std::pair<int const, MAILINFO> >
{
};
#pragma pack(pop)

/* 532 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >
{
	std::allocator<std::pair<int const, MAILINFO> > _Alval;
};
#pragma pack(pop)

/* 536 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 537 */
#pragma pack(push, 1)
class std::map<int, MAILINFO> : std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >
{
};
#pragma pack(pop)

/* 314 */
#pragma pack(push, 1)
class iless
{
};
#pragma pack(pop)

/* 538 */
#pragma pack(push, 1)
class std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0>
{
	iless comp;
};
#pragma pack(pop)

/* 539 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 540 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 541 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> > : std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 542 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 543 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 544 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> > : std::_Tree_nod<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 545 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<std::string const, TELPT> >
{
};
#pragma pack(pop)

/* 546 */
#pragma pack(push, 1)
class std::allocator<std::pair<std::string const, TELPT> > : std::_Allocator_base<std::pair<std::string const, TELPT> >
{
};
#pragma pack(pop)

/* 547 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >
{
	std::allocator<std::pair<std::string const, TELPT> > _Alval;
};
#pragma pack(pop)

/* 551 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> > : std::_Tree_val<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 552 */
#pragma pack(push, 1)
class std::map<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> > > : std::_Tree<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >
{
};
#pragma pack(pop)

/* 82 */
#pragma pack(push, 1)
class CPlayer : CChar
{
	int m_nSocketRef;
	int m_nPartyRef;
	int m_nUID;
	int m_nPID;
	int m_nAdmin;
	int m_nClass;
	unsigned int m_dwSpecialty;
	int m_nContribute;
	__int64 m_nExp;
	int m_nGID;
	CGuild* m_pGuild;
	int m_nGuildLevel;
	char m_szGuildName[17];
	__declspec(align(4)) int m_nStandard;
	int m_nGuildClass;
	char m_szGuildClassTitle[15];
	__declspec(align(2)) int m_nGRole;
	int m_nMoney;
	int m_nPUPoint;
	int m_nSUPoint;
	int m_nKilled;
	int m_nFace;
	int m_nHair;
	unsigned int m_dwWearState;
	unsigned int m_dwEState;
	int m_nRvId;
	int m_nRestPoint;
	int m_nRage;
	int m_nChantBuff;
	int m_nRevivalHP;
	int m_nRevivalMP;
	int m_nUpgrLevel;
	int m_nCAttack;
	int m_nCMagic;
	int m_nWMinAttack;
	int m_nWMaxAttack;
	int m_nWMinMagic;
	int m_nWMaxMagic;
	CPlayerSkill m_skill;
	int m_nParty;
	CIOCriticalSection m_lockItem;
	unsigned __int16 m_wWearItem[7];
	__declspec(align(4)) std::map<int, CItem*> m_mapItem;
	std::vector<TRADEITEM> m_vecTrade;
	CItemMoney* m_pMoney;
	CTrade* m_pTrade;
	int m_nQuestItem;
	CItemTransform* m_pTransform;
	int m_nTFlag;
	CItemStandard* m_pStandard;
	int m_nStBuff;
	int m_bMailSend;
	std::map<int, ITEMINFO> m_mapStorage;
	std::map<int, STALLITEMINFO> m_mapStall;
	char m_szStall[65];
	__declspec(align(4)) int m_nStall;
	CIOCriticalSection m_lockQuest;
	std::map<int, MYQUEST> m_mapMyQuest;
	int m_nQuestJob;
	int m_nCooking[7];
	EVENTLIST* m_pEventHead;
	MLMLIST* m_pTopMlm;
	CIOCriticalSection m_lockMlm;
	int m_nMlmMoney;
	int m_nMlmFee;
	int m_bOverFee;
	std::map<int, FRDINFO> m_mapFrd;
	CIOCriticalSection m_lockFrd;
	CIOCriticalSection m_lockMail;
	std::map<int, MAILINFO> m_mapMail;
	unsigned int m_dwAutoSave;
	unsigned int m_dwNextAutoRefresh;
	unsigned int m_dwNextAction;
	unsigned int m_dwNextRevival;
	unsigned int m_dwNextRefresh;
	unsigned int m_dwNextMsg;
	unsigned int m_dwLastDamage;
	unsigned int m_dwQuestJobTick;
	unsigned int m_dwNextAutoRefreshLevelHP;
	unsigned int m_dwNextAutoRefreshLevelMP;
	unsigned int m_dwNextDecRage;
	unsigned int m_dwNextQuest;
	int m_nTeleMap;
	tagPOINT m_ptTelePixel;
	std::map<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> > > m_mapTelPt;
	int m_nPvPId;
	CPlayer* m_pOppo;
	unsigned int m_dwPvP;
	int m_nCardList[12][2];
	int m_nBetAmount;
	int m_nGet1[2];
	int m_GambleState;
	int m_nSiegeGun;
	int m_nNPC;
	CIOCriticalSection m_lockGamble;
	CSocket* m_pSocket;
};
#pragma pack(pop)

/* 76 */
#pragma pack(push, 1)
class CItem : CBase
{
	int m_nPID;
	int m_nIID;
	CInitItem* m_pInit;
	CPrefix* m_pPrefix;
	unsigned int m_dwInfo;
	int m_nNum;
	CSMap* m_pMap;
	tagPOINT m_ptPixel;
	unsigned int m_dwTick;
	int m_bParty;
	int m_nKeyID;
	int m_nFrom;
	int m_nVer;
	int m_nMapRef;
};
#pragma pack(pop)

/* 350 */
#pragma pack(push, 1)
class CSMap
{
	int m_nIndex;
	int m_nKind;
	CCellMap* m_pSlot[4096];
};
#pragma pack(pop)

/* 353 */
#pragma pack(push, 1)
class CBuff
{
	CBuff_vtbl* __vftable /*VFT*/;
	int m_nType;
	unsigned int m_dwRelease;
	int m_nValue;
	int m_nPrty;
	CBuff* m_pNext;
};
#pragma pack(pop)

/* 323 */
#pragma pack(push, 1)
class _LIST_ENTRY
{
	_LIST_ENTRY* Flink;
	_LIST_ENTRY* Blink;
};
#pragma pack(pop)

/* 324 */
#pragma pack(push, 1)
class _RTL_CRITICAL_SECTION_DEBUG
{
	unsigned __int16 Type;
	unsigned __int16 CreatorBackTraceIndex;
	_RTL_CRITICAL_SECTION* CriticalSection;
	_LIST_ENTRY ProcessLocksList;
	unsigned int EntryCount;
	unsigned int ContentionCount;
	unsigned int Spare[2];
};
#pragma pack(pop)

/* 390 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 391 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 392 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 393 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> > : std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 394 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 395 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 396 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 397 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, stMember*> >
{
};
#pragma pack(pop)

/* 398 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, stMember*> > : std::_Allocator_base<std::pair<int const, stMember*> >
{
};
#pragma pack(pop)

/* 399 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >
{
	std::allocator<std::pair<int const, stMember*> > _Alval;
};
#pragma pack(pop)

/* 403 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 404 */
#pragma pack(push, 1)
class std::map<int, stMember*> : std::_Tree<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >
{
};
#pragma pack(pop)

/* 406 */
#pragma pack(push, 1)
class CGuild : CBase
{
	int m_nPlayerRef;
	int m_nMemberRef;
	int m_nTempRef;
	char m_szName[17];
	__declspec(align(4)) int m_nPoint;
	int m_nExp;
	int m_nPenaltyLevel;
	int m_nStandard;
	int m_nTotalTax;
	char m_szLeader[15];
	char m_szSubLeader[15];
	char m_szCenturion[15];
	char m_szTen[15];
	char m_szRegular[15];
	char m_szTemp[15];
	char m_szTodayMessage[181];
	__declspec(align(2)) unsigned int m_dwDeleteTick;
	int m_nSubLeaderAble;
	int m_nCenturionAble;
	int m_nTenAble;
	int m_nRegularAble;
	int m_nTempAble;
	std::map<int, stMember*> m_cGuildMemberMap;
	int m_nAID;
	CAlliance* m_pAlliance;
	int m_bSiegeGun[2];
};
#pragma pack(pop)

/* 386 */
#pragma pack(push, 1)
union $4E9262F69759CFA9E1A146960E03375C
{
	int m_nSkill;
	CSkill* m_pNext;
};
#pragma pack(pop)

/* 88 */
#pragma pack(push, 1)
class CSkill
{
	CSkill_vtbl* __vftable /*VFT*/;
	$4E9262F69759CFA9E1A146960E03375C ___u1;
	int m_nLevel;
	int m_nLmtLevel;
	unsigned int m_dwLmtSpecialty;
	int m_nLmtSkill;
	int m_nLmtSkillLevel;
	int m_nLmtMaxLevel;
	int m_nRedistribute;
	int m_nDecMP;
	unsigned int m_dwDelayPre;
	unsigned int m_dwDelay;
	unsigned int m_dwActionDelay;
	int m_nLastTime;
	int m_nV1;
	int m_nV2;
	unsigned int m_dwTick;
	int m_nRage;
	int m_nContiCnt;
};
#pragma pack(pop)

/* 420 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::_Node* _Right;
	std::pair<int const, CItem*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 449 */
#pragma pack(push, 1)
class TRADEITEM
{
	int nIID;
	int nNum;
};
#pragma pack(pop)

/* 451 */
#pragma pack(push, 1)
class CItemMoney : CItem
{
};
#pragma pack(pop)

/* 453 */
#pragma pack(push, 1)
class CTrade : CBase
{
	CPlayer* m_pCaller;
	CPlayer* m_pAcc;
};
#pragma pack(pop)

/* 455 */
#pragma pack(push, 1)
class CItemTransform : CItem
{
	int m_nLevel;
	int m_nExp;
	unsigned int m_dwPutOn;
	int m_nTFLevel;
};
#pragma pack(pop)

/* 457 */
#pragma pack(push, 1)
class CItemDefense : CItem
{
	int m_nMaxEnd;
	int m_nCurEnd;
	int m_nXAttack;
	int m_nXMagic;
	int m_nXDefense;
	int m_nXHit;
	int m_nXDodge;
	int m_nProtect;
};
#pragma pack(pop)

/* 459 */
#pragma pack(push, 1)
class CItemStandard : CItemDefense
{
	int m_bSpecApplied;
	unsigned int m_dwPutOffTick;
};
#pragma pack(pop)

/* 471 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::_Node* _Right;
	std::pair<int const, ITEMINFO> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 486 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::_Node* _Right;
	std::pair<int const, STALLITEMINFO> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 501 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::_Node* _Right;
	std::pair<int const, MYQUEST> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 506 */
#pragma pack(push, 1)
class EVENTLIST
{
	int nCurState;
	int nType;
	int nF1;
	EVENTLIST* pNext;
};
#pragma pack(pop)

/* 507 */
#pragma pack(push, 1)
class MLMLIST
{
	int nRelation;
	int nPID;
	char szName[17];
	__declspec(align(4)) int nClass;
	int nLevel;
	int bLogin;
	int nUID;
	MLMLIST* pNext;
};
#pragma pack(pop)

/* 518 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::_Node* _Right;
	std::pair<int const, FRDINFO> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 533 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Node* _Right;
	std::pair<int const, MAILINFO> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 548 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::_Node* _Right;
	std::pair<std::string const, TELPT> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 73 */
#pragma pack(push, 1)
class CIOSocket : CIOObject
{
	unsigned int m_hSocket;
	CIOCriticalSection m_lock;
	_OVERLAPPED m_overlappedRead;
	_OVERLAPPED m_overlappedWrite;
	CIOBuffer* m_pReadBuf;
	CIOBuffer* m_pFirstBuf;
	CIOBuffer* m_pLastBuf;
	int m_nPendingWrite;
};
#pragma pack(pop)

/* 553 */
#pragma pack(push, 1)
class CSocket : CIOSocket
{
	unsigned int m_bit;
	CLink m_link;
	CPlayer* m_pPlayer;
	int m_nEncodeCode;
	int m_nDecodeCode;
	int bIsGetHSCryptKey;
	int m_nPort;
	in_addr m_addr;
	unsigned int m_dwTick;
	int m_timeLogin;
	int m_nUID;
	int m_nAuthType;
	int m_nExpTime;
	int m_timePrev;
	int m_nCID;
	int m_nNoReplyCnt;
	char m_szBillingInfo[11];
	unsigned __int8 m_byHSCliInfo[72];
	__declspec(align(2)) unsigned int* m_pulHSEntry;
	unsigned int m_dwHSTick;
	int m_bHSIsFirstCheck;
	int m_bHSIsWaitAck;
	int nProtocolTestValue;
	int m_nId;
};
#pragma pack(pop)

/* 440 */
#pragma pack(push, 1)
class CPrefix : CBase
{
	int m_nPrefix;
	int m_nLevel;
	int m_nSellPer;
	std::map<enum Symbol, CSpec*> m_mapSpec;
};
#pragma pack(pop)

/* 124 */
#pragma pack(push, 1)
class CCellMap
{
	int m_nX;
	int m_nY;
	CTile* m_pTile;
	CRWLock* m_pLock;
};
#pragma pack(pop)

/* 354 */
#pragma pack(push, 1)
class /*VFT*/ CBuff_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 400 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >::_Node* _Right;
	std::pair<int const, stMember*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 405 */
#pragma pack(push, 1)
class CAlliance : CBase
{
	CAlliance* m_pNextAlliance;
	int m_nGID;
	char m_szGuildName[17];
	char m_szLeaderName[17];
	__declspec(align(4)) unsigned int m_dwAllianceDate;
	CGuild* m_pGuild;
};
#pragma pack(pop)

/* 385 */
#pragma pack(push, 1)
class /*VFT*/ CSkill_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 443 */
#pragma pack(push, 1)
class std::pair<int const, CItem*>
{
	const int first;
	CItem* second;
};
#pragma pack(pop)

/* 472 */
#pragma pack(push, 1)
class __unaligned __declspec(align(2)) ITEMINFO
{
	unsigned __int16 wIndex;
	int nIID;
	unsigned __int8 byPrefix;
	unsigned int dwInfo;
	int nNum;
	unsigned __int8 byMaxEnd;
	unsigned __int8 byCurEnd;
	unsigned __int8 byVer;
	unsigned __int8 byXAttack;
	unsigned __int8 byXMagic;
	unsigned __int8 byXDefense;
	unsigned __int8 byXHit;
	unsigned __int8 byXDodge;
	unsigned __int8 byProtect;
	unsigned __int8 byUpgrLevel;
	unsigned __int8 byUpgrRate;
};
#pragma pack(pop)

/* 473 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<int const, ITEMINFO>
{
	const int first;
	ITEMINFO second;
};
#pragma pack(pop)

/* 487 */
#pragma pack(push, 1)
class __unaligned __declspec(align(2)) STALLITEMINFO
{
	int nIID;
	unsigned __int16 wIndex;
	unsigned __int8 byPrefix;
	unsigned int dwInfo;
	int nNum;
	unsigned __int8 byMaxEnd;
	unsigned __int8 byCurEnd;
	unsigned __int8 byVer;
	unsigned __int8 byXAttack;
	unsigned __int8 byXMagic;
	unsigned __int8 byXDefense;
	unsigned __int8 byXHit;
	unsigned __int8 byXDodge;
	unsigned __int8 byProtect;
	unsigned __int8 byUpgrLevel;
	unsigned __int8 byUpgrRate;
	int nPrice;
};
#pragma pack(pop)

/* 488 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<int const, STALLITEMINFO>
{
	const int first;
	STALLITEMINFO second;
};
#pragma pack(pop)

/* 502 */
#pragma pack(push, 1)
class MYQUEST
{
	int nFlag;
	int bClear;
};
#pragma pack(pop)

/* 503 */
#pragma pack(push, 1)
class std::pair<int const, MYQUEST>
{
	const int first;
	MYQUEST second;
};
#pragma pack(pop)

/* 519 */
#pragma pack(push, 1)
class FRDINFO
{
	int nPID;
	char szName[17];
	__declspec(align(4)) int bLogin;
};
#pragma pack(pop)

/* 520 */
#pragma pack(push, 1)
class std::pair<int const, FRDINFO>
{
	const int first;
	FRDINFO second;
};
#pragma pack(pop)

/* 534 */
#pragma pack(push, 1)
class MAILINFO
{
	int nMID;
	int nPrity;
	int nType;
	int nStatus;
	int nSPID;
	char szSName[17];
	__declspec(align(4)) int nRPID;
	char szRName[17];
	__declspec(align(4)) int nTimetS;
	int nTimetE;
	int nIID;
	int nVer;
	int nIndex;
	int nPrefix;
	int nNum;
	int nPay;
};
#pragma pack(pop)

/* 535 */
#pragma pack(push, 1)
class std::pair<int const, MAILINFO>
{
	const int first;
	MAILINFO second;
};
#pragma pack(pop)

/* 549 */
#pragma pack(push, 1)
class TELPT
{
	int nMap;
	tagPOINT ptPLoc;
	int nZ;
};
#pragma pack(pop)

/* 550 */
#pragma pack(push, 1)
class std::pair<std::string const, TELPT>
{
	const std::string first;
	TELPT second;
};
#pragma pack(pop)

/* 349 */
#pragma pack(push, 1)
class CTile
{
	CBase* m_pHead;
	unsigned int m_dwAttr;
};
#pragma pack(pop)

/* 85 */
#pragma pack(push, 1)
class CRWLock
{
	int m_nCount;
	int m_nLock;
	void* m_hREvent;
	void* m_hWEvent;
	unsigned int m_dwEIP[2];
};
#pragma pack(pop)

/* 402 */
#pragma pack(push, 1)
class std::pair<int const, stMember*>
{
	const int first;
	stMember* second;
};
#pragma pack(pop)

/* 133 */
typedef int LONG;

/* 132 */
class tagRECT
{
	LONG left;
	LONG top;
	LONG right;
	LONG bottom;
};

/* 368 */
#pragma pack(push, 1)
class std::binary_function<unsigned long, unsigned long, bool>
{
};
#pragma pack(pop)

/* 369 */
#pragma pack(push, 1)
class std::less<unsigned long> : std::binary_function<unsigned long, unsigned long, bool>
{
};
#pragma pack(pop)

/* 370 */
#pragma pack(push, 1)
class std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0>
{
	std::less<unsigned long> comp;
};
#pragma pack(pop)

/* 371 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 372 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 373 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> > : std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 374 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 375 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 376 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 377 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<unsigned long const, CSkill*> >
{
};
#pragma pack(pop)

/* 378 */
#pragma pack(push, 1)
class std::allocator<std::pair<unsigned long const, CSkill*> > : std::_Allocator_base<std::pair<unsigned long const, CSkill*> >
{
};
#pragma pack(pop)

/* 379 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >
{
	std::allocator<std::pair<unsigned long const, CSkill*> > _Alval;
};
#pragma pack(pop)

/* 382 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> > : std::_Tree_val<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 383 */
#pragma pack(push, 1)
class std::map<unsigned long, CSkill*> : std::_Tree<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >
{
};
#pragma pack(pop)

/* 384 */
#pragma pack(push, 1)
class CMonsterSkill
{
	CMonster* m_pOwner;
	CSkill* m_pCurSkill;
	std::map<unsigned long, CSkill*> m_mapMSkill;
	unsigned int m_dwTick;
};
#pragma pack(pop)

/* 367 */
#pragma pack(push, 1)
class __declspec(align(8)) CMonster : CChar
{
	CInitMonster* m_pInit;
	int m_nArea;
	tagRECT m_rtArea;
	CChar* m_pTarget;
	unsigned int m_dwNextAction;
	unsigned int m_dwResetHP;
	int m_bAggressive;
	int m_nAIState;
	CChar* m_pParent;
	CMonsterSkill m_skill;
	int m_nIndex;
	int m_nCItem;
	int m_nCItemCnt;
	int m_nGID;
	int m_nOperator;
};
#pragma pack(pop)

/* 401 */
#pragma pack(push, 1)
class stMember
{
	char szName[17];
	__declspec(align(4)) int nPoint;
	int nClass;
	int bConnectTell;
	CPlayer* pPlayer;
	int nDate;
};
#pragma pack(pop)

/* 355 */
#pragma pack(push, 1)
class std::_Allocator_base<QUESTITEMDROP>
{
};
#pragma pack(pop)

/* 356 */
#pragma pack(push, 1)
class std::allocator<QUESTITEMDROP> : std::_Allocator_base<QUESTITEMDROP>
{
};
#pragma pack(pop)

/* 357 */
#pragma pack(push, 1)
class std::_Vector_val<QUESTITEMDROP>
{
	std::allocator<QUESTITEMDROP> _Alval;
};
#pragma pack(pop)

/* 359 */
#pragma pack(push, 1)
class std::vector<QUESTITEMDROP> : std::_Vector_val<QUESTITEMDROP>
{
	__declspec(align(4)) QUESTITEMDROP* _Myfirst;
	QUESTITEMDROP* _Mylast;
	QUESTITEMDROP* _Myend;
};
#pragma pack(pop)

/* 360 */
#pragma pack(push, 1)
class std::_Allocator_base<MSKILL>
{
};
#pragma pack(pop)

/* 361 */
#pragma pack(push, 1)
class std::allocator<MSKILL> : std::_Allocator_base<MSKILL>
{
};
#pragma pack(pop)

/* 362 */
#pragma pack(push, 1)
class std::_Vector_val<MSKILL>
{
	std::allocator<MSKILL> _Alval;
};
#pragma pack(pop)

/* 364 */
#pragma pack(push, 1)
class std::vector<MSKILL> : std::_Vector_val<MSKILL>
{
	__declspec(align(4)) MSKILL* _Myfirst;
	MSKILL* _Mylast;
	MSKILL* _Myend;
};
#pragma pack(pop)

/* 365 */
#pragma pack(push, 1)
class CInitMonster : CBase
{
	char m_szName[25];
	__declspec(align(4)) int m_nIndex;
	int m_nRace;
	int m_nLevel;
	unsigned int m_dwAI;
	int m_nItemGroup[5];
	int m_nDropNum[5];
	int m_nGroupCount;
	int m_nRange;
	int m_nSight[2];
	int m_nExp;
	PROPERTY_BASE m_prtyBase;
	PROPERTY_PT m_prtyPt;
	int m_nMSpeed[2];
	int m_nAttackType;
	std::vector<QUESTITEMDROP> m_vecQuestItemDrop;
	std::vector<MSKILL> m_vecMSkill;
	unsigned int m_dwCountry;
	int m_nCItem;
	int m_nCItemCnt;
	int m_nSkillIndex;
	int m_nSkillLevel;
	float m_nSkillProbablity;
	int m_nSkillTerm;
};
#pragma pack(pop)

/* 380 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >::_Node* _Right;
	std::pair<unsigned long const, CSkill*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 358 */
#pragma pack(push, 1)
class QUESTITEMDROP
{
	unsigned int dwQuestKey;
	int nItemGroup;
	int nDropNum;
};
#pragma pack(pop)

/* 363 */
#pragma pack(push, 1)
class MSKILL
{
	int nSkill;
	int nLevel;
};
#pragma pack(pop)

/* 381 */
#pragma pack(push, 1)
class std::pair<unsigned long const, CSkill*>
{
	const unsigned int first;
	CSkill* second;
};
#pragma pack(pop)

/* 66 */
#pragma pack(push, 1)
class CIOException::CInit
{
};
#pragma pack(pop)

/* 68 */
typedef unsigned int ULONG;

/* 69 */
typedef unsigned __int64 ULONG64;

/* 67 */
#pragma pack(push, 8)
class _SYMBOL_INFO
{
	ULONG SizeOfclass;
	ULONG TypeIndex;
	ULONG64 Reserved[2];
	ULONG Index;
	ULONG Size;
	ULONG64 ModBase;
	ULONG Flags;
	ULONG64 Value;
	ULONG64 Address;
	ULONG Register;
	ULONG Scope;
	ULONG Tag;
	ULONG NameLen;
	ULONG MaxNameLen;
	CHAR Name[1];
};
#pragma pack(pop)

/* 71 */
#pragma pack(push, 1)
class CIOSocket::CIOTimer
{
	unsigned int m_dwTime;
	CIOObject* m_pObject;
	int m_nId;
};
#pragma pack(pop)

/* 72 */
#pragma pack(push, 1)
class CIOSocket::CIOTimerInstance : CIOObject
{
};
#pragma pack(pop)

/* 74 */
#pragma pack(push, 1)
class CIOServer : CIOObject
{
	unsigned int m_hSocket;
	void* m_hAcceptEvent;
};
#pragma pack(pop)

/* 75 */
class CAnger;

/* 77 */
#pragma pack(push, 1)
class lisp::_cons : lisp::_object
{
	lisp::var m_car;
	lisp::var m_cdr;
};
#pragma pack(pop)

/* 78 */
#pragma pack(push, 1)
class CLog::CInit
{
};
#pragma pack(pop)

/* 2075 */
#pragma pack(push, 1)
class CNoMemoryObject
{
};
#pragma pack(pop)

/* 79 */
#pragma pack(push, 1)
class CMemory : CNoMemoryObject
{
	void* _crtheap;
	unsigned int __sbh_threshold;
	CMemory::tagHeader* __sbh_pHeaderList;
	CMemory::tagHeader* __sbh_pHeaderScan;
	int __sbh_sizeHeaderList;
	int __sbh_cntHeaderList;
	CMemory::tagHeader* __sbh_pHeaderDefer;
	int __sbh_indGroupDefer;
	_RTL_CRITICAL_SECTION _lock;
};
#pragma pack(pop)

/* 2082 */
#pragma pack(push, 1)
class CMemory::tagHeader
{
	unsigned int bitvEntryHi;
	unsigned int bitvEntryLo;
	unsigned int bitvCommit;
	void* pHeapData;
	CMemory::tagRegion* pRegion;
};
#pragma pack(pop)

/* 2078 */
#pragma pack(push, 1)
class CMemory::tagListHead
{
	CMemory::tagEntry* pEntryNext;
	CMemory::tagEntry* pEntryPrev;
};
#pragma pack(pop)

/* 2080 */
#pragma pack(push, 1)
class CMemory::tagGroup
{
	int cntEntries;
	CMemory::tagListHead listHead[64];
};
#pragma pack(pop)

/* 2081 */
#pragma pack(push, 1)
class CMemory::tagRegion
{
	int indGroupUse;
	char cntRegionSize[64];
	unsigned int bitvGroupHi[32];
	unsigned int bitvGroupLo[32];
	CMemory::tagGroup grpHeadList[32];
};
#pragma pack(pop)

/* 2077 */
#pragma pack(push, 1)
class CMemory::tagEntry
{
	int sizeFront;
	CMemory::tagEntry* pEntryNext;
	CMemory::tagEntry* pEntryPrev;
};
#pragma pack(pop)

/* 81 */
#pragma pack(push, 1)
class CGenNPC : CBase
{
	int m_nIndex;
	int m_nKind;
	int m_nShape;
	int m_nHtml;
	unsigned int m_dwQuestKey;
	int m_nMap;
	CSMap* m_pMap;
	tagPOINT m_ptPixel;
	int m_nZ;
	tagPOINT m_ptPDir;
	int m_nCID;
	int m_nWarRelation;
	int m_nMirror;
	int m_nItemIndex;
	unsigned int m_dwCountry;
	int m_nTelCount;
	int m_nTelMap[5];
	tagPOINT m_ptPTel[5];
	tagPOINT m_ptSGXY;
	tagPOINT m_ptSGDir;
};
#pragma pack(pop)

/* 2767 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_List_nod<CCase*>::_Node>
{
};
#pragma pack(pop)

/* 2768 */
#pragma pack(push, 1)
class std::allocator<std::_List_nod<CCase*>::_Node> : std::_Allocator_base<std::_List_nod<CCase*>::_Node>
{
};
#pragma pack(pop)

/* 2769 */
#pragma pack(push, 1)
class std::_List_nod<CCase*>
{
	std::allocator<std::_List_nod<CCase*>::_Node> _Alnod;
};
#pragma pack(pop)

/* 2770 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_List_nod<CCase*>::_Node*>
{
};
#pragma pack(pop)

/* 2771 */
#pragma pack(push, 1)
class std::allocator<std::_List_nod<CCase*>::_Node*> : std::_Allocator_base<std::_List_nod<CCase*>::_Node*>
{
};
#pragma pack(pop)

/* 2772 */
#pragma pack(push, 1)
class std::_List_ptr<CCase*> : std::_List_nod<CCase*>
{
	std::allocator<std::_List_nod<CCase*>::_Node*> _Alptr;
};
#pragma pack(pop)

/* 2773 */
#pragma pack(push, 1)
class std::_Allocator_base<CCase*>
{
};
#pragma pack(pop)

/* 2774 */
#pragma pack(push, 1)
class std::allocator<CCase*> : std::_Allocator_base<CCase*>
{
};
#pragma pack(pop)

/* 2775 */
#pragma pack(push, 1)
class std::_List_val<CCase*> : std::_List_ptr<CCase*>
{
	std::allocator<CCase*> _Alval;
};
#pragma pack(pop)

/* 2805 */
#pragma pack(push, 1)
class std::list<CCase*> : std::_List_val<CCase*>
{
	__declspec(align(2)) std::_List_nod<CCase*>::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 83 */
#pragma pack(push, 1)
class CQuest : CBase
{
	unsigned int m_dwKey;
	CQuest* m_pClone;
	int m_bLinked;
	std::list<CCase*> m_listCase;
};
#pragma pack(pop)

/* 2776 */
#pragma pack(push, 1)
class std::_List_nod<CCase*>::_Node
{
	std::_List_nod<CCase*>::_Node* _Next;
	std::_List_nod<CCase*>::_Node* _Prev;
	CCase* _Myval;
};
#pragma pack(pop)

/* 2777 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_List_nod<CCondition*>::_Node>
{
};
#pragma pack(pop)

/* 2778 */
#pragma pack(push, 1)
class std::allocator<std::_List_nod<CCondition*>::_Node> : std::_Allocator_base<std::_List_nod<CCondition*>::_Node>
{
};
#pragma pack(pop)

/* 2779 */
#pragma pack(push, 1)
class std::_List_nod<CCondition*>
{
	std::allocator<std::_List_nod<CCondition*>::_Node> _Alnod;
};
#pragma pack(pop)

/* 2780 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_List_nod<CCondition*>::_Node*>
{
};
#pragma pack(pop)

/* 2781 */
#pragma pack(push, 1)
class std::allocator<std::_List_nod<CCondition*>::_Node*> : std::_Allocator_base<std::_List_nod<CCondition*>::_Node*>
{
};
#pragma pack(pop)

/* 2782 */
#pragma pack(push, 1)
class std::_List_ptr<CCondition*> : std::_List_nod<CCondition*>
{
	std::allocator<std::_List_nod<CCondition*>::_Node*> _Alptr;
};
#pragma pack(pop)

/* 2783 */
#pragma pack(push, 1)
class std::_Allocator_base<CCondition*>
{
};
#pragma pack(pop)

/* 2784 */
#pragma pack(push, 1)
class std::allocator<CCondition*> : std::_Allocator_base<CCondition*>
{
};
#pragma pack(pop)

/* 2785 */
#pragma pack(push, 1)
class std::_List_val<CCondition*> : std::_List_ptr<CCondition*>
{
	std::allocator<CCondition*> _Alval;
};
#pragma pack(pop)

/* 2789 */
#pragma pack(push, 1)
class std::list<CCondition*> : std::_List_val<CCondition*>
{
	__declspec(align(2)) std::_List_nod<CCondition*>::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 2790 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_List_nod<CAction*>::_Node>
{
};
#pragma pack(pop)

/* 2791 */
#pragma pack(push, 1)
class std::allocator<std::_List_nod<CAction*>::_Node> : std::_Allocator_base<std::_List_nod<CAction*>::_Node>
{
};
#pragma pack(pop)

/* 2792 */
#pragma pack(push, 1)
class std::_List_nod<CAction*>
{
	std::allocator<std::_List_nod<CAction*>::_Node> _Alnod;
};
#pragma pack(pop)

/* 2793 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_List_nod<CAction*>::_Node*>
{
};
#pragma pack(pop)

/* 2794 */
#pragma pack(push, 1)
class std::allocator<std::_List_nod<CAction*>::_Node*> : std::_Allocator_base<std::_List_nod<CAction*>::_Node*>
{
};
#pragma pack(pop)

/* 2795 */
#pragma pack(push, 1)
class std::_List_ptr<CAction*> : std::_List_nod<CAction*>
{
	std::allocator<std::_List_nod<CAction*>::_Node*> _Alptr;
};
#pragma pack(pop)

/* 2796 */
#pragma pack(push, 1)
class std::_Allocator_base<CAction*>
{
};
#pragma pack(pop)

/* 2797 */
#pragma pack(push, 1)
class std::allocator<CAction*> : std::_Allocator_base<CAction*>
{
};
#pragma pack(pop)

/* 2798 */
#pragma pack(push, 1)
class std::_List_val<CAction*> : std::_List_ptr<CAction*>
{
	std::allocator<CAction*> _Alval;
};
#pragma pack(pop)

/* 2803 */
#pragma pack(push, 1)
class std::list<CAction*> : std::_List_val<CAction*>
{
	__declspec(align(2)) std::_List_nod<CAction*>::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 2804 */
#pragma pack(push, 1)
class CCase
{
	std::list<CCondition*> m_listCond;
	std::list<CAction*> m_listAction;
};
#pragma pack(pop)

/* 2786 */
#pragma pack(push, 1)
class std::_List_nod<CCondition*>::_Node
{
	std::_List_nod<CCondition*>::_Node* _Next;
	std::_List_nod<CCondition*>::_Node* _Prev;
	CCondition* _Myval;
};
#pragma pack(pop)

/* 2799 */
#pragma pack(push, 1)
class std::_List_nod<CAction*>::_Node
{
	std::_List_nod<CAction*>::_Node* _Next;
	std::_List_nod<CAction*>::_Node* _Prev;
	CAction* _Myval;
};
#pragma pack(pop)

/* 2787 */
#pragma pack(push, 1)
class CCondition
{
	CCondition_vtbl* __vftable /*VFT*/;
	int m_nValue;
};
#pragma pack(pop)

/* 2802 */
#pragma pack(push, 1)
union $082C648FE64BEC95B67FA0ECA2DE14B9
{
	int m_nValue;
	CQuest* m_pLink;
};
#pragma pack(pop)

/* 2800 */
#pragma pack(push, 1)
class CAction
{
	CAction_vtbl* __vftable /*VFT*/;
	$082C648FE64BEC95B67FA0ECA2DE14B9 ___u1;
};
#pragma pack(pop)

/* 2788 */
#pragma pack(push, 1)
class /*VFT*/ CCondition_vtbl
{
	void(__thiscall * ~CCondition)(CCondition* this);
	int(__thiscall* IsMeet)(CCondition* this, CPlayer*);
};
#pragma pack(pop)

/* 2801 */
#pragma pack(push, 1)
class /*VFT*/ CAction_vtbl
{
	void(__thiscall * ~CAction)(CAction* this);
	void(__thiscall* Action)(CAction* this, CPlayer*);
};
#pragma pack(pop)

/* 84 */
class CTraceSnapshot;

/* 86 */
#pragma pack(push, 1)
class CServer : CIOServer
{
};
#pragma pack(pop)

/* 87 */
#pragma pack(push, 1)
class CScreen
{
	char* m_pBuffer;
	int m_nWidth;
	int m_nHeight;
	int m_nLine;
	int m_nPitch;
	CIOCriticalSection m_lock;
};
#pragma pack(pop)

/* 672 */
#pragma pack(push, 1)
class CBlow : CSkill
{
};
#pragma pack(pop)

/* 89 */
#pragma pack(push, 1)
class CShieldAttack : CBlow
{
};
#pragma pack(pop)

/* 90 */
#pragma pack(push, 1)
class CMysticArrow : CBlow
{
};
#pragma pack(pop)

/* 91 */
#pragma pack(push, 1)
class CMagic : CSkill
{
};
#pragma pack(pop)

/* 715 */
#pragma pack(push, 1)
class CLitning : CMagic
{
};
#pragma pack(pop)

/* 92 */
#pragma pack(push, 1)
class CCallLitning : CLitning
{
};
#pragma pack(pop)

/* 723 */
#pragma pack(push, 1)
class CMagicWide : CMagic
{
};
#pragma pack(pop)

/* 93 */
#pragma pack(push, 1)
class CMagicWideSelf : CMagicWide
{
};
#pragma pack(pop)

/* 754 */
#pragma pack(push, 1)
class CHealingAny : CSkill
{
};
#pragma pack(pop)

/* 94 */
#pragma pack(push, 1)
class CHealingAnyQuick : CHealingAny
{
};
#pragma pack(pop)

/* 95 */
#pragma pack(push, 1)
class CProtect : CSkill
{
};
#pragma pack(pop)

/* 96 */
#pragma pack(push, 1)
class CDash : CSkill
{
};
#pragma pack(pop)

/* 97 */
#pragma pack(push, 1)
class CMeshSpeed : CSkill
{
};
#pragma pack(pop)

/* 98 */
#pragma pack(push, 1)
class CDarknessVision : CSkill
{
};
#pragma pack(pop)

/* 99 */
#pragma pack(push, 1)
class CAmnesia : CSkill
{
};
#pragma pack(pop)

/* 100 */
#pragma pack(push, 1)
class CSacrifice : CSkill
{
};
#pragma pack(pop)

/* 848 */
#pragma pack(push, 1)
class CSkillBuff : CSkill
{
};
#pragma pack(pop)

/* 101 */
#pragma pack(push, 1)
class CMeshStr : CSkillBuff
{
};
#pragma pack(pop)

/* 102 */
#pragma pack(push, 1)
class CMeshDefense : CSkillBuff
{
};
#pragma pack(pop)

/* 103 */
#pragma pack(push, 1)
class CDestroySight : CSkillBuff
{
};
#pragma pack(pop)

/* 104 */
#pragma pack(push, 1)
class CDoTele : CSkill
{
};
#pragma pack(pop)

/* 982 */
#pragma pack(push, 1)
class CMLitning : CMagic
{
};
#pragma pack(pop)

/* 105 */
#pragma pack(push, 1)
class CMShock : CMLitning
{
};
#pragma pack(pop)

/* 106 */
#pragma pack(push, 1)
class CShootingFire : CMagicWide
{
};
#pragma pack(pop)

/* 107 */
#pragma pack(push, 1)
class CMSiegeGunBallExplosion : CMagicWideSelf
{
};
#pragma pack(pop)

/* 108 */
#pragma pack(push, 1)
class CThunder : CBlow
{
};
#pragma pack(pop)

/* 802 */
#pragma pack(push, 1)
class CHealingParty : CSkill
{
};
#pragma pack(pop)

/* 109 */
#pragma pack(push, 1)
class CHealingPartyPlus : CHealingParty
{
};
#pragma pack(pop)

/* 110 */
#pragma pack(push, 1)
class CMock : CSkill
{
};
#pragma pack(pop)

/* 111 */
#pragma pack(push, 1)
class CInfernal : CBlow
{
};
#pragma pack(pop)

/* 112 */
#pragma pack(push, 1)
class CShot : CBlow
{
};
#pragma pack(pop)

/* 113 */
#pragma pack(push, 1)
class CExplosion : CBlow
{
};
#pragma pack(pop)

/* 114 */
#pragma pack(push, 1)
class CGetherShot : CBlow
{
};
#pragma pack(pop)

/* 115 */
#pragma pack(push, 1)
class CEdge : CBlow
{
};
#pragma pack(pop)

/* 116 */
#pragma pack(push, 1)
class CMeditation : CSkill
{
};
#pragma pack(pop)

/* 117 */
#pragma pack(push, 1)
class CHealingPartyIns : CHealingParty
{
};
#pragma pack(pop)

/* 118 */
#pragma pack(push, 1)
class CPoisonArrow : CSkill
{
};
#pragma pack(pop)

/* 119 */
#pragma pack(push, 1)
class CSilenceArrow : CSkill
{
};
#pragma pack(pop)

/* 120 */
#pragma pack(push, 1)
class CVanishConfi : CSkillBuff
{
};
#pragma pack(pop)

/* 896 */
#pragma pack(push, 1)
class CChant : CSkill
{
};
#pragma pack(pop)

/* 121 */
#pragma pack(push, 1)
class CChantHealing : CChant
{
};
#pragma pack(pop)

/* 122 */
#pragma pack(push, 1)
class CTGroundSplinter : CBlow
{
};
#pragma pack(pop)

/* 123 */
#pragma pack(push, 1)
class CDoAscension : CMagicWideSelf
{
};
#pragma pack(pop)

/* 125 */
class std::_Iterator_base;

/* 126 */
class CPythonExceptionSender;

/* 127 */
#pragma pack(push, 1)
class InitCodePage
{
};
#pragma pack(pop)

/* 129 */
#pragma pack(push, 1)
class std::_Init_locks
{
};
#pragma pack(pop)

/* 130 */
#pragma pack(push, 4)
class sockaddr
{
	u_short sa_family;
	char sa_data[14];
};
#pragma pack(pop)

/* 131 */
class _MEMORYSTATUS
{
	DWORD dwLength;
	DWORD dwMemoryLoad;
	DWORD dwTotalPhys;
	DWORD dwAvailPhys;
	DWORD dwTotalPageFile;
	DWORD dwAvailPageFile;
	DWORD dwTotalVirtual;
	DWORD dwAvailVirtual;
};

/* 135 */
typedef int __ehstate_t;

/* 134 */
#pragma pack(push, 4)
class EHRegistrationNode
{
	EHRegistrationNode* pNext;
	void* frameHandler;
	__ehstate_t state;
};
#pragma pack(pop)

/* 136 */
#pragma pack(push, 8)
class _BA519187DB4FB038EDB1959BB4D2DF27
{
	double x;
};
#pragma pack(pop)

/* 137 */
#pragma pack(push, 4)
class in_addr::_C13EC994467D6E67044F092615EC7EA9::_4DE764E669F663DACA3CBFDE73714CB5
{
	u_short s_w1;
	u_short s_w2;
};
#pragma pack(pop)

/* 138 */
#pragma pack(push, 4)
class in_addr::_C13EC994467D6E67044F092615EC7EA9::_01C175C1F0716DCA00314EDD79DBC0A0
{
	u_char s_b1;
	u_char s_b2;
	u_char s_b3;
	u_char s_b4;
};
#pragma pack(pop)

/* 139 */
#pragma pack(push, 4)
class _6D7329FAD13C403F17A910B84CCFB7BF
{
	unsigned __int8 ld12[12];
};
#pragma pack(pop)

/* 140 */
#pragma pack(push, 4)
union in_addr::_C13EC994467D6E67044F092615EC7EA9
{
	in_addr::_C13EC994467D6E67044F092615EC7EA9::_01C175C1F0716DCA00314EDD79DBC0A0 S_un_b;
	in_addr::_C13EC994467D6E67044F092615EC7EA9::_4DE764E669F663DACA3CBFDE73714CB5 S_un_w;
	u_long S_addr;
};
#pragma pack(pop)

/* 141 */
enum $88425F2A737304D519041DA836EB0269 : __int32
{
	_BUF_SIZE = 0x10,
};

/* 142 */
enum $FBAD2EF9375C97A433C22C545BCB4F4D : __int32
{
	_ALLOC_MASK = 0xF,
};

/* 143 */
enum S2C_PROTOCOL : __int32
{
	S2C_SIEGEGUNSET = 0x0,
	S2C_SIEGEGUNCONTROL = 0x1,
	S2C_REQGUID = 0x2,
	S2C_REQCRC = 0x3,
	S2C_ITEMINFO = 0x4,
	S2C_PUTONITEM = 0x5,
	S2C_PUTOFFITEM = 0x6,
	S2C_INSERTITEM = 0x7,
	S2C_TRASHITEM = 0x8,
	S2C_UPDATEITEMNUM = 0x9,
	S2C_SKILLADDVALUE = 0xA,
	S2C_SKILLREDISTRIBUTE = 0xB,
	S2C_PKBULLETININFO = 0xC,
	S2C_GETSTALLINFO = 0xD,
	S2C_MORA = 0xE,
	S2C_NOTICE = 0xF,
	S2C_SKILLINFO = 0x10,
	S2C_PLAYERINFO = 0x11,
	S2C_FRD = 0x12,
	S2C_MAIL = 0x13,
	S2C_LUCKYBLOW = 0x14,
	S2C_MSTATEEX = 0x15,
	S2C_MAPSTATE = 0x16,
	S2C_CHANGEFACE = 0x17,
	S2C_PLAYER_ANIMATION = 0x18,
	S2C_DELPLAYERINFO = 0x19,
	S2C_RESTOREPLAYER = 0x1A,
	S2C_ANS_LOAD = 0x1B,
	S2C_ANS_START = 0x1C,
	S2C_ANS_RESTART = 0x1D,
	S2C_ALIVE = 0x1E,
	S2C_GETMYTELPT = 0x1F,
	S2C_SETMYTELPT = 0x20,
	S2C_MOVEBEFORE = 0x21,
	S2C_MOVEPLAYER_ON = 0x22,
	S2C_MOVEPLAYER_END = 0x23,
	S2C_MOVEMONSTER_ON = 0x24,
	S2C_MOVEMONSTER_END = 0x25,
	S2C_MOVENPC_ON = 0x26,
	S2C_MOVENPC_END = 0x27,
	S2C_MOVEHORSE_ON_____RESERVED = 0x28,
	S2C_MOVEHORSE_END_____RESERVED = 0x29,
	S2C_CODE = 0x2A,
	S2C_ANS_LOGIN = 0x2B,
	S2C_ANS_NEWPLAYER = 0x2C,
	S2C_CLOSE = 0x2D,
	S2C_GSTATE = 0x2E,
	S2C_PET = 0x2F,
	S2C_TOOJUN = 0x30,
	S2C_KAL21 = 0x31,
	S2C_CREATEPLAYER = 0x32,
	S2C_CREATEMONSTER = 0x33,
	S2C_CREATENPC = 0x34,
	S2C_CREATEHORSE_____RESERVED = 0x35,
	S2C_CREATEITEM = 0x36,
	S2C_REMOVEPLAYER = 0x37,
	S2C_REMOVEMONSTER = 0x38,
	S2C_REMOVENPC = 0x39,
	S2C_REMOVEHORSE_____RESERVED = 0x3A,
	S2C_REMOVEITEM = 0x3B,
	S2C_CHATTING = 0x3C,
	S2C_ACTION = 0x3D,
	S2C_ATTACK = 0x3E,
	S2C_SKILL = 0x3F,
	S2C_INFODIE = 0x40,
	S2C_DEFENSE = 0x41,
	S2C_PROPERTY = 0x42,
	S2C_MESSAGE = 0x43,
	S2C_MESSAGEV = 0x44,
	S2C_UPDATEPROPERTY = 0x45,
	S2C_TELEPORT = 0x46,
	S2C_MSTATE = 0x47,
	S2C_UPDATEMPROPERTY = 0x48,
	S2C_EFFECT = 0x49,
	S2C_SENDHTML = 0x4A,
	S2C_ASKTRADE = 0x4B,
	S2C_ITEMLIST = 0x4C,
	S2C_OPENTRADE = 0x4D,
	S2C_CLOSETRADE = 0x4E,
	S2C_SHOWOFFITEM = 0x4F,
	S2C_ANS_TRADEITEM = 0x50,
	S2C_SKILLUP = 0x51,
	S2C_ASKPARTY = 0x52,
	S2C_PARTYMEMPOS = 0x53,
	S2C_PARTYINFO = 0x54,
	S2C_UPDATEPARTY = 0x55,
	S2C_SAVEQUEST = 0x56,
	S2C_QUESTINFO = 0x57,
	S2C_STORAGEINFO = 0x58,
	S2C_INSERT_SITEM = 0x59,
	S2C_UPDATE_SITEMNUM = 0x5A,
	S2C_UPDATEITEMEND = 0x5B,
	S2C_UPDATEITEMINFO = 0x5C,
	S2C_ANS_GAMEEXIT = 0x5D,
	S2C_GUILD = 0x5E,
	S2C_MESSAGEPK = 0x5F,
	S2C_ASKPVP = 0x60,
	S2C_ANS_COPYPLAYER = 0x61,
	S2C_BILLINGINFO = 0x62,
	S2C_BILLINGALERT = 0x63,
	S2C_MLM = 0x64,
	S2C_MOVEDASHPLAYER_ON = 0x65,
	S2C_MOVEDASHPLAYER_END = 0x66,
	S2C_SHORTCUT = 0x67,
	S2C_EFFECTMIX = 0x68,
	S2C_MIX = 0x69,
	S2C_END = 0x6A,
};

/* 144 */
enum $E1E0A9449B20FC8B5DD4266DF8C4BFBD : __int32
{
	INSERT_FAIL = 0x0,
	INSERT_SUCCESS = 0x1,
	INSERT_NOSLOT = 0x2,
};

/* 145 */
enum $2B6A793AA40B69BF59D76EE81B549973 : __int32
{
	CANT_END = 0x0,
	NORMAL_END = 0x1,
	ABNORMAL_END = 0x2,
	CANCEL_END = 0x3,
};

/* 146 */
enum $56A821A0F7BC2D0072A04FC39B229560 : __int32
{
	KAL21_INIT = 0x0,
	KAL21_BETTED = 0x1,
	KAL21_USERGETINGCARD = 0x2,
	KAL21_USERGOTALLCARD = 0x3,
	KAL21_WINWITH10AND1 = 0x4,
};

/* 147 */
enum SKILL_ADD_VALUE : __int32
{
	SAV_DAMAGELIGHTNINGADD = 0x0,
	SAV_DAMAGEWIDEICE = 0x1,
	SAV_DAMAGEWIDEFIRE = 0x2,
	SAV_DAMAGEPOISON = 0x3,
	SAV_HEALINGPARTY = 0x4,
	SAV_DAMAGESUFFERING = 0x5,
	SAV_DAMAGESPIRIT = 0x6,
	SAV_DAMAGEWIDECHAINLIGHTNING = 0x7,
	SAV_DAMAGEWIDEICEREQUIEM = 0x8,
	SAV_DAMAGEWIDEEXPLOSIVEBURST = 0x9,
	SAV_HEALINGPARTYPLUS = 0xA,
	SAV_HEALINGPARTYINS = 0xB,
	SAV_DAMAGEPOISONCLOUD = 0xC,
	SAV_DAMAGEPULLSWING = 0xD,
	SAV_DAMAGEWIDEMDORAGE = 0xE,
	SAV_DAMAGEWIDEMDOFURY = 0xF,
	SAV_DAMAGEWIDEMDOGROUNDFEAL = 0x10,
	SAV_DAMAGEWIDEMDOASCENSION1 = 0x11,
	SAV_DAMAGEWIDEMDOASCENSION2 = 0x12,
	SAV_DAMAGEWIDETHUNDERSTORM = 0x13,
	SAV_DAMAGEWIDEICESTORM = 0x14,
	SAV_DAMAGEWIDEFIRERAIN = 0x15,
	SAV_DAMAGEWIDEOVERRUN = 0x16,
	SAV_DAMAGEWIDEMSWIING1 = 0x17,
	SAV_DAMAGEWIDEMSWIING2 = 0x18,
	SAV_DAMAGEWIDEMFURY = 0x19,
	SAV_DAMAGEWIDEFIREEXPLOSION = 0x1A,
	SAV_DAMAGEWIDESIEGEGUNBALL = 0x1B,
};

/* 148 */
enum std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl : __int32
{
	_Red = 0x0,
	_Black = 0x1,
};

/* 149 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::_Redbl;

/* 150 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::_Redbl;

/* 151 */
enum BASE_BIT : __int32
{
	BBIT_DELETE = 0x0,
};

/* 152 */
enum ITEM_SUBCLASS : __int32
{
	ISC_SWORD = 0x0,
	ISC_WAND = 0x1,
	ISC_BOW = 0x2,
	ISC_SHIELD = 0x3,
	ISC_HELMET = 0x4,
	ISC_UPPERARMOR = 0x5,
	ISC_LOWERARMOR = 0x6,
	ISC_GAUNTLET = 0x7,
	ISC_BOOTS = 0x8,
	ISC_RING = 0x9,
	ISC_NECKLACE = 0xA,
	ISC_TRINKET = 0xB,
	ISC_REFRESH = 0xC,
	ISC_CHARM = 0xD,
	ISC_GEM = 0xE,
	ISC_ETC = 0xF,
	ISC_COIN = 0x10,
	ISC_COMMON = 0x11,
	ISC_REPAIR = 0x12,
	ISC_COCOON = 0x13,
	ISC_MASK = 0x14,
	ISC_SWORD2HAND = 0x15,
	ISC_STANDARD = 0x16,
};

/* 153 */
enum RESIST_TYPE : __int32
{
	RT_FIRE = 0x0,
	RT_ICE = 0x1,
	RT_LITNING = 0x2,
	RT_CURSE = 0x3,
	RT_PALSY = 0x4,
};

/* 154 */
enum $62D17ACA00205B512E977225E0BD3A7C : __int32
{
	TBIT_START = 0x1,
	TBIT_CANCEL = 0x2,
	TBIT_SETTIMER = 0x3,
	TBIT_END = 0x4,
};

/* 155 */
enum TYTE_LOG : __int32
{
	TL_LOGIN = 0x0,
	TL_LOGOUT = 0x1,
	TL_CREATE = 0x2,
	TL_CREATE_CHEAT = 0x3,
	TL_DELETE = 0x4,
	TL_UPDATEPID = 0x5,
	TL_UPDATENUM = 0x6,
	TL_BUY = 0x7,
	TL_SELL = 0x8,
	TL_USE = 0x9,
	TL_TRADE = 0xA,
	TL_DROP = 0xB,
	TL_PICKUP = 0xC,
	TL_PERMIT = 0xD,
	TL_SKILLUP = 0xE,
	TL_STORAGE = 0xF,
	TL_QUEST = 0x10,
	TL_SAVE_SP = 0x11,
	TL_UPDATE_PRTY = 0x12,
	TL_BLOCK = 0x13,
	TL_FREE = 0x14,
	TL_CHARMING = 0x15,
	TL_SETGEM = 0x16,
	TL_UPDATEEND = 0x17,
	TL_EVENT = 0x18,
	TL_PARTYPICKUP = 0x19,
	TL_TRADEBYSTALL = 0x1A,
	TL_CHANGEPREFIX = 0x1B,
	TL_UPDATE_CHEAT = 0x1C,
	TL_EXPLEVEL = 0x1D,
	TL_SKILLREDISTRIBUTE = 0x1E,
	TL_GUILD = 0x1F,
	TL_GUILD_EXP = 0x20,
	TL_ALLIANCE_CREATE = 0x21,
	TL_ALLIANCE_JOIN = 0x22,
	TL_ALLIANCE_DELETE = 0x23,
	TL_ALLIANCE_POSTPONE = 0x24,
	TL_CASTLEWAR_ADD = 0x25,
	TL_CASTLEWAR_END = 0x26,
	TL_BLESS = 0x27,
	TL_FORCEDIN = 0x28,
	TL_MLM = 0x29,
	TL_BUYFORCEDIN = 0x2A,
	TL_USEPAYITEM = 0x2B,
	TL_UPDATEITEMINFO = 0x2C,
	TL_UPGRADE_DESTROY = 0x2D,
	TL_UPGRADE_RATE = 0x2E,
	TL_UPGRADE_LEVEL = 0x2F,
	TL_MAIL_SEND = 0x30,
	TL_MAIL_POSTAGEL = 0x31,
	TL_MAIL_ITEMSEND = 0x32,
	TL_MAIL_ITEMRECV = 0x33,
	TL_CHANGEFACE = 0x34,
	TL_MOVEITEM = 0x35,
	TL_HACKING = 0x36,
};

/* 156 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::_Redbl;

/* 157 */
enum MESSAGE_TYPE : __int32
{
	MSG_SHUTDOWN_MIN = 0x0,
	MSG_SHUTDOWN_SEC = 0x1,
	MSG_SHUTDOWN_NOW = 0x2,
	MSG_SHUTDOWN_CANCEL = 0x3,
	MSG_INVALID_NAME = 0x4,
	MSG_SAMEPLAYERONGAME = 0x5,
	MSG_BLOCKEDPLAYER = 0x6,
	MSG_FAILLOADPLAYER = 0x7,
	MSG_NOTEXISTPLAYER = 0x8,
	MSG_MOVEHACK = 0x9,
	MSG_ALREADYPUTON = 0xA,
	MSG_CANTDELPUTONITEM = 0xB,
	MSG_CLASSLIMIT = 0xC,
	MSG_CANTDROPPUTONITEM = 0xD,
	MSG_DODGED = 0xE,
	MSG_USERCOUNT = 0xF,
	MSG_USERALLCOUNT = 0x10,
	MSG_INVENISFULL = 0x11,
	MSG_CURRENCY = 0x12,
	MSG_DESTPLAYERONTRADE = 0x13,
	MSG_NOTENOUGHPEERINVENSLOT = 0x14,
	MSG_INVALID_ITEMLIST = 0x15,
	MSG_TRADEAGREED = 0x16,
	MSG_PRIORITYOFITEM = 0x17,
	MSG_TOOFARFROMME = 0x18,
	MSG_THEREISNOPLAYER = 0x19,
	MSG_NEEDPUPOINT = 0x1A,
	MSG_NORIGHTOFPARTYHEAD = 0x1B,
	MSG_ASKJOINPARTY = 0x1C,
	MSG_JOINEDINPARTY = 0x1D,
	MSG_PARTYISFULL = 0x1E,
	MSG_JOINEDINOTHERPARTY = 0x1F,
	MSG_LEFTPARTY = 0x20,
	MSG_EXILEDFROMPARTY = 0x21,
	MSG_REJECTJOINPARTY = 0x22,
	MSG_BECOMEPARTYHEAD = 0x23,
	MSG_ENDPARTY = 0x24,
	MSG_OFFLINE_OUTOFRANGE = 0x25,
	MSG_SPECIALTYUP = 0x26,
	MSG_NOTENOUGHSTORSLOT = 0x27,
	MSG_NOTENOUGHINVENSLOT = 0x28,
	MSG_SAVEDREVIVALPT = 0x29,
	MSG_PARTYMEMGETITEM = 0x2A,
	MSG_EVENTRESULT = 0x2B,
	MSG_FISH_PROGRESS = 0x2C,
	MSG_SOLDOUT_SITEM = 0x2D,
	MSG_NOTENOUGH_SITEM = 0x2E,
	MSG_CANTBUY_SITEM = 0x2F,
	MSG_CHANGEDSTALLINFO = 0x30,
	MSG_COOKING_PROGRESS = 0x31,
	MSG_ALREADYENDEDSTALL = 0x32,
	MSG_COOKING_SCARCE_MATERIALS = 0x33,
	MSG_CANTPUTONSTALLITEM = 0x34,
	MSG_ASKREVIVAL = 0x35,
	MSG_ENCHANTFAILED = 0x36,
	MSG_GIG_FAIL = 0x37,
	MSG_REALTIMEEVENT = 0x38,
	MSG_REALTIMEEVENT_START = 0x39,
	MSG_REALTIMEEVENT_END = 0x3A,
	MSG_DONEINITSTAT = 0x3B,
	MSG_NOTREADYTOTRADE = 0x3C,
	MSG_NOTREADYTOPARTY = 0x3D,
	MSG_NOTREADYTOPVP = 0x3E,
	MSG_OFFLINE_OUTOFPVPRANGE = 0x3F,
	MSG_REJECTPVP = 0x40,
	MSG_ONPVP = 0x41,
	MSG_NOTENOUGHRAGE = 0x42,
	MSG_NOTTRANSFORMAREA = 0x43,
	MSG_INVALIDTILE = 0x44,
	MSG_TAXRATE = 0x45,
	MSG_INFOSYS = 0x46,
	MSG_REVIVAL_FAIL = 0x47,
	MSG_CHANT_ALREADYUSE = 0x48,
	MSG_MLMLOGIN = 0x49,
	MSG_ADDBSTATE = 0x4A,
	MSG_SUBBSTATE = 0x4B,
	MSG_CANTSAVEREVIVALPT = 0x4C,
	MSG_NOTTRANSFORMBYFLAG = 0x4D,
	MSG_CANTDROPFLAG = 0x4E,
	MSG_PUTOFFAFTER10SEC = 0x4F,
	MSG_MYTELEPORTERROR = 0x50,
	MSG_UPGRADELEVELSUBMONEY = 0x51,
	MSG_UPGRADELEVELDESTORY = 0x52,
	MSG_FRD = 0x53,
	MSG_NOTSTALLATCASTLE = 0x54,
	MSG_MAIL = 0x55,
	MSG_ITEMMONSTERUSED = 0x56,
	MSG_ITEMMONSTEROPEN = 0x57,
	MSG_ITEMMONSTEROPENED = 0x58,
	MSG_ITEMMONSTERCANCELED = 0x59,
	MSG_LUCKYBLOW = 0x5A,
	MSG_ALREADYMIRRORSET = 0x5B,
	MSG_NOMIRROR = 0x5C,
	MSG_MIRRORSET = 0x5D,
	MSG_MIRRORBROKEN = 0x5E,
	MSG_TB_CREATE0 = 0x5F,
	MSG_TB_CREATE1 = 0x60,
	MSG_TB_CREATE2 = 0x61,
	MSG_TB_CREATE3 = 0x62,
	MSG_TB_CREATE4 = 0x63,
	MSG_CHANGENAME = 0x64,
	MSG_SKILLBUFFALREADYUSE = 0x65,
	MSG_ALREADYCHANGEDFACE = 0x66,
	MSG_FAIL_DELETEGUILDMASTER = 0x67,
	MSG_INSUFFICIENTITEM = 0x68,
	MSG_REMAINTIME = 0x69,
	MSG_INIT_2ND_JOB = 0x6A,
	MSG_BILLINGEXTENDED = 0x6B,
	MSG_BILLINGTYPECHANGED = 0x6C,
	MSG_NOMOREPUTON = 0x6D,
	MSG_UPPER_CHANCE_STONE = 0x6E,
	MSG_EX_GEUMJUN_JAMOJUN = 0x6F,
	MSG_EVENT_LIMIT = 0x70,
	MSG_ITEMDROP = 0x71,
	MSG_EXISTPARTYONPK = 0x72,
	MSG_NODOORKEY = 0x73,
	MGS_DOOROPEN = 0x74,
	MGS_DOORCLOSE = 0x75,
	MSG_SIEGEGUNSETCANCEL = 0x76,
	MSG_SIEGEGUNIMPOSSIBLE = 0x77,
	MSG_SIEGEGUNUSED = 0x78,
	MSG_SIEGEGUNUNSETUSED = 0x79,
	MSG_SIEGEGUNSETCLASS = 0x7A,
	MSG_SIEGEGUNCONDITION = 0x7B,
	MSG_SIEGEGUNDIFFERNT = 0x7C,
	MSG_SIEGEGUNHANDLING = 0x7D,
	MSG_SIEGEGUNREMOVECLASS = 0x7E,
	MSG_SIEGEGUNREMOVEHANDLING = 0x7F,
	MSG_SIEGEGUNREMOVECANCEL = 0x80,
	MSG_SIEGEGUNSET = 0x81,
	MSG_SIEGEGUNNOSKILL = 0x82,
	MSG_SIEGEGUNGUILD = 0x83,
	MSG_SIEGEGUNUNSETIMPOSSIBLE = 0x84,
	MSG_SIEGEGUNNOTGUILD = 0x85,
	MSG_SIEGEGUNNORELATION = 0x86,
	MSG_CANTSIEGEITEMUSE = 0x87,
	MSG_LONGRESTUSER = 0x88,
	MSG_RETURNCOOLTIME = 0x89,
	MSG_MIXING = 0x8A,
};

/* 158 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::_Redbl;

/* 159 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::_Redbl;

/* 160 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::_Redbl;

/* 162 */
enum C2S_PROTOCOL : __int32
{
	C2S_RESTOREPLAYER = 0x0,
	C2S_ACKGUID = 0x1,
	C2S_LOGIN = 0x2,
	C2S_ACKCRC = 0x3,
	C2S_NEWPLAYER = 0x4,
	C2S_ALIVE = 0x5,
	C2S_COPYPLAYER = 0x6,
	C2S_DELPLAYER = 0x7,
	C2S_CONNECT = 0x8,
	C2S_ANS_CODE = 0x9,
	C2S_LOADPLAYER = 0xA,
	C2S_START = 0xB,
	C2S_EX_GEUMJUN_JAMOJUN = 0xC,
	C2S_TOOJUN = 0xD,
	C2S_KAL21 = 0xE,
	C2S_ATTACK = 0xF,
	C2S_SKILL = 0x10,
	C2S_CHATTING = 0x11,
	C2S_TELEPORT = 0x12,
	C2S_RESTART = 0x13,
	C2S_MOVE_ON = 0x14,
	C2S_MOVE_END = 0x15,
	C2S_ASKNPC = 0x16,
	C2S_ITEMLIST = 0x17,
	C2S_BUYITEM = 0x18,
	C2S_SELLITEM = 0x19,
	C2S_DROPITEM = 0x1A,
	C2S_GAMEEXIT = 0x1B,
	C2S_SHOWOFFITEM = 0x1C,
	C2S_ACTION = 0x1D,
	C2S_UPDATEPROPERTY = 0x1E,
	C2S_REST = 0x1F,
	C2S_PICKUPITEM = 0x20,
	C2S_USEITEM = 0x21,
	C2S_ASKTRADE = 0x22,
	C2S_ANS_ASKTRADE = 0x23,
	C2S_CANCELTRADE = 0x24,
	C2S_REVIVAL = 0x25,
	C2S_SIEGEGUN = 0x26,
	C2S_SIEGEGUNSET = 0x27,
	C2S_SIEGEGUNCONTROL = 0x28,
	C2S_LEARNSKILL = 0x29,
	C2S_SKILLUP = 0x2A,
	C2S_PRESKILL = 0x2B,
	C2S_ASKPARTY = 0x2C,
	C2S_ANS_ASKPARTY = 0x2D,
	C2S_GUILD = 0x2E,
	C2S_LEAVEPARTY = 0x2F,
	C2S_EXILEPARTY = 0x30,
	C2S_PUTINSTORAGE = 0x31,
	C2S_PUTOUTSTORAGE = 0x32,
	C2S_QUEST = 0x33,
	C2S_STORAGEINFO = 0x34,
	C2S_PET = 0x35,
	C2S_ANNUALEVENTREST = 0x36,
	C2S_ANNUALEVENTNEW = 0x37,
	C2S_SAVEREVIVALPT = 0x38,
	C2S_ENCHANTITEM = 0x39,
	C2S_SETSTALLINFO = 0x3A,
	C2S_MOD2NDJOB = 0x3B,
	C2S_UPPER_CHANCE_STONE = 0x3C,
	C2S_PLAYER_ANIMATION = 0x3D,
	C2S_TRADEITEM = 0x3E,
	C2S_TRASHITEM = 0x3F,
	C2S_FRD = 0x40,
	C2S_PUTONITEM = 0x41,
	C2S_PUTOFFITEM = 0x42,
	C2S_SWITCHSTALL = 0x43,
	C2S_EVENT = 0x44,
	C2S_QUESTJOB_END = 0x45,
	C2S_GETSTALLINFO = 0x46,
	C2S_BUYITEMATSTALL = 0x47,
	C2S_MORA = 0x48,
	C2S_COOKING = 0x49,
	C2S_ANS_REVIVALSKILL = 0x4A,
	C2S_SKILLREDISTRIBUTE = 0x4B,
	C2S_BOKJOOMUNY = 0x4C,
	C2S_DANJI = 0x4D,
	C2S_INITSTAT = 0x4E,
	C2S_PKBULLETININFO = 0x4F,
	C2S_ASKPVP = 0x50,
	C2S_ANS_ASKPVP = 0x51,
	C2S_TRANSFORM = 0x52,
	C2S_BLESS = 0x53,
	C2S_TRANSFORMSKILL = 0x54,
	C2S_MLM = 0x55,
	C2S_MOVEDASH_ON = 0x56,
	C2S_MOVEDASH_END = 0x57,
	C2S_PKSTATUS = 0x58,
	C2S_SHORTCUT = 0x59,
	C2S_SETMYTELPT = 0x5A,
	C2S_UPGRADEITEM = 0x5B,
	C2S_MAIL = 0x5C,
	C2S_CANCELITEMMONSTER = 0x5D,
	C2S_GETITEMMONSTER = 0x5E,
	C2S_CHANGEGUILDNAME = 0x5F,
	C2S_CHANGEPLAYERNAME = 0x60,
	C2S_NPC = 0x61,
	C2S_MIXING = 0x62,
	C2S_END = 0x63,
};

/* 163 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >::_Redbl;

/* 164 */
enum $6D9AB000E79D691B009392C4D78AE8A5 : __int32
{
	_Multi = 0x0,
};

/* 165 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >::_Redbl;

/* 166 */
typedef $6D9AB000E79D691B009392C4D78AE8A5 $2FF91253294FCFB042CACC1E0C1D9866;

/* 167 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >::_Redbl;

/* 168 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >::_Redbl;

/* 169 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >::_Redbl;

/* 170 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::_Redbl;

/* 171 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::_Redbl;

/* 172 */
enum DIFF_LV_TYPE : __int32
{
	DLT_GRAY = 0x0,
	DLT_BLUE = 0x1,
	DLT_GREEN = 0x2,
	DLT_YELLOW = 0x3,
	DLT_ORANGE = 0x4,
	DLT_RED = 0x5,
	DLT_VIOLET = 0x6,
};

/* 173 */
enum GUILD_MSG : __int32
{
	GMSG_CONTINUE = 0x0,
	GMSG_ERROR = 0x1,
	GMSG_CONNECT = 0x2,
	GMSG_DISCONNECT = 0x3,
	GMSG_NOMEMBER = 0x4,
	GMSG_TODAYMESSAGE = 0x5,
	GMSG_DATE_LIMIT = 0x6,
	GMSG_CREATE_LEVEL_LIMIT = 0x7,
	GMSG_CREATE_MONEY_LIMIT = 0x8,
	GMSG_CREATE_POINT_LIMIT = 0x9,
	GMSG_CREATE_NOPARTY = 0xA,
	GMSG_CREATE_NOHEAD = 0xB,
	GMSG_CREATE_NOFULLPARTY = 0xC,
	GMSG_CREATE_ALREADYMEMBER = 0xD,
	GMSG_CREATE_CONSENTWAIT = 0xE,
	GMSG_CREATE_ALREADYCANCEL = 0xF,
	GMSG_CREATE_ALREADYCONSENT = 0x10,
	GMSG_CREATE_CONSENT = 0x11,
	GMSG_CREATE_INVALID_NAME = 0x12,
	GMSG_CREATE_SAMENAME = 0x13,
	GMSG_CREATE_NOT_ALLCONSENT = 0x14,
	GMSG_CREATE_COMPLET = 0x15,
	GMSG_LACK_SKILL = 0x16,
	GMSG_CONFLUX_TEMPMEMBERFULL = 0x17,
	GMSG_CONFLUX_DISCONNECT = 0x18,
	GMSG_CONFLUX_ALREADYMEMBER = 0x19,
	GMSG_CONFLUX_OFFER_DISCONNECT = 0x1A,
	GMSG_CONFLUX_SENDOK = 0x1B,
	GMSG_CONFLUX_CANCEL = 0x1C,
	GMSG_CONFLUX_U_ALREADYMEMBER = 0x1D,
	GMSG_CONFLUX_COMPLET = 0x1E,
	GMSG_SECESSION_LEADER = 0x1F,
	GMSG_SECESSION = 0x20,
	GMSG_SECESSION_COMPLET = 0x21,
	GMSG_BANISH_LEADER = 0x22,
	GMSG_BANISH = 0x23,
	GMSG_BANISH_COMPLET = 0x24,
	GMSG_APPOINTMENT_LEADER = 0x25,
	GMSG_APPOINTMENT_FULL = 0x26,
	GMSG_SUBLEADER_DATE_LIMIT = 0x27,
	GMSG_APPOINTMENT_MEMBERFULL = 0x28,
	GMSG_APPOINTMENT_SAMECLASS = 0x29,
	GMSG_APPOINTMENT_COMPLET = 0x2A,
	GMSG_DISSOLUTION = 0x2B,
	GMSG_DISSOLUTION_COMPLET = 0x2C,
	GMSG_TITLE_INVALID = 0x2D,
	GMSG_TITLE_COMPLET = 0x2E,
	GMSG_SETSKILL_COMPLET = 0x2F,
	GMSG_SETSTANDARD_COMPLET = 0x30,
	GMSG_SETCONNECTTELL_SAME = 0x31,
	GMSG_SETCONNECTTELL_COMPLET = 0x32,
	GMSG_HAVE_NO_EXP = 0x33,
	GMSG_EXPADD = 0x34,
	GMSG_EXPFULL = 0x35,
	GMSG_MEMBERLEVELUP = 0x36,
	GMSG_UNKNOWN_CLASS = 0x37,
	GMSG_GUILDNOTICE_INVALID = 0x38,
	GMSG_SKILL_LEVEL_LIMIT = 0x39,
	GMSG_ALLIANCE_U_ALREADY = 0x3A,
	GMSG_ALLIANCE_INVALID_DATE = 0x3B,
	GMSG_ALLIANCE_DISCONNECT = 0x3C,
	GMSG_ALLIANCE_ALREADY = 0x3D,
	GMSG_ALLIANCE_OFFER = 0x3E,
	GMSG_ALLIANCE_OFFER_SEND = 0x3F,
	GMSG_ALLIANCE_FULL = 0x40,
	GMSG_ALLIANCE_COMPLET = 0x41,
	GMSG_ALLIANCE_CANCEL = 0x42,
	GMSG_ALLIANCE_EXPIRE = 0x43,
	GMSG_ALLIANCE_NO_PERIOD = 0x44,
	GMSG_ALLIANCE_POSTPONE = 0x45,
	GMSG_WARDECLARE_NO_PERIOD = 0x46,
	GMSG_WARDECLARE_NO_LEADER = 0x47,
	GMSG_WARDECLARE_LORD = 0x48,
	GMSG_WARDECLARE_ALLIANCE = 0x49,
	GMSG_WARDECLARE_MONEY_LIMIT = 0x4A,
	GMSG_WARDECLARE_ALREADYDECLARE = 0x4B,
	GMSG_WARDECLARE = 0x4C,
	GMSG_WARDECLARE_COUNT_OVER = 0x4D,
	GMSG_WARBEGIN = 0x4E,
	GMSG_WAREND_WIN = 0x4F,
	GMSG_WAREND_LOSE = 0x50,
	GMSG_WARUNFURL_NO_DECLARE = 0x51,
	GMSG_WARUNFURL_ALREADY = 0x52,
	GMSG_WARUNFURL_STANDARDLIVE = 0x53,
	GMSG_WAR_UNFURLSTANDARD_BEGIN = 0x54,
	GMSG_WAR_UNFUELCOMPLET = 0x55,
	GMSG_TAX_NO_LORD = 0x56,
	GMSG_TAX_DEVIATE = 0x57,
	GMSG_TAX_SET_RATE_COMPLET = 0x58,
	GMSG_GATE_LIMIT = 0x59,
	GMSG_SET_GATELIMIT_COMPLET = 0x5A,
	GMSG_WAR_NOPERIOD = 0x5B,
	GMSG_WAR_NO_LEADER = 0x5C,
	GMSG_WAR_NO_RELATION = 0x5D,
	GMSG_CONFLUX_NOPERIOD = 0x5E,
	GMSG_WARUNFURL_U_ALREADY = 0x5F,
	GMSG_GATE_LIMIT_GUILD = 0x60,
	GMSG_GATE_LIMIT_ALLIANCE = 0x61,
	GMSG_WAR_BROKEN_STANDARD = 0x62,
	GMSG_WAR_BROKEN_GATE = 0x63,
	GMSG_WAR_TIME = 0x64,
	GMSG_TAX_LEVY = 0x65,
	GMSG_SETSTANDARD_FAILED = 0x66,
	GMSG_SETSTANDARD_FAILEDBYLEVEL = 0x67,
	GMSG_WAR_LORDDECLARE_TIME = 0x68,
	GMSG_WAR_EXTENDED_TIME = 0x69,
	GMSG_WAR_CHANGELORD = 0x6A,
	GMSG_DISSOLUTION_FAIL = 0x6B,
};

/* 174 */
enum _CM_SERVICE_NODE_TYPE : __int32
{
	DriverType = 0x1,
	FileSystemType = 0x2,
	Win32ServiceOwnProcess = 0x10,
	Win32ServiceShareProcess = 0x20,
	AdapterType = 0x4,
	RecognizerType = 0x8,
};

/* 175 */
enum _CM_SERVICE_LOAD_TYPE : __int32
{
	BootLoad = 0x0,
	SystemLoad = 0x1,
	AutoLoad = 0x2,
	DemandLoad = 0x3,
	DisableLoad = 0x4,
};

/* 176 */
enum _CM_ERROR_CONTROL_TYPE : __int32
{
	IgnoreError = 0x0,
	NormalError = 0x1,
	SevereError = 0x2,
	CriticalError = 0x3,
};

/* 177 */
enum _THREAD_WRITE_FLAGS : __int32
{
	ThreadWriteThread = 0x1,
	ThreadWriteStack = 0x2,
	ThreadWriteContext = 0x4,
	ThreadWriteBackingStore = 0x8,
	ThreadWriteInclassionWindow = 0x10,
	ThreadWriteThreadData = 0x20,
};

/* 178 */
enum WELL_KNOWN_SID_TYPE : __int32
{
	WinNullSid = 0x0,
	WinWorldSid = 0x1,
	WinLocalSid = 0x2,
	WinCreatorOwnerSid = 0x3,
	WinCreatorGroupSid = 0x4,
	WinCreatorOwnerServerSid = 0x5,
	WinCreatorGroupServerSid = 0x6,
	WinNtAuthoritySid = 0x7,
	WinDialupSid = 0x8,
	WinNetworkSid = 0x9,
	WinBatchSid = 0xA,
	WinInteractiveSid = 0xB,
	WinServiceSid = 0xC,
	WinAnonymousSid = 0xD,
	WinProxySid = 0xE,
	WinEnterpriseControllersSid = 0xF,
	WinSelfSid = 0x10,
	WinAuthenticatedUserSid = 0x11,
	WinRestrictedCodeSid = 0x12,
	WinTerminalServerSid = 0x13,
	WinRemoteLogonIdSid = 0x14,
	WinLogonIdsSid = 0x15,
	WinLocalSystemSid = 0x16,
	WinLocalServiceSid = 0x17,
	WinNetworkServiceSid = 0x18,
	WinBuiltinDomainSid = 0x19,
	WinBuiltinAdministratorsSid = 0x1A,
	WinBuiltinUsersSid = 0x1B,
	WinBuiltinGuestsSid = 0x1C,
	WinBuiltinPowerUsersSid = 0x1D,
	WinBuiltinAccountOperatorsSid = 0x1E,
	WinBuiltinSystemOperatorsSid = 0x1F,
	WinBuiltinPrintOperatorsSid = 0x20,
	WinBuiltinBackupOperatorsSid = 0x21,
	WinBuiltinReplicatorSid = 0x22,
	WinBuiltinPreWindows2000CompatibleAccessSid = 0x23,
	WinBuiltinRemoteDesktopUsersSid = 0x24,
	WinBuiltinNetworkConfigurationOperatorsSid = 0x25,
	WinAccountAdministratorSid = 0x26,
	WinAccountGuestSid = 0x27,
	WinAccountKrbtgtSid = 0x28,
	WinAccountDomainAdminsSid = 0x29,
	WinAccountDomainUsersSid = 0x2A,
	WinAccountDomainGuestsSid = 0x2B,
	WinAccountComputersSid = 0x2C,
	WinAccountControllersSid = 0x2D,
	WinAccountCertAdminsSid = 0x2E,
	WinAccountSchemaAdminsSid = 0x2F,
	WinAccountEnterpriseAdminsSid = 0x30,
	WinAccountPolicyAdminsSid = 0x31,
	WinAccountRasAndIasServersSid = 0x32,
	WinNTLMAuthenticationSid = 0x33,
	WinDigestAuthenticationSid = 0x34,
	WinSChannelAuthenticationSid = 0x35,
	WinThisOrganizationSid = 0x36,
	WinOtherOrganizationSid = 0x37,
	WinBuiltinIncomingForestTrustBuildersSid = 0x38,
	WinBuiltinPerfMonitoringUsersSid = 0x39,
	WinBuiltinPerfLoggingUsersSid = 0x3A,
};

/* 179 */
enum PK_MSG : __int32
{
	PKMSG_ONPK = 0x0,
	PKMSG_ONPKAROUND = 0x1,
	PKMSG_ONPKDIE = 0x2,
	PKMSG_PKDIE = 0x3,
	PKMSG_OFFPK = 0x4,
	PKMSG_ONPKKILL = 0x5,
	PKMSG_LIMIT_OFFPKTICK = 0x6,
	PKMSG_LIMIT_TRADESELF = 0x7,
	PKMSG_LIMIT_TRADEOTHER = 0x8,
	PKMSG_LIMIT_FISH = 0x9,
	PKMSG_LIMIT_STALL = 0xA,
	PKMSG_LIMIT_GUILDINVITE = 0xB,
	PKMSG_LIMIT_PARTYSELF = 0xC,
	PKMSG_LIMIT_PARTYOTHER = 0xD,
	PKMSG_SCANONPKWARNING = 0xE,
	PKMSG_LIMIT_ONSUICIDE = 0xF,
};

/* 180 */
enum UPGRADEITEM_TYPE : __int32
{
	UI_DESTROY = 0x0,
	UI_RATEUP = 0x1,
	UI_LEVEL = 0x2,
};

/* 181 */
enum PLAYER_ANIMATION : __int32
{
	PA_GREETING = 0x0,
	PA_AFFIRMATION = 0x1,
	PA_DENY = 0x2,
	PA_SMILE = 0x3,
	PA_EMBRACE = 0x4,
	PA_EXCITING = 0x5,
	PA_ANGRY = 0x6,
	PA_TIRED = 0x7,
	PA_PRAISE = 0x8,
	PA_APPLAUSE = 0x9,
	PA_RASINGHAND = 0xA,
	PA_CHEERS = 0xB,
	PA_POINTTO = 0xC,
	PA_PROVOKE = 0xD,
	PA_DANCE = 0xE,
	PA_FAIRLY = 0xF,
	PA_FORWARD = 0x10,
	PA_KISS = 0x11,
	PA_SHY = 0x12,
	PA_DRINKING = 0x13,
};

/* 182 */
enum _MODULE_WRITE_FLAGS : __int32
{
	ModuleWriteModule = 0x1,
	ModuleWriteDataSeg = 0x2,
	ModuleWriteMiscRecord = 0x4,
	ModuleWriteCvRecord = 0x8,
	ModuleReferencedByMemory = 0x10,
};

/* 183 */
enum SIEGEGUNSET : __int32
{
	SG_SET = 0x0,
	SG_SETTING = 0x1,
	SG_SETEND = 0x2,
	SG_UNSETTING = 0x3,
	SG_UNSETEND = 0x4,
};

/* 184 */
enum _JOBOBJECTINFOCLASS : __int32
{
	JobObjectBasicAccountingInformation = 0x1,
	JobObjectBasicLimitInformation = 0x2,
	JobObjectBasicProcessIdList = 0x3,
	JobObjectBasicUIRestrictions = 0x4,
	JobObjectSecurityLimitInformation = 0x5,
	JobObjectEndOfJobTimeInformation = 0x6,
	JobObjectAssociateCompletionPortInformation = 0x7,
	JobObjectBasicAndIoAccountingInformation = 0x8,
	JobObjectExtendedLimitInformation = 0x9,
	JobObjectJobSetInformation = 0xA,
	MaxJobObjectInfoClass = 0xB,
};

/* 185 */
enum _MINIDUMP_TYPE : __int32
{
	MiniDumpNormal = 0x0,
	MiniDumpWithDataSegs = 0x1,
	MiniDumpWithFullMemory = 0x2,
	MiniDumpWithHandleData = 0x4,
	MiniDumpFilterMemory = 0x8,
	MiniDumpScanMemory = 0x10,
	MiniDumpWithUnloadedModules = 0x20,
	MiniDumpWithIndirectlyReferencedMemory = 0x40,
	MiniDumpFilterModulePaths = 0x80,
	MiniDumpWithProcessThreadData = 0x100,
	MiniDumpWithPrivateReadWriteMemory = 0x200,
};

/* 186 */
enum _LOGICAL_PROCESSOR_RELATIONSHIP : __int32
{
	RelationProcessorCore = 0x0,
	RelationNumaNode = 0x1,
};

/* 187 */
enum _WSAEcomparator : __int32
{
	COMP_EQUAL = 0x0,
	COMP_NOTLESS = 0x1,
};

/* 188 */
enum COUNTRY_CODE : __int32
{
	N_KR = 0x0,
	N_CN = 0x1,
	N_EN = 0x2,
};

/* 189 */
enum _IMAGEHLP_STATUS_REASON : __int32
{
	BindOutOfMemory = 0x0,
	BindRvaToVaFailed = 0x1,
	BindNoRoomInImage = 0x2,
	BindImportModuleFailed = 0x3,
	BindImportProcedureFailed = 0x4,
	BindImportModule = 0x5,
	BindImportProcedure = 0x6,
	BindForwarder = 0x7,
	BindForwarderNOT = 0x8,
	BindImageModified = 0x9,
	BindExpandFileHeaders = 0xA,
	BindImageComplete = 0xB,
	BindMismatchedSymbols = 0xC,
	BindSymbolsNotUpdated = 0xD,
	BindImportProcedure32 = 0xE,
	BindImportProcedure64 = 0xF,
	BindForwarder32 = 0x10,
	BindForwarder64 = 0x11,
	BindForwarderNOT32 = 0x12,
	BindForwarderNOT64 = 0x13,
};

/* 190 */
enum MAP_STATE : __int32
{
	MS_NONE = 0x0,
	MS_QUAKE1 = 0x1,
	MS_QUAKE2 = 0x2,
	MS_QUAKE3 = 0x3,
	MS_QUAKE4 = 0x4,
	MS_TB_CREATE = 0x5,
};

/* 191 */
enum MONSTER_RACE : __int32
{
	MR_MAGUNI = 0x0,
	MR_NOTMAGUNI = 0x1,
	MR_CASTLESTANDARD = 0x2,
	MR_CASTLEGATE = 0x3,
	MR_ITEM = 0x4,
	MR_MAGIC = 0x5,
	MR_INACTIVE = 0x6,
	MR_EGG = 0x7,
	MR_COCOON = 0x8,
	MR_FIREFLOWER = 0x9,
	MR_SIEGEGUN = 0xA,
	MR_SIEGEGUNBALL = 0xB,
};

/* 192 */
enum DROPITEMMASK : __int32
{
	G1_WEAPON = 0x1,
	G1_ARMOR = 0x2,
	G1_ENCHANT = 0x3,
	G1_GENERAL = 0x4,
	G1_ORNAMENT = 0x5,
	G2W_1HAND = 0x1,
	G2W_2HAND = 0x2,
	G2A_MAIN = 0x3,
	G2A_SUB = 0x4,
	G2E_PREFIX = 0x5,
	G2E_UPGRADE = 0x6,
	G2E_ETC = 0x7,
	G2G_USABLE = 0x8,
	G2G_UNUSABLE = 0x9,
	G2G_QUEST = 0xA,
	G2G_MONEY = 0xB,
	G2G_ETC = 0xC,
	G2O_TRINKET = 0xD,
	G2O_NECKLACE = 0xE,
	G2O_RING = 0xF,
	G3W_SHORT = 0x1,
	G3W_LONG = 0x2,
	G3A_UPPER = 0x3,
	G3A_HELMET = 0x4,
	G3A_GAUNTLET = 0x5,
	G3A_BOOTS = 0x6,
	G3A_LOWER = 0x7,
	G3A_SHIELD = 0x8,
	G3A_MASK = 0x9,
	G3A_FLAG = 0xA,
	G3A_TRANSFORM = 0xB,
	G3E_CHARM_WEAPON = 0xC,
	G3E_CHARM_ARMOR = 0xD,
	G3E_CHARM_ORNAMENT = 0xE,
	G3E_CHARM_ATTACK = 0xF,
	G3E_CHARM_MAGIC = 0x10,
	G3E_CHARM_DEFENSE = 0x11,
	G3E_CHARM_HIT = 0x12,
	G3E_CHARM_DODGE = 0x13,
	G3E_REPAIRKIT = 0x14,
	G3E_PROTECT = 0x15,
	G4A_SWORD = 0x1,
	G4A_BOW = 0x2,
	G4A_WAND = 0x3,
};

/* 193 */
enum _SC_ACTION_TYPE : __int32
{
	SC_ACTION_NONE = 0x0,
	SC_ACTION_RESTART = 0x1,
	SC_ACTION_REBOOT = 0x2,
	SC_ACTION_RUN_COMMAND = 0x3,
};

/* 194 */
enum _WSAESETSERVICEOP : __int32
{
	RNRSERVICE_REGISTER = 0x0,
	RNRSERVICE_DEREGISTER = 0x1,
	RNRSERVICE_DELETE = 0x2,
};

/* 195 */
enum MLM_FLAG : __int32
{
	M_FEE = 0x0,
	M_GMASTER = 0x1,
	M_MASTER = 0x2,
	M_FELLA = 0x3,
	M_PUPIL = 0x4,
	MLM_C_ASK1 = 0x0,
	MLM_C_INFO = 0x1,
	MLM_C_ASK2 = 0x2,
	MLM_C_MSG = 0x3,
	MLM_A_SET = 0x0,
	MLM_A_INFO1 = 0x1,
	MLM_A_INFO2 = 0x2,
	MLM_A_RESET = 0x3,
	MLM_A_SETBREAK = 0x4,
	MLM_M_ASKRELATION = 0x0,
	MLM_M_REPLYFROMCLNT = 0x1,
	MLM_M_REPLYFROMAUTH = 0x2,
	MLM_M_BREAKRELATION = 0x3,
	MLM_M_INFORELATION = 0x4,
	MLM_M_CONFIRM = 0x5,
	MLM_M_SETMSG = 0x6,
	MLM_M_GETMSG = 0x7,
	MLM_M_SENDMSG = 0x8,
	MLM_D_INSERT = 0x0,
	MLM_D_BREAKONPUPIL = 0x1,
	MLM_D_BREAKONMASTER = 0x2,
	MLM_D_SAVEFEE = 0x3,
	MLM_D_SETMSG = 0x4,
	MLM_D_GETMSG = 0x5,
	MLMA_SETFAIL = 0x0,
	MLMA_SETFIRST = 0x1,
	MLMA_SETSECOND = 0x2,
};

/* 196 */
enum _TAPE_DRIVE_PROBLEM_TYPE : __int32
{
	TapeDriveProblemNone = 0x0,
	TapeDriveReadWriteWarning = 0x1,
	TapeDriveReadWriteError = 0x2,
	TapeDriveReadWarning = 0x3,
	TapeDriveWriteWarning = 0x4,
	TapeDriveReadError = 0x5,
	TapeDriveWriteError = 0x6,
	TapeDriveHardwareError = 0x7,
	TapeDriveUnsupportedMedia = 0x8,
	TapeDriveScsiConnectionError = 0x9,
	TapeDriveTimetoClean = 0xA,
	TapeDriveCleanDriveNow = 0xB,
	TapeDriveMediaLifeExpired = 0xC,
	TapeDriveSnappedTape = 0xD,
};

/* 197 */
enum IMPORT_OBJECT_TYPE : __int32
{
	IMPORT_OBJECT_CODE = 0x0,
	IMPORT_OBJECT_DATA = 0x1,
	IMPORT_OBJECT_CONST = 0x2,
};

/* 198 */
enum IMPORT_OBJECT_NAME_TYPE : __int32
{
	IMPORT_OBJECT_ORDINAL = 0x0,
	IMPORT_OBJECT_NAME = 0x1,
	IMPORT_OBJECT_NAME_NO_PREFIX = 0x2,
	IMPORT_OBJECT_NAME_UNDECORATE = 0x3,
};

/* 199 */
enum FRD_FLAG : __int32
{
	FRD_MSG_LIMITMAX = 0x0,
	FRD_MSG_ALREADYINSERT = 0x1,
	FRD_MSG_NOTEXISTPLAYER = 0x2,
	FRD_C_INSERT = 0x0,
	FRD_C_DELETE = 0x1,
	FRD_C_LIST = 0x2,
	FRD_C_REFRESH = 0x3,
	FRD_M_INSERT = 0x0,
	FRD_M_DELETE = 0x1,
	FRD_M_PID = 0x2,
	FRD_M_LOAD = 0x3,
	FRD_M_REFRESH = 0x4,
	FRD_D_INSERT = 0x0,
	FRD_D_DELETE = 0x1,
	FRD_D_PID = 0x2,
	FRD_D_LOAD = 0x3,
};

/* 200 */
enum ReplacesCorHdrNumericDefines : __int32
{
	COMIMAGE_FLAGS_ILONLY = 0x1,
	COMIMAGE_FLAGS_32BITREQUIRED = 0x2,
	COMIMAGE_FLAGS_IL_LIBRARY = 0x4,
	COMIMAGE_FLAGS_STRONGNAMESIGNED = 0x8,
	COMIMAGE_FLAGS_TRACKDEBUGDATA = 0x10000,
	COR_VERSION_MAJOR_V2 = 0x2,
	COR_VERSION_MAJOR = 0x2,
	COR_VERSION_MINOR = 0x0,
	COR_DELETED_NAME_LENGTH = 0x8,
	COR_VTABLEGAP_NAME_LENGTH = 0x8,
	NATIVE_TYPE_MAX_CB = 0x1,
	COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 0xFF,
	IMAGE_COR_MIH_METHODRVA = 0x1,
	IMAGE_COR_MIH_EHRVA = 0x2,
	IMAGE_COR_MIH_BASICBLOCK = 0x8,
	COR_VTABLE_32BIT = 0x1,
	COR_VTABLE_64BIT = 0x2,
	COR_VTABLE_FROM_UNMANAGED = 0x4,
	COR_VTABLE_CALL_MOST_DERIVED = 0x10,
	IMAGE_COR_EATJ_THUNK_SIZE = 0x20,
	MAX_CLASS_NAME = 0x400,
	MAX_PACKAGE_NAME = 0x400,
};

/* 201 */
enum _SC_STATUS_TYPE : __int32
{
	SC_STATUS_PROCESS_INFO = 0x0,
};

/* 202 */
enum _SC_ENUM_TYPE : __int32
{
	SC_ENUM_PROCESS_INFO = 0x0,
};

/* 203 */
enum MAIL_FLAG : __int32
{
	MAIL_SR_SUCCESS = 0x0,
	MAIL_SR_LIMITMAX = 0x1,
	MAIL_SR_NOTEXISTPLAYER = 0x2,
	MAIL_SR_NOTENOUGHMONEY = 0x3,
	MAIL_SR_NOTEXISTITEM = 0x4,
	MAIL_SR_NOTGETMID = 0x5,
	MAIL_SR_FAILSCANPLAYER = 0x6,
	MAIL_SFLAG_NONE = 0x0,
	MAIL_SFLAG_READ = 0x1,
	MAIL_SFLAG_SENDPROC = 0x2,
	MAIL_SFLAG_ITEMRECVPROC = 0x3,
	MAIL_SF_SUCCESS = 0x0,
	MAIL_SF_FAIL = 0x1,
	MAIL_IRF_SUCCESS = 0x0,
	MAIL_IRF_FAIL = 0x1,
	MAIL_CR_ITEMRECVPROC = 0x1,
	MAIL_CR_ALREADYRETURN = 0x2,
	MAIL_MSG_NEWMAIL = 0x0,
	MAIL_MSG_RETURN = 0x1,
	MAIL_MSG_DELETE = 0x2,
	MAIL_MSG_SENDPROC = 0x3,
	MAIL_MSG_ITEMRECVPROC = 0x4,
	MAIL_MSG_ALREADYRETURN = 0x5,
	MAIL_MSG_NOTENOUGHMONEY = 0x6,
	MAIL_MSG_ITEMRECVSUCCESS = 0x7,
	MAIL_MSG_ITEMRECVNOSLOT = 0x8,
	MAIL_MSG_ITEMATSTALL = 0x9,
	MAIL_T_GENERAL = 0x0,
	MAIL_T_PARCEL = 0x1,
	MAIL_T_RETURN = 0x2,
	MAIL_T_PAY = 0x3,
	MAIL_T_NOTICE = 0x4,
	MAIL_C_SEND_RESULT = 0x0,
	MAIL_C_LIST = 0x1,
	MAIL_C_MSG = 0x2,
	MAIL_C_UPDATEINFO = 0x3,
	MAIL_M_SEND = 0x0,
	MAIL_M_SEND_RESULT = 0x1,
	MAIL_M_REFRESH = 0x2,
	MAIL_M_LOAD = 0x3,
	MAIL_M_RETURNPROC = 0x4,
	MAIL_M_CHECK_RESULT = 0x5,
	MAIL_M_GETMSG = 0x6,
	MAIL_M_SETMSG = 0x7,
	MAIL_M_RETURN = 0x8,
	MAIL_M_DELETE = 0x9,
	MAIL_M_ITEMRECV = 0xA,
	MAIL_M_ITEMRECV_RESULT = 0xB,
	MAIL_D_SEND = 0x0,
	MAIL_D_SEND_FLAG = 0x1,
	MAIL_D_LOAD = 0x2,
	MAIL_D_RETURNPROC = 0x3,
	MAIL_D_GETMSG = 0x4,
	MAIL_D_RETURN = 0x5,
	MAIL_D_DELETE = 0x6,
	MAIL_D_ITEMRECV = 0x7,
	MAIL_D_ITEMRECV_FLAG = 0x8,
};

/* 204 */
enum EVENT_FLAG : __int32
{
	EF_INVALIDCARDID = 0x0,
	EF_USEDCARDID = 0x1,
	EF_NOMORECHANCE = 0x2,
	EF_SUCCESS_CARDEVENT = 0x3,
	EF_ALREADYRECOMMAND = 0x4,
	EF_INVALIDACCOUNT = 0x5,
	EF_INVALIDPLAYER = 0x6,
	EF_NOTNEWACCOUNT = 0x7,
	EF_SAMEACCOUNT = 0x8,
	EF_SUCCESS_SPONSOREVENT = 0x9,
	EF_OVERLEVEL10 = 0xA,
	EF_UNDERLEVEL16 = 0xB,
	EF_OVERPUPIL20 = 0xC,
	EF_ALREADYGOTMASTER = 0xD,
	EF_REJECTEDTOBEMASTER = 0xE,
	EF_PLAYERALREADYGOTMASTER = 0xF,
	EF_CANTBREAKRELATION = 0x10,
	EF_GOTPUPIL = 0x11,
	EF_GOTMASTER = 0x12,
	EF_GOT20KMONEYFOR16 = 0x13,
	EF_GOT20KMONEYFORPUPIL16 = 0x14,
	EF_BROKERELATION = 0x15,
	EF_INVALIDMLMMSG = 0x16,
	EF_MLMMSGUPDATED = 0x17,
	EF_UNDERLEVEL10 = 0x18,
	EF_DEFICIENT_DICECOIN = 0x19,
	EF_SUCCESS_DICEEVENT = 0x1A,
	EB_SPONSOR = 0x1,
	EB_MLM_MASTER = 0x2,
	EB_MLM_BROKEN = 0x4,
	EA_FROMDB = 0x0,
	EA_FROMAUTH = 0x1,
	EB_REST_CHANCE = 0x1,
	EB_REST_L17 = 0x2,
	EB_REST_L25 = 0x4,
	EB_REST_L33 = 0x8,
	EB_REST_L40 = 0x10,
	EB_NEW_TELP_1 = 0x20,
	EB_NEW_TELP_2 = 0x40,
	EB_NEW_LV20_1 = 0x80,
	EB_NEW_LV20_2 = 0x100,
	EB_NEW_LV20_3 = 0x200,
	EB_NEW_LV20_4 = 0x400,
	EB_NEW_LV20_5 = 0x800,
	EB_NEW_LV20_6 = 0x1000,
};

/* 205 */
enum IMAGE_AUX_SYMBOL_TYPE : __int32
{
	IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = 0x1,
};

/* 206 */
enum _IMAGEHLP_SYMBOL_TYPE_INFO : __int32
{
	TI_GET_SYMTAG = 0x0,
	TI_GET_SYMNAME = 0x1,
	TI_GET_LENGTH = 0x2,
	TI_GET_TYPE = 0x3,
	TI_GET_TYPEID = 0x4,
	TI_GET_BASETYPE = 0x5,
	TI_GET_ARRAYINDEXTYPEID = 0x6,
	TI_FINDCHILDREN = 0x7,
	TI_GET_DATAKIND = 0x8,
	TI_GET_ADDRESSOFFSET = 0x9,
	TI_GET_OFFSET = 0xA,
	TI_GET_VALUE = 0xB,
	TI_GET_COUNT = 0xC,
	TI_GET_CHILDRENCOUNT = 0xD,
	TI_GET_BITPOSITION = 0xE,
	TI_GET_VIRTUALBASECLASS = 0xF,
	TI_GET_VIRTUALTABLESHAPEID = 0x10,
	TI_GET_VIRTUALBASEPOINTEROFFSET = 0x11,
	TI_GET_CLASSPARENTID = 0x12,
	TI_GET_NESTED = 0x13,
	TI_GET_SYMINDEX = 0x14,
	TI_GET_LEXICALPARENT = 0x15,
	TI_GET_ADDRESS = 0x16,
	TI_GET_THISADJUST = 0x17,
	TI_GET_UDTKIND = 0x18,
	TI_IS_EQUIV_TO = 0x19,
	TI_GET_CALLING_CONVENTION = 0x1A,
};

/* 207 */
enum _ACL_INFORMATION_CLASS : __int32
{
	AclRevisionInformation = 0x1,
	AclSizeInformation = 0x2,
};

/* 208 */
enum std::_Uninitialized : __int32
{
	_Noinit = 0x0,
};

/* 209 */
enum SYS_CODE : __int32
{
	SYS_PK = 0x0,
	SYS_COSMO = 0x1,
	SYS_BILLING = 0x2,
	SYS_NMSOCKET = 0x3,
	SYS_FLAG = 0x4,
	SYS_ENG = 0x5,
	SYS_FRD = 0x6,
	SYS_NMBILLING = 0x7,
	SYS_TESTSRV = 0x8,
	SYS_WAR = 0x9,
	SYS_MAIL = 0xA,
	SYS_GAMBLE = 0xB,
	SYS_WAR2 = 0xC,
	SYS_HACKSHIELD = 0xD,
	SYS_HACKSHIELD_PACKET = 0xE,
	SYS_END = 0xF,
};

/* 210 */
enum EVENT_CODE : __int32
{
	EVENT_DOUBLEEXP = 0x0,
	EVENT_DICE = 0x1,
	EVENT_MORA = 0x2,
	EVENT_SPONSOR = 0x3,
	EVENT_CHANGEFACE = 0x4,
	EVENT_MLM = 0x5,
	EVENT_SNOW = 0x6,
	EVENT_THXGIVING = 0x7,
	EVENT_ANNUAL = 0x8,
	EVENT_END = 0x9,
};

/* 211 */
enum _SYSTEM_POWER_STATE : __int32
{
	PowerSystemUnspecified = 0x0,
	PowerSystemWorking = 0x1,
	PowerSystemSleeping1 = 0x2,
	PowerSystemSleeping2 = 0x3,
	PowerSystemSleeping3 = 0x4,
	PowerSystemHibernate = 0x5,
	PowerSystemShutdown = 0x6,
	PowerSystemMaximum = 0x7,
};

/* 212 */
enum EventMora : __int32
{
	MORA_KAWI = 0x0,
	MORA_BAWI = 0x1,
	MORA_BO = 0x2,
	MORA_IS = 0x3,
	MORA_MORA = 0x4,
	MORA_TIME = 0x5,
	MORA_NO_TIME = 0x6,
	MORA_SHOW = 0x7,
	MORA_LEVEL_LIMIT = 0x8,
};

/* 213 */
enum CHAT_TYPE : __int32
{
	CHAT_COMMON = 0x0,
	CHAT_WHISPER = 0x1,
	CHAT_PARTY = 0x2,
	CHAT_GUILD = 0x3,
};

/* 214 */
enum POWER_ACTION : __int32
{
	PowerActionNone = 0x0,
	PowerActionReserved = 0x1,
	PowerActionSleep = 0x2,
	PowerActionHibernate = 0x3,
	PowerActionShutdown = 0x4,
	PowerActionShutdownReset = 0x5,
	PowerActionShutdownOff = 0x6,
	PowerActionWarmEject = 0x7,
};

/* 215 */
enum ATTR : __int32
{
	ATTR_PLAYER = 0x1,
	ATTR_MONSTER = 0x2,
	ATTR_NPC = 0x3,
	ATTR_ITEM = 0x4,
};

/* 216 */
enum NPC_KIND : __int32
{
	NK_MERCHANT = 0x0,
	NK_INFORMANT = 0x1,
	NK_GUARD = 0x2,
	NK_QUEST = 0x3,
	NK_SCENARIO = 0x4,
	NK_TELEPORT = 0x5,
	NK_DOOR = 0x6,
	NK_SIEGEGUNSTONE = 0x7,
	NK_RETURNPOINT = 0x8,
};

/* 217 */
enum _DEVICE_POWER_STATE : __int32
{
	PowerDeviceUnspecified = 0x0,
	PowerDeviceD0 = 0x1,
	PowerDeviceD1 = 0x2,
	PowerDeviceD2 = 0x3,
	PowerDeviceD3 = 0x4,
	PowerDeviceMaximum = 0x5,
};

/* 218 */
enum EFFECT_TYPE : __int32
{
	E_NONE = 0x0,
	E_HP = 0x1,
	E_MP = 0x2,
	E_LEVELUP = 0x3,
	E_CHARM_1 = 0x4,
	E_CHARM_2 = 0x5,
	E_CHARM_3 = 0x6,
	E_CHARM_4 = 0x7,
	E_CHARM_5 = 0x8,
	E_CHARM_6 = 0x9,
	E_CHARM_7 = 0xA,
	E_CHARM_8 = 0xB,
	E_POTION_1 = 0xC,
	E_POTION_2 = 0xD,
	E_POTION_3 = 0xE,
	E_POTION_4 = 0xF,
	E_POTION_5 = 0x10,
	E_FLUTE_1 = 0x11,
	E_STONE_1 = 0x12,
	E_STONE_2 = 0x13,
	E_STONE_3 = 0x14,
	E_LUCKYKEY = 0x15,
	E_LUCKSTONE = 0x16,
	E_DAMAGED = 0x17,
	E_PET_HP = 0x18,
	E_PET_MP = 0x19,
	E_PET_MINMAXATTACK = 0x1A,
	E_PET_DEFENSE = 0x1B,
	E_MOD2NDJOB = 0x1C,
	E_UPPER_CHANCE_STONE = 0x1D,
	E_GUNNERY = 0x1E,
	E_MIX_FLAME = 0x1F,
	E_MIX_ICE = 0x20,
	E_MIX_LIGHT = 0x21,
	E_MIX_POISON = 0x22,
	E_MIX_PARAL = 0x23,
};

/* 219 */
enum LATENCY_TIME : __int32
{
	LT_DONT_CARE = 0x0,
	LT_LOWEST_LATENCY = 0x1,
};

/* 220 */
enum _AUDIT_EVENT_TYPE : __int32
{
	AuditEventObjectAccess = 0x0,
	AuditEventDirectoryServiceAccess = 0x1,
};

/* 221 */
enum POWER_INFORMATION_LEVEL : __int32
{
	SystemPowerPolicyAc = 0x0,
	SystemPowerPolicyDc = 0x1,
	VerifySystemPolicyAc = 0x2,
	VerifySystemPolicyDc = 0x3,
	SystemPowerCapabilities = 0x4,
	SystemBatteryState = 0x5,
	SystemPowerStateHandler = 0x6,
	ProcessorStateHandler = 0x7,
	SystemPowerPolicyCurrent = 0x8,
	AdministratorPowerPolicy = 0x9,
	SystemReserveHiberFile = 0xA,
	ProcessorInformation = 0xB,
	SystemPowerInformation = 0xC,
	ProcessorStateHandler2 = 0xD,
	LastWakeTime = 0xE,
	LastSleepTime = 0xF,
	SystemExecutionState = 0x10,
	SystemPowerStateNotifyHandler = 0x11,
	ProcessorPowerPolicyAc = 0x12,
	ProcessorPowerPolicyDc = 0x13,
	VerifyProcessorPowerPolicyAc = 0x14,
	VerifyProcessorPowerPolicyDc = 0x15,
	ProcessorPowerPolicyCurrent = 0x16,
	SystemPowerStateLogging = 0x17,
	SystemPowerLoggingEntry = 0x18,
};

/* 222 */
enum WEAR_STATE : __int32
{
	WS_WEAPON = 0x0,
	WS_SHIELD = 0x1,
	WS_HELMET = 0x2,
	WS_UPPERARMOR = 0x3,
	WS_LOWERARMOR = 0x4,
	WS_GAUNTLET = 0x5,
	WS_BOOTS = 0x6,
	WS_RING = 0x7,
	WS_NECKLACE = 0x8,
	WS_TRINKET = 0x9,
	WS_TRANSFORM = 0xA,
	WS_MASK = 0xB,
	WS_2HANDWEAPON = 0xC,
	WS_STANDARD = 0xD,
};

/* 223 */
enum _EXCEPTION_DISPOSITION : __int32
{
	ExceptionContinueExecution = 0x0,
	ExceptionContinueSearch = 0x1,
	ExceptionNestedException = 0x2,
	ExceptionCollidedUnwind = 0x3,
};

/* 224 */
enum PLAYER_CLASS : __int32
{
	PC_KNIGHT = 0x0,
	PC_MAGE = 0x1,
	PC_ARCHER = 0x2,
	PC_WARRIOR = 0x3,
	PC_ASSASSIN = 0x4,
	PC_TALISMAN = 0x5,
	PC_SPIRITKNIGHT = 0x6,
	PC_MONK = 0x7,
};

/* 225 */
enum ADDRESS_MODE : __int32
{
	AddrMode1616 = 0x0,
	AddrMode1632 = 0x1,
	AddrModeReal = 0x2,
	AddrModeFlat = 0x3,
};

/* 226 */
enum ITEM_CLASS : __int32
{
	IC_WEAPON = 0x0,
	IC_DEFENSE = 0x1,
	IC_ORNAMENT = 0x2,
	IC_GENERAL = 0x3,
	IC_QUEST = 0x4,
	IC_MONEY = 0x5,
	IC_TRANSFORM = 0x6,
};

/* 227 */
enum _SECURITY_IMPERSONATION_LEVEL : __int32
{
	SecurityAnonymous = 0x0,
	SecurityIdentification = 0x1,
	SecurityImpersonation = 0x2,
	SecurityDelegation = 0x3,
};

/* 228 */
enum _TOKEN_TYPE : __int32
{
	TokenPrimary = 0x1,
	TokenImpersonation = 0x2,
};

/* 229 */
enum _TOKEN_INFORMATION_CLASS : __int32
{
	TokenUser = 0x1,
	TokenGroups = 0x2,
	TokenPrivileges = 0x3,
	TokenOwner = 0x4,
	TokenPrimaryGroup = 0x5,
	TokenDefaultDacl = 0x6,
	TokenSource = 0x7,
	TokenType = 0x8,
	TokenImpersonationLevel = 0x9,
	TokenStatistics = 0xA,
	TokenRestrictedSids = 0xB,
	TokenSessionId = 0xC,
	TokenGroupsAndPrivileges = 0xD,
	TokenSessionReference = 0xE,
	TokenSandBoxInert = 0xF,
	TokenAuditPolicy = 0x10,
	MaxTokenInfoClass = 0x11,
};

/* 230 */
enum ACTION_TYPE : __int32
{
	AT_COMMON = 0x0,
	AT_GENERAL = 0x1,
	AT_MOVE = 0x2,
	AT_REST = 0x3,
	AT_ATTACK = 0x4,
	AT_SKILL = 0x5,
	AT_DEFENSE = 0x6,
	AT_DAMAGE = 0x7,
	AT_KNEE = 0x8,
	AT_DIE = 0x9,
	AT_BEHEADED = 0xA,
	AT_STALL = 0xB,
	AT_PRETRANSFORM = 0xC,
	AT_TRANSFORM = 0xD,
};

/* 231 */
enum CHAR_KIND : __int32
{
	CK_PLAYER = 0x0,
	CK_MONSTER = 0x1,
	CK_NPC = 0x2,
	CK_HORSE = 0x3,
};

/* 232 */
enum AdminType : __int32
{
	A_USER = 0x0,
	A_BLOCKED = 0x1,
	A_RESERVED1 = 0x2,
	A_ADMIN = 0x3,
	A_GM = 0x4,
	A_SUPERADMIN = 0x5,
};

/* 233 */
enum ANSWER : __int32
{
	ANS_ERROR = 0x0,
	ANS_OK = 0x1,
	ANS_MLMOK = 0x2,
	ANS_ERROR_DISSOLUTION = 0x3,
};

/* 234 */
enum LOGIN_ANS : __int32
{
	LA_ERROR = 0x0,
	LA_OK = 0x1,
	LA_WRONGID = 0x2,
	LA_WRONGPWD = 0x3,
	LA_SAMEUSER = 0x4,
	LA_BLOCKED = 0x5,
	LA_EXPIRED = 0x6,
	LA_AGELIMITED = 0x7,
	LA_NOTPERMITTED = 0x8,
	LA_LOGINLATER = 0x9,
};

/* 235 */
enum NEWPLAYER_ANS : __int32
{
	NA_ERROR = 0x0,
	NA_OK = 0x1,
	NA_WRONGCLASS = 0x2,
	NA_OVERPLAYERNUM = 0x3,
	NA_OCCUPIEDID = 0x4,
	NA_WRONGPROPERTY = 0x5,
	NA_NOTAVAILABLE = 0x6,
};

/* 236 */
enum _MINIDUMP_STREAM_TYPE : __int32
{
	UnusedStream = 0x0,
	ReservedStream0 = 0x1,
	ReservedStream1 = 0x2,
	ThreadListStream = 0x3,
	ModuleListStream = 0x4,
	MemoryListStream = 0x5,
	ExceptionStream = 0x6,
	SystemInfoStream = 0x7,
	ThreadExListStream = 0x8,
	Memory64ListStream = 0x9,
	CommentStreamA = 0xA,
	CommentStreamW = 0xB,
	HandleDataStream = 0xC,
	FunctionTableStream = 0xD,
	UnloadedModuleListStream = 0xE,
	MiscInfoStream = 0xF,
	LastReservedStream = 0xFFFF,
};

/* 237 */
enum COPYPLAYER_ANS : __int32
{
	CP_ERROR = 0x0,
	CP_OK = 0x1,
	CP_VALIDNAME = 0x2,
	CP_OVERPLAYERNUM = 0x3,
	CP_OCCUPIEDNAME = 0x4,
	CP_INVALIDSERVER = 0x5,
	CP_INVALIDPLAYER = 0x6,
	CP_BLOCKEDPLAYER = 0x7,
};

/* 238 */
enum CLOSE_CONNECT : __int32
{
	CC_NORMAL = 0x0,
	CC_KICK = 0x1,
	CC_SAMEPLAYER = 0x2,
	CC_SAMEUSER = 0x3,
	CC_HACK = 0x4,
	CC_EXPIRED = 0x5,
	CC_OVERPOPULATION = 0x6,
	CC_ERROR = 0x7,
	CC_RELOGINFORCOPYPLAYER = 0x8,
	CC_RESTOREPLAYER = 0x9,
	CC_WRONG_PROTOCOL_VERSION = 0xA,
};

/* 239 */
enum LOGIN_TYPE : __int32
{
	LT_DELETED = 0x1,
	LT_BLOCKED = 0x2,
	LT_FREE = 0x8,
	LT_FLATRATE = 0x10,
	LT_PRORATE = 0x20,
	LT_HOST = 0x100,
	LT_PCBANG = 0x200,
	LT_BILLINGMASK = 0x30,
	LT_AUTHMASK = 0x38,
};

/* 240 */
enum _GET_FILEEX_INFO_LEVELS : __int32
{
	GetFileExInfoStandard = 0x0,
	GetFileExMaxInfoLevel = 0x1,
};

/* 241 */
enum TYPE_MAINLOG : __int32
{
	TML_PLAYER = 0x0,
	TML_DELETEITEM = 0x1,
	TML_INSERTITEM = 0x2,
	TML_UPDATEITEMPID = 0x3,
	TML_UPDATEITEMNUM = 0x4,
	TML_PUTINSTORAGE = 0x5,
	TML_PUTOUTSTORAGE = 0x6,
	TML_QUEST = 0x7,
	TML_ACCOUNT = 0x8,
	TML_ENCHANTITEM = 0x9,
	TML_UPDATETRANSFORM = 0xA,
	TML_ALLIANCE = 0xB,
	TML_CASTLEWAR = 0xC,
	TML_UPGRADEITEM = 0xD,
	TML_MAIL = 0xE,
	TML_STOREDPROC = 0xF,
};

/* 242 */
enum _FINDEX_INFO_LEVELS : __int32
{
	FindExInfoStandard = 0x0,
	FindExInfoMaxInfoLevel = 0x1,
};

/* 243 */
enum _FINDEX_SEARCH_OPS : __int32
{
	FindExSearchNameMatch = 0x0,
	FindExSearchLimitToDirectories = 0x1,
	FindExSearchLimitToDevices = 0x2,
	FindExSearchMaxSearchOp = 0x3,
};

/* 244 */
enum PROPERTY_TYPE : __int32
{
	P_STR = 0x0,
	P_HTH = 0x1,
	P_INT = 0x2,
	P_WIS = 0x3,
	P_DEX = 0x4,
	P_HP = 0x5,
	P_MP = 0x6,
	P_CURHP = 0x7,
	P_CURMP = 0x8,
	P_HIT = 0x9,
	P_DODGE = 0xA,
	P_MINATTACK = 0xB,
	P_MAXATTACK = 0xC,
	P_MINMAGIC = 0xD,
	P_MAXMAGIC = 0xE,
	P_DEFENSE = 0xF,
	P_ABSORB = 0x10,
	P_ASPEED = 0x11,
	P_RESFIRE = 0x12,
	P_RESICE = 0x13,
	P_RESLITNING = 0x14,
	P_RESCURSE = 0x15,
	P_RESPALSY = 0x16,
	P_PUPOINT = 0x17,
	P_SUPOINT = 0x18,
	P_EXP = 0x19,
	P_LEVEL = 0x1A,
	P_MINMAXATTACK = 0x1B,
	P_MINMAXMAGIC = 0x1C,
	P_RESISTALL = 0x1D,
	P_CONTRIBUTE = 0x1E,
	P_FATAL = 0x1F,
	P_MSPEED = 0x20,
	P_BLOCK = 0x21,
	P_HASTE = 0x22,
	P_RAGE = 0x23,
	P_MORTAL = 0x24,
	P_HOST = 0x25,
	P_RANGE = 0x26,
	P_MIX = 0x27,
	P_PREFIX = 0xFF,
};

/* 245 */
enum _HEAP_INFORMATION_CLASS : __int32
{
	HeapCompatibilityInformation = 0x0,
};

/* 246 */
enum _COMPUTER_NAME_FORMAT : __int32
{
	ComputerNameNetBIOS = 0x0,
	ComputerNameDnsHostname = 0x1,
	ComputerNameDnsDomain = 0x2,
	ComputerNameDnsFullyQualified = 0x3,
	ComputerNamePhysicalNetBIOS = 0x4,
	ComputerNamePhysicalDnsHostname = 0x5,
	ComputerNamePhysicalDnsDomain = 0x6,
	ComputerNamePhysicalDnsFullyQualified = 0x7,
	ComputerNameMax = 0x8,
};

/* 247 */
enum SYM_TYPE : __int32
{
	SymNone = 0x0,
	SymCoff = 0x1,
	SymCv = 0x2,
	SymPdb = 0x3,
	SymExport = 0x4,
	SymDeferred = 0x5,
	SymSym = 0x6,
	SymDia = 0x7,
	SymVirtual = 0x8,
	NumSymTypes = 0x9,
};

/* 248 */
enum _ACTIVATION_CONTEXT_INFO_CLASS : __int32
{
	ActivationContextBasicInformation = 0x1,
	ActivationContextDetailedInformation = 0x2,
	AssemblyDetailedInformationInActivationContext = 0x3,
	FileInformationInAssemblyOfAssemblyInActivationContext = 0x4,
	MaxActivationContextInfoClass = 0x5,
	AssemblyDetailedInformationInActivationContxt = 0x3,
	FileInformationInAssemblyOfAssemblyInActivationContxt = 0x4,
};

/* 249 */
enum _COMPUTER_NAME_TYPE : __int32
{
	PrimaryComputerName = 0x0,
	AlternateComputerNames = 0x1,
	AllComputerNames = 0x2,
	ComputerNameTypeMax = 0x3,
};

/* 250 */
enum GUILD_MEMBER_CLASS : __int32
{
	GUILD_LEADER = 0x1,
	GUILD_SUBLEADER = 0x2,
	GUILD_CENTURION = 0x3,
	GUILD_TEN = 0x4,
	GUILD_REGULAR = 0x5,
	GUILD_TEMP = 0x6,
	GUILD_CONSENT = 0x7,
	GUILD_CONSENT_WAIT = 0x8,
};

/* 251 */
enum GUILD_SKILL : __int32
{
	GUILD_CONFLUX = 0x0,
	GUILD_BANISH = 0x1,
	GUILD_NOTICE = 0x2,
	GUILD_APPOINTMENT = 0x3,
	GUILD_TITLE = 0x4,
};

/* 252 */
enum GUILD_TYPE : __int32
{
	G_MSG = 0x0,
	G_CREATE_TRIAL = 0x1,
	G_CREATE_CONSENT = 0x2,
	G_CREATE_CONSENT_ANSWER = 0x3,
	G_CREATE_CONSENT_COMPLET = 0x4,
	G_CREATE_GUILDNAME = 0x5,
	G_MEMBERINFO = 0x6,
	G_ADMININFO = 0x7,
	G_BASICINFO = 0x8,
	G_VIEW = 0x9,
	G_SECESSION = 0xA,
	G_TODAYMESSAGE = 0xB,
	G_EXPADD = 0xC,
	G_SETSKILLABLE = 0xD,
	G_CONFLUX = 0xE,
	G_CONFLUX_ANSWER = 0xF,
	G_DISSOLUTION = 0x10,
	G_ALLIANCEINFO = 0x11,
	G_ALLIANCEANSWER = 0x12,
	G_WAR_DECLARE = 0x13,
	G_WAR_DECLARE_LIST = 0x14,
	G_WAR_UNFURL = 0x15,
	G_WAR_UNFURL_CANCEL = 0x16,
	G_CASTLEINFO = 0x17,
	G_TAX_RATE_CONTROL = 0x18,
	G_CASTLEGATENPC = 0x19,
	G_CASTLEGATE_SETLIMIT = 0x1A,
	G_TAX_LEVY = 0x1B,
	G_CHECK_STANDARD = 0x1C,
	G_SET_STANDARD = 0x1D,
};

/* 253 */
enum SYSNLS_FUNCTION : __int32
{
	COMPARE_STRING = 0x1,
};

/* 254 */
enum _SID_NAME_USE : __int32
{
	SidTypeUser = 0x1,
	SidTypeGroup = 0x2,
	SidTypeDomain = 0x3,
	SidTypeAlias = 0x4,
	SidTypeWellKnownGroup = 0x5,
	SidTypeDeletedAccount = 0x6,
	SidTypeInvalid = 0x7,
	SidTypeUnknown = 0x8,
	SidTypeComputer = 0x9,
};

/* 255 */
enum SYSGEOTYPE : __int32
{
	GEO_NATION = 0x1,
	GEO_LATITUDE = 0x2,
	GEO_LONGITUDE = 0x3,
	GEO_ISO2 = 0x4,
	GEO_ISO3 = 0x5,
	GEO_RFC1766 = 0x6,
	GEO_LCID = 0x7,
	GEO_FRIENDLYNAME = 0x8,
	GEO_OFFICIALNAME = 0x9,
	GEO_TIMEZONES = 0xA,
	GEO_OFFICIALLANGUAGES = 0xB,
};

/* 256 */
enum SYSGEOCLASS : __int32
{
	GEOCLASS_NATION = 0x10,
	GEOCLASS_REGION = 0xE,
};

/* 257 */
enum _WSACOMPLETIONTYPE : __int32
{
	NSP_NOTIFY_IMMEDIATELY = 0x0,
	NSP_NOTIFY_HWND = 0x1,
	NSP_NOTIFY_EVENT = 0x2,
	NSP_NOTIFY_PORT = 0x3,
	NSP_NOTIFY_APC = 0x4,
};

/* 258 */
enum $583456D2BF8784912E5A7AC09C36A0A3 : __int32
{
	sevInfo = 0x0,
	sevProblem = 0x1,
	sevAttn = 0x2,
	sevFatal = 0x3,
	sevMax = 0x4,
};

/* 259 */
enum _MINIDUMP_CALLBACK_TYPE : __int32
{
	ModuleCallback = 0x0,
	ThreadCallback = 0x1,
	ThreadExCallback = 0x2,
	IncludeThreadCallback = 0x3,
	IncludeModuleCallback = 0x4,
};

/* 260 */
enum $079E40840CDFCB5BDCB3539DEADA4ED1 : __int32
{
	ok = 0x0,
	partial = 0x1,
	error = 0x2,
	noconv = 0x3,
};

/* 261 */
enum std::_Iosb<int>::_Dummy_enum : __int32
{
	_Dummy_enum_val = 0x1,
};

/* 262 */
enum std::_Iosb<int>::_Fmtflags : __int32
{
	_Fmtmask = 0xFFFF,
	_Fmtzero = 0x0,
};

/* 263 */
enum std::_Iosb<int>::_Iostate : __int32
{
	_Statmask = 0x17,
};

/* 264 */
enum std::_Iosb<int>::_Openmode : __int32
{
	_Openmask = 0xFF,
};

/* 265 */
enum std::_Iosb<int>::_Seekdir : __int32
{
	_Seekmask = 0x3,
};

/* 266 */
enum $F0312C582E9D9ECC519F6E49B11D229E : __int32
{
	_Openprot = 0x1B6,
};

/* 267 */
enum $EAE461898C311127FCF11BEA62B65C1A : __int32
{
	alnum = 0x107,
	alpha = 0x103,
	cntrl = 0x20,
	digit = 0x4,
	graph = 0x117,
	lower = 0x2,
	print = 0x1D7,
	punct = 0x10,
	space = 0x48,
	upper = 0x1,
	xdigit = 0x80,
};

/* 269 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::_Redbl;

/* 270 */
enum S2D_PROTOCOL : __int32
{
	S2D_DELPLAYER = 0x0,
	S2D_LOADPLAYER = 0x1,
	S2D_SAVEALLPROPERTY = 0x2,
	S2D_DELETEITEM = 0x3,
	S2D_PUTONITEM = 0x4,
	S2D_PUTOFFITEM = 0x5,
	S2D_INSERTITEM = 0x6,
	S2D_UPDATEITEMPID = 0x7,
	S2D_UPDATEITEMNUM = 0x8,
	S2D_INSERTSKILL = 0x9,
	S2D_SKILLUP = 0xA,
	S2D_PUTINSTORAGE = 0xB,
	S2D_PUTOUTSTORAGE = 0xC,
	S2D_INSERTQUESTFLAG = 0xD,
	S2D_UPDATEQUESTFLAG = 0xE,
	S2D_SAVESPECIALTY = 0xF,
	S2D_UPDATEPROPERTY = 0x10,
	S2D_UPDATEITEMXVALUE = 0x11,
	S2D_UPDATEITEMEND = 0x12,
	S2D_UPDATEITEMPREFIX = 0x13,
	S2D_UPDATE_TFITEM = 0x14,
	S2D_UPDATEITEMINFO = 0x15,
	S2D_SKILLREDISTRIBUTE = 0x16,
	S2D_ALLIANCE_CREATE = 0x17,
	S2D_ALLIANCE_JOIN = 0x18,
	S2D_BUFFREMAIN = 0x19,
	S2D_ALLIANCE_DELETE = 0x1A,
	S2D_TAX_SAVE = 0x1B,
	S2D_UPDATEITEMUPGRADE = 0x1C,
	S2D_FRD = 0x1D,
	S2D_MAIL = 0x1E,
	S2D_SYNC = 0x1F,
	S2D_CLOSE = 0x20,
	S2D_LOGIN = 0x21,
	S2D_NEWPLAYER = 0x22,
	S2D_FORCEDINSTORAGE = 0x23,
	S2D_SAVEREVIVALPT = 0x24,
	S2D_EVENTSAVE = 0x25,
	S2D_EVENT = 0x26,
	S2D_GUILD_CREATE_SECEDECHECK = 0x27,
	S2D_GUILD_SECEDECHECK = 0x28,
	S2D_GUILD_SAMENAMECHECK = 0x29,
	S2D_GUILD_CREATE = 0x2A,
	S2D_GUILD_CONFLUX = 0x2B,
	S2D_GUILD_SECEDER_DELETE = 0x2C,
	S2D_GUILD_SECEDER = 0x2D,
	S2D_GUILD_APPOINTMENT = 0x2E,
	S2D_GUILD_DISSOLUTION = 0x2F,
	S2D_GUILD_TITLECHANGE = 0x30,
	S2D_GUILD_SET_TODAYMESSAGE = 0x31,
	S2D_GUILD_SETEXP = 0x32,
	S2D_GUILD_SET_SKILL = 0x33,
	S2D_CHECKCOPY = 0x34,
	S2D_REQUESTCOPY = 0x35,
	S2D_COPYPLAYER = 0x36,
	S2D_PK_BULLETIN_INSERT = 0x37,
	S2D_PK_BULLETIN_REQUEST = 0x38,
	S2D_CASTLE_INIT = 0x39,
	S2D_WAR_INIT = 0x3A,
	S2D_GUILD_SETEXP2 = 0x3B,
	S2D_ALLIANCE_POSTPONE = 0x3C,
	S2D_WAR_ADD = 0x3D,
	S2D_WAR_CLEAR = 0x3E,
	S2D_CASTLE_SETTAXRATE = 0x3F,
	S2D_CASTLE_SETGID = 0x40,
	S2D_CASTLE_SETGATELIMIT = 0x41,
	S2D_MLM = 0x42,
	S2D_SHORTCUT = 0x43,
	S2D_GUILD_CHECKSTANDARD = 0x44,
	S2D_GUILD_SETSTANDARD = 0x45,
	S2D_GETMYTELPT = 0x46,
	S2D_SETMYTELPT = 0x47,
	S2D_CHANGEPLAYERNAME = 0x48,
	S2D_CHANGEGUILDNAME = 0x49,
	S2D_STATISTICS = 0x4A,
	S2D_CHANGEFACE = 0x4B,
	S2D_EVENT_LOGIN = 0x4C,
	S2D_EVENT_NPC = 0x4D,
	S2D_EVENT_CHANGE_FLAG = 0x4E,
	S2D_RESTOREPLAYER = 0x4F,
	S2D_RESTORELONGRESTUSERITEM = 0x50,
	S2D_END = 0x51,
};

/* 271 */
enum S2A_PROTOCOL : __int32
{
	S2A_SYNC = 0x0,
	S2A_LOGIN = 0x1,
	S2A_LOGOUT = 0x2,
	S2A_RELOGIN = 0x3,
	S2A_CLOSE = 0x4,
	S2A_USER = 0x5,
	S2A_USERALL = 0x6,
	S2A_CLEARLOGIN = 0x7,
	S2A_SVRINFO = 0x8,
	S2A_BLOCK = 0x9,
	S2A_FREE = 0xA,
	S2A_EVENT = 0xB,
	S2A_REQUESTCOPY = 0xC,
	S2A_ANS_REQUESTCOPY = 0xD,
	S2A_SPECIALITEM = 0xE,
	S2A_EVENT_LOGIN = 0xF,
	S2A_EVENT_NPC = 0x10,
	S2A_EVENT_CHANGE_FLAG = 0x11,
	S2A_END = 0x12,
};

/* 272 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::_Redbl;

/* 273 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >::_Redbl;

/* 274 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::_Redbl;

/* 275 */
enum SOCKET_BIT : __int32
{
	SBIT_LOGIN_REQUEST = 0x0,
	SBIT_LOGIN = 0x1,
	SBIT_COPYPLAYER = 0x2,
	SBIT_LOADPLAYER = 0x3,
	SBIT_ONGAME = 0x4,
	SBIT_WAIT_CLOSED = 0x5,
	SBIT_CLOSED = 0x6,
	SBIT_LONGRESTUSER = 0x7,
};

/* 276 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >::_Redbl;

/* 277 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >::_Redbl;

/* 278 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >::_Redbl;

/* 279 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >::_Redbl;

/* 280 */
enum BUFF_TYPE : __int32
{
	BUFF_MOVESPEED = 0x0,
	BUFF_STONE = 0x1,
	BUFF_MEDITATION = 0x2,
	BUFF_FATALCHANCE = 0x3,
	BUFF_REVIVALSEQUELA = 0x4,
	BUFF_ATTACKUP = 0x5,
	BUFF_MAGICUP = 0x6,
	BUFF_STUN = 0x7,
	BUFF_MOVESTOP = 0x8,
	BUFF_HITUP = 0x9,
	BUFF_ATTACKMINUP = 0xA,
	BUFF_POISON = 0xB,
	BUFF_HASTE = 0xC,
	BUFF_PROTECT = 0xD,
	BUFF_PROTECTRANGE = 0xE,
	BUFF_MAGICSTOP = 0xF,
	BUFF_CUTEXPHALF = 0x10,
	BUFF_KILLEDNOCOUNT = 0x11,
	BUFF_HP = 0x12,
	BUFF_MP = 0x13,
	BUFF_ATTACKSPEED = 0x14,
	BUFF_HITUPPER = 0x15,
	BUFF_DAMAGEDEX = 0x16,
	BUFF_HITNICE = 0x17,
	BUFF_DODGEALL = 0x18,
	BUFF_FATALNICE = 0x19,
	BUFF_SLEEP = 0x1A,
	BUFF_DEFENSEPER = 0x1B,
	BUFF_CTDEFENSEPER = 0x1C,
	BUFF_SUFFERING = 0x1D,
	BUFF_EXPADD130 = 0x1E,
	BUFF_MONEYADD120 = 0x1F,
	BUFF_FISHADD200 = 0x20,
	BUFF_DROPUPCHARMARMOR = 0x21,
	BUFF_DROPUPCHARMORNAMENT = 0x22,
	BUFF_DROPUPCHARMWEAPON = 0x23,
	BUFF_INCHANTWEAPON = 0x24,
	BUFF_AURADEFENSE = 0x25,
	BUFF_CTHEALING = 0x26,
	BUFF_SPIRITDMG = 0x27,
	BUFF_FLAGMSPEED = 0x28,
	BUFF_FLAGATTACK = 0x29,
	BUFF_FLAGMAGIC = 0x2A,
	BUFF_FLAGDEFENSE = 0x2B,
	BUFF_FLAGRESIST = 0x2C,
	BUFF_FLAGHP = 0x2D,
	BUFF_STREN_UPSTR = 0x2E,
	BUFF_STREN_UPHTH = 0x2F,
	BUFF_STREN_UPDEX = 0x30,
	BUFF_STREN_UPINT = 0x31,
	BUFF_STREN_UPFATAL = 0x32,
	BUFF_PAY_UPATTACK = 0x33,
	BUFF_PAY_CUTDAMAGE = 0x34,
	BUFF_PAY_UPXBLOW3 = 0x35,
	BUFF_PAY_UPXBLOW5 = 0x36,
	BUFF_PAY_AUTOREFRESH = 0x37,
	BUFF_PAY_UPHIT = 0x38,
	BUFF_PAY_UPDODGE = 0x39,
	BUFF_PAY_PERFECTDEF = 0x3A,
	BUFF_PAY_DRAINHP = 0x3B,
	BUFF_PAY_UPSTR = 0x3C,
	BUFF_PAY_UPHTH = 0x3D,
	BUFF_PAY_UPINT = 0x3E,
	BUFF_PAY_UPWIS = 0x3F,
	BUFF_PAY_UPDEX = 0x40,
	BUFF_DEAD_MAIN = 0x41,
	BUFF_DEAD_ONPK = 0x42,
	BUFF_DEAD_OFFPK = 0x43,
	BUFF_DEAD_CUTEXPHALF = 0x44,
	BUFF_BERSERK = 0x45,
	BUFF_CTDEFLIGHTNING = 0x46,
	BUFF_CTDEFICE = 0x47,
	BUFF_CTDEFFIRE = 0x48,
	BUFF_CTACCURACY = 0x49,
	BUFF_CTBATTLE = 0x4A,
	BUFF_SHIELDRESILIENCE = 0x4B,
	BUFF_RESIST_LIGHTING = 0x4C,
	BUFF_RESIST_ICE = 0x4D,
	BUFF_RESIST_FIRE = 0x4E,
	BUFF_RESIST_CURSE = 0x4F,
	BUFF_RESIST_PALSY = 0x50,
	BUFF_SILENCESHOT = 0x51,
	BUFF_EMERGENCYESCAPE = 0x52,
	BUFF_CLOUDSIGHT = 0x53,
	BUFF_MANABURN = 0x54,
	BUFF_MESH_CHANCE = 0x55,
	BUFF_MESH_STR = 0x56,
	BUFF_MESH_HTH = 0x57,
	BUFF_MESH_DEX = 0x58,
	BUFF_MESH_INT = 0x59,
	BUFF_MESH_WIS = 0x5A,
	BUFF_MESH_DEFENSE = 0x5B,
	BUFF_POISONCLOUD = 0x5C,
	BUFF_VANISHCONFI = 0x5D,
	BUFF_DESTROYSIGHT = 0x5E,
	BUFF_DO_UPABSORB = 0x5F,
	BUFF_DO_UPRESISTALL = 0x60,
	BUFF_PLAYERNAMECHANGED = 0x61,
	BUFF_GUILDNAMECHANGED = 0x62,
	BUFF_LUCKYKEY = 0x63,
	BUFF_LUCKYSTONE1 = 0x64,
	BUFF_LUCKYSTONE2 = 0x65,
	BUFF_CHANGEFACE = 0x66,
	BUFF_PET = 0x67,
	BUFF_PK = 0x68,
	BUFF_HYDROCHLORICACID = 0x69,
	BUFF_UPSTR = 0x6A,
	BUFF_UPHTH = 0x6B,
	BUFF_UPINT = 0x6C,
	BUFF_UPWIS = 0x6D,
	BUFF_UPDEX = 0x6E,
	BUFF_PAY_GUNNERY = 0x6F,
	BUFF_EXPADD110_1 = 0x70,
	BUFF_EXPADD110_2 = 0x71,
	BUFF_EXPADD110_3 = 0x72,
	BUFF_RETURN_COOLTIME = 0x73,
	BUFF_MIXDAMAGE = 0x74,
	BUFF_MIXLIGHT = 0x75,
	BUFF_MIXICE = 0x76,
};

/* 281 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >::_Redbl;

/* 283 */
enum $CFF14F821B1821DFEFD250B2E6ABF1C7 : __int32
{
	GUILDSKILL_NAME = 0x0,
	GUILDSKILL_STANDARD = 0x1,
	GUILDSKILL_CAPTURE_WAR = 0x2,
	GUILDSKILL_ALLIANCE = 0x3,
};

/* 284 */
enum $AB2A311F0A5DF093E0A3EA4B73E8EB69 : __int32
{
	EVENTTYPE_MORA = 0x0,
};

/* 285 */
enum PLAYER_BIT : __int32
{
	PBIT_LOAD = 0x1,
	PBIT_CREATE = 0x2,
	PBIT_ONPLAY = 0x3,
	PBIT_END = 0x4,
};

/* 286 */
enum STALL_FLAG : __int32
{
	SF_REGITEM = 0x0,
	SF_REMITEM = 0x1,
	SF_REGMSG = 0x2,
	SF_ITEMINFO = 0x0,
	SF_MSG = 0x1,
};

/* 287 */
enum PVP_FLAG : __int32
{
	PVP_COUNTDOWN = 0x0,
	PVP_START = 0x1,
	PVP_WIN = 0x2,
	PVP_LOSE = 0x3,
	PVP_TIMEOUT = 0x4,
	PVP_BROADCASTSTART = 0x5,
	PVP_BROADCASTWIN = 0x6,
	PVP_BROADCASTTIMEOUT = 0x7,
};

/* 288 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::_Redbl;

/* 289 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >::_Redbl;

/* 290 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >::_Redbl;

/* 291 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >::_Redbl;

/* 292 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >::_Redbl;

/* 293 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::_Redbl;

/* 294 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >::_Redbl;

/* 295 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >::_Redbl;

/* 296 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >::_Redbl;

/* 297 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >::_Redbl;

/* 298 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >::_Redbl;

/* 299 */
enum AI_STATE : __int32
{
	AIS_NONE = 0x0,
	AIS_ROAM = 0x1,
	AIS_CHASE = 0x2,
	AIS_RETURN = 0x3,
	AIS_ATTACK = 0x4,
	AIS_PRESKILL = 0x5,
	AIS_EXSKILL = 0x6,
	AIS_ESCORT = 0x7,
};

/* 300 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::_Redbl;

/* 301 */
enum MOVE_TYPE : __int32
{
	MT_ROAM = 0x0,
	MT_CHASE = 0x1,
	MT_RETURN = 0x2,
	MT_FIX = 0x3,
};

/* 302 */
enum $DC17417D066B51536FFECEA836FF9B2D : __int32
{
	INFO = 0x0,
	NORMAL = 0x1,
	ERR = 0x2,
};

/* 303 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >::_Redbl;

/* 304 */
typedef std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Redbl std::_Tree<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >::_Redbl;

/* 305 */
enum D2S_PROTOCOL : __int32
{
	D2S_LOGIN = 0x0,
	D2S_VERSION = 0x1,
	D2S_ANS_NEWPLAYER = 0x2,
	D2S_ANS_DELPLAYER = 0x3,
	D2S_LOADPLAYER = 0x4,
	RESVD_D2S_LOADSKILL = 0x5,
	RESVD_D2S_LOADITEM = 0x6,
	RESVD_D2S_STORAGEINFO = 0x7,
	D2S_EVENT = 0x8,
	D2S_GUILD_CREATE_SECEDECHECK = 0x9,
	D2S_GUILD_SECEDECHECK = 0xA,
	D2S_GUILD_SAMENAMECHECK = 0xB,
	D2S_GUILD_DELPLAYER = 0xC,
	D2S_ANS_CHECKCOPY = 0xD,
	D2S_ANS_REQUESTCOPY = 0xE,
	D2S_ANS_COPYPLAYER = 0xF,
	D2S_PK_BULLETIN_LOAD = 0x10,
	D2S_CASTLE_INIT = 0x11,
	D2S_WAR_INIT = 0x12,
	D2S_SHORTCUT = 0x13,
	D2S_GUILD_CHECKSTANDARD = 0x14,
	D2S_GUILD_SETSTANDARD = 0x15,
	D2S_GETMYTELPT = 0x16,
	D2S_SETMYTELPT = 0x17,
	D2S_FRD = 0x18,
	D2S_MAIL = 0x19,
	D2S_CHANGEPLAYERNAME = 0x1A,
	D2S_CHANGEGUILDNAME = 0x1B,
	D2S_EVENT_GET_FLAG = 0x1C,
	D2S_DELPLAYERINFO = 0x1D,
	D2S_RESTOREPLAYER = 0x1E,
	D2S_END = 0x1F,
};

/* 306 */
enum BUFFUP_TYPE : __int32
{
	BUT_PT = 0x1,
	BUT_PER = 0x2,
	BUT_UP = 0x3,
};

/* 307 */
enum A2S_PROTOCOL : __int32
{
	A2S_VERSION = 0x0,
	A2S_LOGIN = 0x1,
	A2S_USER = 0x2,
	A2S_USERALL = 0x3,
	A2S_KICKOUT = 0x4,
	A2S_BLOCK = 0x5,
	A2S_FREE = 0x6,
	A2S_EVENT = 0x7,
	A2S_REQUESTCOPY = 0x8,
	A2S_ANS_REQUESTCOPY = 0x9,
	A2S_BILLINGALERT = 0xA,
	A2S_SPECIALITEM = 0xB,
	A2S_NOTICE = 0xC,
	A2S_IS_EVENT = 0xD,
	A2S_EVENT_GET_FLAG = 0xE,
	A2S_RESTORELONGRESTUSERITEM = 0xF,
	A2S_END = 0x10,
};

/* 308 */
enum INTRNCVT_STATUS : __int32
{
	INTRNCVT_OK = 0x0,
	INTRNCVT_OVERFLOW = 0x1,
	INTRNCVT_UNDERFLOW = 0x2,
};

/* 309 */
enum state_t : __int32
{
	S_INIT = 0x0,
	S_EAT0L = 0x1,
	S_SIGNM = 0x2,
	S_GETL = 0x3,
	S_GETR = 0x4,
	S_POINT = 0x5,
	S_E = 0x6,
	S_SIGNE = 0x7,
	S_EAT0E = 0x8,
	S_GETE = 0x9,
	S_END = 0xA,
	S_E_IMPLICIT = 0xB,
};

/* 310 */
enum STATE : __int32
{
	ST_NORMAL = 0x0,
	ST_PERCENT = 0x1,
	ST_FLAG = 0x2,
	ST_WIDTH = 0x3,
	ST_DOT = 0x4,
	ST_PRECIS = 0x5,
	ST_SIZE = 0x6,
	ST_TYPE = 0x7,
};

/* 311 */
enum CHARTYPE : __int32
{
	CH_OTHER = 0x0,
	CH_PERCENT = 0x1,
	CH_DOT = 0x2,
	CH_STAR = 0x3,
	CH_ZERO = 0x4,
	CH_DIGIT = 0x5,
	CH_FLAG = 0x6,
	CH_SIZE = 0x7,
	CH_TYPE = 0x8,
};

/* 312 */
enum $D283E5A92EBEB600100C8EBC9C67A011 : __int32
{
	lkNormal = 0x0,
	lkPrealloc = 0x1,
	lkDeleted = 0x2,
};

/* 313 */
enum _RTC_ErrorNumber : __int32
{
	_RTC_CHKSTK = 0x0,
	_RTC_CVRT_LOSS_INFO = 0x1,
	_RTC_CORRUPT_STACK = 0x2,
	_RTC_UNINIT_LOCAL_USE = 0x3,
	_RTC_ILLEGAL = 0x4,
};

/* 320 */
#pragma pack(push, 1)
class StrCmp
{
};
#pragma pack(pop)

/* 321 */
#pragma pack(push, 1)
class CIOException
{
};
#pragma pack(pop)

/* 325 */
#pragma pack(push, 1)
class std::allocator<char>::rebind<char>
{
};
#pragma pack(pop)

/* 329 */
#pragma pack(push, 1)
class CIOBuffer::CSlot
{
	CIOBuffer* m_pBuffer;
	CIOSpinLock m_lock;
};
#pragma pack(pop)

/* 330 */
#pragma pack(push, 1)
class CIOSocket::CInit
{
};
#pragma pack(pop)

/* 331 */
#pragma pack(push, 1)
class /*VFT*/ CIOSocket::CIOTimerInstance_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
};
#pragma pack(pop)

/* 332 */
#pragma pack(push, 1)
class /*VFT*/ CIOSocket_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	void(__thiscall* OnCreate)(CIOSocket* this);
	void(__thiscall* OnClose)(CIOSocket* this);
	void(__thiscall* OnRead)(CIOSocket* this);
};
#pragma pack(pop)

/* 336 */
#pragma pack(push, 1)
class /*VFT*/ lisp::_string_vtbl
{
	const char* (__thiscall* GetString)(lisp::_object* this);
	int(__thiscall* GetInteger)(lisp::_object* this);
	unsigned int(__thiscall* GetUnsigned)(lisp::_object* this);
	lisp::var* (__thiscall* car)(lisp::_object* this);
	lisp::var* (__thiscall* cdr)(lisp::_object* this);
	bool(__thiscall* consp)(lisp::_object* this);
	bool(__thiscall* null)(lisp::_object* this);
	bool(__thiscall* stringp)(lisp::_object* this);
	bool(__thiscall* integerp)(lisp::_object* this);
	int(__thiscall* length)(lisp::_object* this);
};
#pragma pack(pop)

/* 337 */
#pragma pack(push, 1)
class /*VFT*/ lisp::_integer_vtbl
{
	const char* (__thiscall* GetString)(lisp::_object* this);
	int(__thiscall* GetInteger)(lisp::_object* this);
	unsigned int(__thiscall* GetUnsigned)(lisp::_object* this);
	lisp::var* (__thiscall* car)(lisp::_object* this);
	lisp::var* (__thiscall* cdr)(lisp::_object* this);
	bool(__thiscall* consp)(lisp::_object* this);
	bool(__thiscall* null)(lisp::_object* this);
	bool(__thiscall* stringp)(lisp::_object* this);
	bool(__thiscall* integerp)(lisp::_object* this);
	int(__thiscall* length)(lisp::_object* this);
};
#pragma pack(pop)

/* 338 */
#pragma pack(push, 1)
class lisp::_integer : lisp::_object
{
	int m_nValue;
};
#pragma pack(pop)

/* 339 */
#pragma pack(push, 1)
class /*VFT*/ lisp::_cons_vtbl
{
	const char* (__thiscall* GetString)(lisp::_object* this);
	int(__thiscall* GetInteger)(lisp::_object* this);
	unsigned int(__thiscall* GetUnsigned)(lisp::_object* this);
	lisp::var* (__thiscall* car)(lisp::_object* this);
	lisp::var* (__thiscall* cdr)(lisp::_object* this);
	bool(__thiscall* consp)(lisp::_object* this);
	bool(__thiscall* null)(lisp::_object* this);
	bool(__thiscall* stringp)(lisp::_object* this);
	bool(__thiscall* integerp)(lisp::_object* this);
	int(__thiscall* length)(lisp::_object* this);
};
#pragma pack(pop)

/* 340 */
#pragma pack(push, 1)
class /*VFT*/ lisp::_null_vtbl
{
	const char* (__thiscall* GetString)(lisp::_object* this);
	int(__thiscall* GetInteger)(lisp::_object* this);
	unsigned int(__thiscall* GetUnsigned)(lisp::_object* this);
	lisp::var* (__thiscall* car)(lisp::_object* this);
	lisp::var* (__thiscall* cdr)(lisp::_object* this);
	bool(__thiscall* consp)(lisp::_object* this);
	bool(__thiscall* null)(lisp::_object* this);
	bool(__thiscall* stringp)(lisp::_object* this);
	bool(__thiscall* integerp)(lisp::_object* this);
	int(__thiscall* length)(lisp::_object* this);
};
#pragma pack(pop)

/* 341 */
#pragma pack(push, 1)
class lisp::_null : lisp::_object
{
};
#pragma pack(pop)

/* 342 */
#pragma pack(push, 1)
class lisp
{
};
#pragma pack(pop)

/* 344 */
#pragma pack(push, 1)
class /*VFT*/ CBase_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
};
#pragma pack(pop)

/* 345 */
#pragma pack(push, 1)
class CBaseList
{
	CBase* m_pBase;
	CBaseList* m_pNext;
};
#pragma pack(pop)

/* 366 */
#pragma pack(push, 1)
class /*VFT*/ CInitMonster_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
};
#pragma pack(pop)

/* 387 */
#pragma pack(push, 1)
class /*VFT*/ CChar_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
};
#pragma pack(pop)

/* 407 */
#pragma pack(push, 1)
class /*VFT*/ CAlliance_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
};
#pragma pack(pop)

/* 408 */
#pragma pack(push, 1)
class /*VFT*/ CGuild_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
};
#pragma pack(pop)

/* 439 */
#pragma pack(push, 1)
class /*VFT*/ CInitItem_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
};
#pragma pack(pop)

/* 441 */
#pragma pack(push, 1)
class /*VFT*/ CPrefix_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
};
#pragma pack(pop)

/* 442 */
#pragma pack(push, 1)
class CItem_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	void(__thiscall* PutInfo)(CItem* this, char**, int);
	void(__thiscall* Init_)(CItem*, int, int, int);
	void(__thiscall* Init)(CItem* this, int, char**);
	void(__thiscall* SetWearState)(CItem* this, CPlayer*);
	int(__thiscall* Trash)(CItem* this, CPlayer*, int);
	void(__thiscall* Erase)(CItem* this, int);
	void(__thiscall* PutOn)(CItem* this, CPlayer*);
	void(__thiscall* PutOff)(CItem* this, CPlayer*);
	void(__thiscall* ApplySpec)(CItem* this, CPlayer*);
	void(__thiscall* FreeSpec)(CItem* this, CPlayer*);
	int Use_;
	void(__thiscall* Insert)(CItem* this, int, int);
	int(__thiscall* UpdateNum)(CItem* this, CPlayer*, int, int);
	void(__thiscall* Drop)(CItem* this, CChar*, const tagPOINT*, const tagPOINT*, int, int, int);
	int(__thiscall* Use)(CItem* this, CPlayer*);
	CItem* (__thiscall* Trade)(CItem* this, CPlayer*, int, int);
	int(__thiscall* CanSell)(CItem* this, int);
	int(__thiscall* CanTrade)(CItem* this, int, CPlayer*, CPlayer*);
	int(__thiscall* CanDrop)(CItem* this, int, CPlayer*);
	int(__thiscall* CanMerge)(CItem* this, CItem*);
	int(__thiscall* StorageIn)(CItem* this, CPlayer*, int);
	int(__thiscall* StorageOut)(CItem* this, CPlayer*, int, int, int*);
	void(__thiscall* ForcedStorageIn)(CItem* this, int, int, char*, int);
	int(__thiscall* IsMoney)(CItem* this);
	int(__thiscall* IsBroken)(CItem* this);
	int(__thiscall* Enchant)(CItem* this, CPlayer*, CItem*);
	int(__thiscall* Charming)(CItem* this, CPlayer*, int);
	int(__thiscall* CharmingCheat)(CItem* this, CPlayer*, int, int);
	int(__thiscall* Repair)(CItem* this, CPlayer*);
	int(__thiscall* ChangePrefix)(CItem* this, CPlayer*, int, int*, int*);
	int(__thiscall* Protect)(CItem* this, CPlayer*);
	int(__thiscall* IsQuestItem)(CItem* this);
	int(__thiscall* GetSellMoney)(CItem* this, int);
	void(__thiscall* SetEtc)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeDestroy)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeRateUp)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeLevel)(CItem* this, CPlayer*);
};
#pragma pack(pop)

/* 452 */
#pragma pack(push, 1)
class /*VFT*/ CItemMoney_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	void(__thiscall* PutInfo)(CItem* this, char**, int);
	_BYTE gap4C[4];
	void(__thiscall* Init)(CItem* this, int, char**);
	void(__thiscall* SetWearState)(CItem* this, CPlayer*);
	int(__thiscall* Trash)(CItem* this, CPlayer*, int);
	void(__thiscall* Erase)(CItem* this, int);
	void(__thiscall* PutOn)(CItem* this, CPlayer*);
	void(__thiscall* PutOff)(CItem* this, CPlayer*);
	void(__thiscall* ApplySpec)(CItem* this, CPlayer*);
	void(__thiscall* FreeSpec)(CItem* this, CPlayer*);
	_BYTE gap70[4];
	void(__thiscall* Insert)(CItem* this, int, int);
	int(__thiscall* UpdateNum)(CItem* this, CPlayer*, int, int);
	void(__thiscall* Drop)(CItem* this, CChar*, const tagPOINT*, const tagPOINT*, int, int, int);
	int(__thiscall* Use)(CItem* this, CPlayer*);
	CItem* (__thiscall* Trade)(CItem* this, CPlayer*, int, int);
	int(__thiscall* CanSell)(CItem* this, int);
	int(__thiscall* CanTrade)(CItem* this, int, CPlayer*, CPlayer*);
	int(__thiscall* CanDrop)(CItem* this, int, CPlayer*);
	int(__thiscall* CanMerge)(CItem* this, CItem*);
	int(__thiscall* StorageIn)(CItem* this, CPlayer*, int);
	int(__thiscall* StorageOut)(CItem* this, CPlayer*, int, int, int*);
	void(__thiscall* ForcedStorageIn)(CItem* this, int, int, char*, int);
	int(__thiscall* IsMoney)(CItem* this);
	int(__thiscall* IsBroken)(CItem* this);
	int(__thiscall* Enchant)(CItem* this, CPlayer*, CItem*);
	int(__thiscall* Charming)(CItem* this, CPlayer*, int);
	int(__thiscall* CharmingCheat)(CItem* this, CPlayer*, int, int);
	int(__thiscall* Repair)(CItem* this, CPlayer*);
	int(__thiscall* ChangePrefix)(CItem* this, CPlayer*, int, int*, int*);
	int(__thiscall* Protect)(CItem* this, CPlayer*);
	int(__thiscall* IsQuestItem)(CItem* this);
	int(__thiscall* GetSellMoney)(CItem* this, int);
	void(__thiscall* SetEtc)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeDestroy)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeRateUp)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeLevel)(CItem* this, CPlayer*);
};
#pragma pack(pop)

/* 454 */
#pragma pack(push, 1)
class /*VFT*/ CTrade_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
};
#pragma pack(pop)

/* 456 */
#pragma pack(push, 1)
class /*VFT*/ CItemTransform_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	void(__thiscall* PutInfo)(CItem* this, char**, int);
	_BYTE gap4C[4];
	void(__thiscall* Init)(CItem* this, int, char**);
	void(__thiscall* SetWearState)(CItem* this, CPlayer*);
	int(__thiscall* Trash)(CItem* this, CPlayer*, int);
	void(__thiscall* Erase)(CItem* this, int);
	void(__thiscall* PutOn)(CItem* this, CPlayer*);
	void(__thiscall* PutOff)(CItem* this, CPlayer*);
	void(__thiscall* ApplySpec)(CItem* this, CPlayer*);
	void(__thiscall* FreeSpec)(CItem* this, CPlayer*);
	_BYTE gap70[4];
	void(__thiscall* Insert)(CItem* this, int, int);
	int(__thiscall* UpdateNum)(CItem* this, CPlayer*, int, int);
	void(__thiscall* Drop)(CItem* this, CChar*, const tagPOINT*, const tagPOINT*, int, int, int);
	int(__thiscall* Use)(CItem* this, CPlayer*);
	CItem* (__thiscall* Trade)(CItem* this, CPlayer*, int, int);
	int(__thiscall* CanSell)(CItem* this, int);
	int(__thiscall* CanTrade)(CItem* this, int, CPlayer*, CPlayer*);
	int(__thiscall* CanDrop)(CItem* this, int, CPlayer*);
	int(__thiscall* CanMerge)(CItem* this, CItem*);
	int(__thiscall* StorageIn)(CItem* this, CPlayer*, int);
	int(__thiscall* StorageOut)(CItem* this, CPlayer*, int, int, int*);
	void(__thiscall* ForcedStorageIn)(CItem* this, int, int, char*, int);
	int(__thiscall* IsMoney)(CItem* this);
	int(__thiscall* IsBroken)(CItem* this);
	int(__thiscall* Enchant)(CItem* this, CPlayer*, CItem*);
	int(__thiscall* Charming)(CItem* this, CPlayer*, int);
	int(__thiscall* CharmingCheat)(CItem* this, CPlayer*, int, int);
	int(__thiscall* Repair)(CItem* this, CPlayer*);
	int(__thiscall* ChangePrefix)(CItem* this, CPlayer*, int, int*, int*);
	int(__thiscall* Protect)(CItem* this, CPlayer*);
	int(__thiscall* IsQuestItem)(CItem* this);
	int(__thiscall* GetSellMoney)(CItem* this, int);
	void(__thiscall* SetEtc)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeDestroy)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeRateUp)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeLevel)(CItem* this, CPlayer*);
};
#pragma pack(pop)

/* 458 */
#pragma pack(push, 1)
class /*VFT*/ CItemDefense_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	void(__thiscall* PutInfo)(CItem* this, char**, int);
	_BYTE gap4C[4];
	void(__thiscall* Init)(CItem* this, int, char**);
	void(__thiscall* SetWearState)(CItem* this, CPlayer*);
	int(__thiscall* Trash)(CItem* this, CPlayer*, int);
	void(__thiscall* Erase)(CItem* this, int);
	void(__thiscall* PutOn)(CItem* this, CPlayer*);
	void(__thiscall* PutOff)(CItem* this, CPlayer*);
	void(__thiscall* ApplySpec)(CItem* this, CPlayer*);
	void(__thiscall* FreeSpec)(CItem* this, CPlayer*);
	_BYTE gap70[4];
	void(__thiscall* Insert)(CItem* this, int, int);
	int(__thiscall* UpdateNum)(CItem* this, CPlayer*, int, int);
	void(__thiscall* Drop)(CItem* this, CChar*, const tagPOINT*, const tagPOINT*, int, int, int);
	int(__thiscall* Use)(CItem* this, CPlayer*);
	CItem* (__thiscall* Trade)(CItem* this, CPlayer*, int, int);
	int(__thiscall* CanSell)(CItem* this, int);
	int(__thiscall* CanTrade)(CItem* this, int, CPlayer*, CPlayer*);
	int(__thiscall* CanDrop)(CItem* this, int, CPlayer*);
	int(__thiscall* CanMerge)(CItem* this, CItem*);
	int(__thiscall* StorageIn)(CItem* this, CPlayer*, int);
	int(__thiscall* StorageOut)(CItem* this, CPlayer*, int, int, int*);
	void(__thiscall* ForcedStorageIn)(CItem* this, int, int, char*, int);
	int(__thiscall* IsMoney)(CItem* this);
	int(__thiscall* IsBroken)(CItem* this);
	int(__thiscall* Enchant)(CItem* this, CPlayer*, CItem*);
	int(__thiscall* Charming)(CItem* this, CPlayer*, int);
	int(__thiscall* CharmingCheat)(CItem* this, CPlayer*, int, int);
	int(__thiscall* Repair)(CItem* this, CPlayer*);
	int(__thiscall* ChangePrefix)(CItem* this, CPlayer*, int, int*, int*);
	int(__thiscall* Protect)(CItem* this, CPlayer*);
	int(__thiscall* IsQuestItem)(CItem* this);
	int(__thiscall* GetSellMoney)(CItem* this, int);
	void(__thiscall* SetEtc)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeDestroy)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeRateUp)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeLevel)(CItem* this, CPlayer*);
};
#pragma pack(pop)

/* 460 */
#pragma pack(push, 1)
class /*VFT*/ CItemStandard_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	void(__thiscall* PutInfo)(CItem* this, char**, int);
	_BYTE gap4C[4];
	void(__thiscall* Init)(CItem* this, int, char**);
	void(__thiscall* SetWearState)(CItem* this, CPlayer*);
	int(__thiscall* Trash)(CItem* this, CPlayer*, int);
	void(__thiscall* Erase)(CItem* this, int);
	void(__thiscall* PutOn)(CItem* this, CPlayer*);
	void(__thiscall* PutOff)(CItem* this, CPlayer*);
	void(__thiscall* ApplySpec)(CItem* this, CPlayer*);
	void(__thiscall* FreeSpec)(CItem* this, CPlayer*);
	_BYTE gap70[4];
	void(__thiscall* Insert)(CItem* this, int, int);
	int(__thiscall* UpdateNum)(CItem* this, CPlayer*, int, int);
	void(__thiscall* Drop)(CItem* this, CChar*, const tagPOINT*, const tagPOINT*, int, int, int);
	int(__thiscall* Use)(CItem* this, CPlayer*);
	CItem* (__thiscall* Trade)(CItem* this, CPlayer*, int, int);
	int(__thiscall* CanSell)(CItem* this, int);
	int(__thiscall* CanTrade)(CItem* this, int, CPlayer*, CPlayer*);
	int(__thiscall* CanDrop)(CItem* this, int, CPlayer*);
	int(__thiscall* CanMerge)(CItem* this, CItem*);
	int(__thiscall* StorageIn)(CItem* this, CPlayer*, int);
	int(__thiscall* StorageOut)(CItem* this, CPlayer*, int, int, int*);
	void(__thiscall* ForcedStorageIn)(CItem* this, int, int, char*, int);
	int(__thiscall* IsMoney)(CItem* this);
	int(__thiscall* IsBroken)(CItem* this);
	int(__thiscall* Enchant)(CItem* this, CPlayer*, CItem*);
	int(__thiscall* Charming)(CItem* this, CPlayer*, int);
	int(__thiscall* CharmingCheat)(CItem* this, CPlayer*, int, int);
	int(__thiscall* Repair)(CItem* this, CPlayer*);
	int(__thiscall* ChangePrefix)(CItem* this, CPlayer*, int, int*, int*);
	int(__thiscall* Protect)(CItem* this, CPlayer*);
	int(__thiscall* IsQuestItem)(CItem* this);
	int(__thiscall* GetSellMoney)(CItem* this, int);
	void(__thiscall* SetEtc)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeDestroy)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeRateUp)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeLevel)(CItem* this, CPlayer*);
};
#pragma pack(pop)

/* 554 */
#pragma pack(push, 1)
class /*VFT*/ CSocket_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	void(__thiscall* OnCreate)(CIOSocket* this);
	void(__thiscall* OnClose)(CIOSocket* this);
	void(__thiscall* OnRead)(CIOSocket* this);
};
#pragma pack(pop)

/* 555 */
#pragma pack(push, 1)
class /*VFT*/ CPlayer_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	void(__thiscall* UpdateTransformExp)(CPlayer* this, int);
};
#pragma pack(pop)

/* 556 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 557 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 558 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 559 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> > : std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 560 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 561 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 562 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 563 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, CPlayer*> >
{
};
#pragma pack(pop)

/* 564 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CPlayer*> > : std::_Allocator_base<std::pair<int const, CPlayer*> >
{
};
#pragma pack(pop)

/* 565 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >
{
	std::allocator<std::pair<int const, CPlayer*> > _Alval;
};
#pragma pack(pop)

/* 566 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::_Node* _Right;
	std::pair<int const, CPlayer*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 567 */
#pragma pack(push, 1)
class std::pair<int const, CPlayer*>
{
	const int first;
	CPlayer* second;
};
#pragma pack(pop)

/* 568 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 569 */
#pragma pack(push, 1)
class std::map<int, CPlayer*> : std::_Tree<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >
{
};
#pragma pack(pop)

/* 570 */
#pragma pack(push, 1)
class std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0>
{
	StrCmp comp;
};
#pragma pack(pop)

/* 571 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 572 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 573 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> > : std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 574 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 575 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 576 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 577 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<char const* const, CPlayer*> >
{
};
#pragma pack(pop)

/* 578 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, CPlayer*> > : std::_Allocator_base<std::pair<char const* const, CPlayer*> >
{
};
#pragma pack(pop)

/* 579 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >
{
	std::allocator<std::pair<char const* const, CPlayer*> > _Alval;
};
#pragma pack(pop)

/* 580 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::_Node* _Right;
	std::pair<char const* const, CPlayer*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 581 */
#pragma pack(push, 1)
class std::pair<char const* const, CPlayer*>
{
	const char* const first;
	CPlayer* second;
};
#pragma pack(pop)

/* 582 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> > : std::_Tree_val<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 583 */
#pragma pack(push, 1)
class std::map<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> > > : std::_Tree<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >
{
};
#pragma pack(pop)

/* 584 */
#pragma pack(push, 1)
class CItemWeapon : CItem
{
	int m_nMaxEnd;
	int m_nCurEnd;
	int m_nXAttack;
	int m_nXMagic;
	int m_nXDefense;
	int m_nXHit;
	int m_nXDodge;
	int m_nProtect;
	int m_nUpgrLevel;
	int m_nUpgrRate;
};
#pragma pack(pop)

/* 585 */
#pragma pack(push, 1)
class /*VFT*/ CItemWeapon_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	void(__thiscall* PutInfo)(CItem* this, char**, int);
	_BYTE gap4C[4];
	void(__thiscall* Init)(CItem* this, int, char**);
	void(__thiscall* SetWearState)(CItem* this, CPlayer*);
	int(__thiscall* Trash)(CItem* this, CPlayer*, int);
	void(__thiscall* Erase)(CItem* this, int);
	void(__thiscall* PutOn)(CItem* this, CPlayer*);
	void(__thiscall* PutOff)(CItem* this, CPlayer*);
	void(__thiscall* ApplySpec)(CItem* this, CPlayer*);
	void(__thiscall* FreeSpec)(CItem* this, CPlayer*);
	_BYTE gap70[4];
	void(__thiscall* Insert)(CItem* this, int, int);
	int(__thiscall* UpdateNum)(CItem* this, CPlayer*, int, int);
	void(__thiscall* Drop)(CItem* this, CChar*, const tagPOINT*, const tagPOINT*, int, int, int);
	int(__thiscall* Use)(CItem* this, CPlayer*);
	CItem* (__thiscall* Trade)(CItem* this, CPlayer*, int, int);
	int(__thiscall* CanSell)(CItem* this, int);
	int(__thiscall* CanTrade)(CItem* this, int, CPlayer*, CPlayer*);
	int(__thiscall* CanDrop)(CItem* this, int, CPlayer*);
	int(__thiscall* CanMerge)(CItem* this, CItem*);
	int(__thiscall* StorageIn)(CItem* this, CPlayer*, int);
	int(__thiscall* StorageOut)(CItem* this, CPlayer*, int, int, int*);
	void(__thiscall* ForcedStorageIn)(CItem* this, int, int, char*, int);
	int(__thiscall* IsMoney)(CItem* this);
	int(__thiscall* IsBroken)(CItem* this);
	int(__thiscall* Enchant)(CItem* this, CPlayer*, CItem*);
	int(__thiscall* Charming)(CItem* this, CPlayer*, int);
	int(__thiscall* CharmingCheat)(CItem* this, CPlayer*, int, int);
	int(__thiscall* Repair)(CItem* this, CPlayer*);
	int(__thiscall* ChangePrefix)(CItem* this, CPlayer*, int, int*, int*);
	int(__thiscall* Protect)(CItem* this, CPlayer*);
	int(__thiscall* IsQuestItem)(CItem* this);
	int(__thiscall* GetSellMoney)(CItem* this, int);
	void(__thiscall* SetEtc)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeDestroy)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeRateUp)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeLevel)(CItem* this, CPlayer*);
};
#pragma pack(pop)

/* 586 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 587 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 588 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 589 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> > : std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 590 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 591 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 592 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 593 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, CInitItem*> >
{
};
#pragma pack(pop)

/* 594 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CInitItem*> > : std::_Allocator_base<std::pair<int const, CInitItem*> >
{
};
#pragma pack(pop)

/* 595 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >
{
	std::allocator<std::pair<int const, CInitItem*> > _Alval;
};
#pragma pack(pop)

/* 596 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >::_Node* _Right;
	std::pair<int const, CInitItem*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 597 */
#pragma pack(push, 1)
class std::pair<int const, CInitItem*>
{
	const int first;
	CInitItem* second;
};
#pragma pack(pop)

/* 598 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 599 */
#pragma pack(push, 1)
class std::map<int, CInitItem*> : std::_Tree<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >
{
};
#pragma pack(pop)

/* 600 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 601 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 602 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 603 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> > : std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 604 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 605 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 606 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 607 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, CPrefix*> >
{
};
#pragma pack(pop)

/* 608 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CPrefix*> > : std::_Allocator_base<std::pair<int const, CPrefix*> >
{
};
#pragma pack(pop)

/* 609 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >
{
	std::allocator<std::pair<int const, CPrefix*> > _Alval;
};
#pragma pack(pop)

/* 610 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >::_Node* _Right;
	std::pair<int const, CPrefix*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 611 */
#pragma pack(push, 1)
class std::pair<int const, CPrefix*>
{
	const int first;
	CPrefix* second;
};
#pragma pack(pop)

/* 612 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 613 */
#pragma pack(push, 1)
class std::map<int, CPrefix*> : std::_Tree<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >
{
};
#pragma pack(pop)

/* 614 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 615 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 616 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 617 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> > : std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 618 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 619 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 620 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 621 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, CItemGroup*> >
{
};
#pragma pack(pop)

/* 622 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CItemGroup*> > : std::_Allocator_base<std::pair<int const, CItemGroup*> >
{
};
#pragma pack(pop)

/* 623 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >
{
	std::allocator<std::pair<int const, CItemGroup*> > _Alval;
};
#pragma pack(pop)

/* 624 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >::_Node* _Right;
	std::pair<int const, CItemGroup*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 639 */
#pragma pack(push, 1)
class std::pair<int const, CItemGroup*>
{
	const int first;
	CItemGroup* second;
};
#pragma pack(pop)

/* 625 */
#pragma pack(push, 1)
class std::_Allocator_base<ITEMGROUP>
{
};
#pragma pack(pop)

/* 626 */
#pragma pack(push, 1)
class std::allocator<ITEMGROUP> : std::_Allocator_base<ITEMGROUP>
{
};
#pragma pack(pop)

/* 627 */
#pragma pack(push, 1)
class std::_Vector_val<ITEMGROUP>
{
	std::allocator<ITEMGROUP> _Alval;
};
#pragma pack(pop)

/* 636 */
#pragma pack(push, 1)
class std::vector<ITEMGROUP> : std::_Vector_val<ITEMGROUP>
{
	__declspec(align(4)) ITEMGROUP* _Myfirst;
	ITEMGROUP* _Mylast;
	ITEMGROUP* _Myend;
};
#pragma pack(pop)

/* 637 */
#pragma pack(push, 1)
class CItemGroup : CBase
{
	int m_nIndex;
	std::vector<ITEMGROUP> m_vecGroup;
};
#pragma pack(pop)

/* 635 */
#pragma pack(push, 1)
class ITEMGROUP
{
	int nPer;
	CGroup* pGroup;
};
#pragma pack(pop)

/* 628 */
#pragma pack(push, 1)
class std::_Allocator_base<ITEMDROPINFO>
{
};
#pragma pack(pop)

/* 629 */
#pragma pack(push, 1)
class std::allocator<ITEMDROPINFO> : std::_Allocator_base<ITEMDROPINFO>
{
};
#pragma pack(pop)

/* 630 */
#pragma pack(push, 1)
class std::_Vector_val<ITEMDROPINFO>
{
	std::allocator<ITEMDROPINFO> _Alval;
};
#pragma pack(pop)

/* 632 */
#pragma pack(push, 1)
class std::vector<ITEMDROPINFO> : std::_Vector_val<ITEMDROPINFO>
{
	__declspec(align(4)) ITEMDROPINFO* _Myfirst;
	ITEMDROPINFO* _Mylast;
	ITEMDROPINFO* _Myend;
};
#pragma pack(pop)

/* 633 */
#pragma pack(push, 1)
class CGroup : CBase
{
	int m_nID;
	std::vector<ITEMDROPINFO> m_vecItemInfo;
};
#pragma pack(pop)

/* 631 */
#pragma pack(push, 1)
class ITEMDROPINFO
{
	int nPer;
	int nItemID;
	int nPrefix;
	int nNum;
};
#pragma pack(pop)

/* 634 */
#pragma pack(push, 1)
class /*VFT*/ CGroup_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
};
#pragma pack(pop)

/* 638 */
#pragma pack(push, 1)
class /*VFT*/ CItemGroup_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
};
#pragma pack(pop)

/* 640 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 641 */
#pragma pack(push, 1)
class std::map<int, CItemGroup*> : std::_Tree<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >
{
};
#pragma pack(pop)

/* 642 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<unsigned long const, CSkill*>, int, std::pair<unsigned long const, CSkill*> const*, std::pair<unsigned long const, CSkill*> const&>
{
};
#pragma pack(pop)

/* 643 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<unsigned long const, CSkill*>, int, std::pair<unsigned long const, CSkill*> const*, std::pair<unsigned long const, CSkill*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<unsigned long const, CSkill*>, int, std::pair<unsigned long const, CSkill*> const*, std::pair<unsigned long const, CSkill*> const&>
{
};
#pragma pack(pop)

/* 644 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >::const_iterator : std::_Bidit<std::pair<unsigned long const, CSkill*>, int, std::pair<unsigned long const, CSkill*> const*, std::pair<unsigned long const, CSkill*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 645 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 646 */
#pragma pack(push, 1)
class CInitSkill : CBase
{
	int m_nClass;
	int m_nIndex;
	int m_nLmtLevel;
	unsigned int m_dwLmtSpecialty;
	int m_nLmtSkill;
	int m_nLmtSkillLevel;
	int m_nLmtMaxLevel;
	int m_nRedistribute;
	int m_nRage;
	int m_nDecMP;
	int m_nLastTime;
	unsigned int m_dwDelayPre;
	unsigned int m_dwDelay;
	unsigned int m_dwActionDelay;
	int m_nV1;
	int m_nV2;
};
#pragma pack(pop)

/* 647 */
#pragma pack(push, 1)
class /*VFT*/ CInitSkill_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
};
#pragma pack(pop)

/* 648 */
#pragma pack(push, 1)
class std::allocator<std::pair<unsigned long const, CSkill*> >::rebind<std::pair<unsigned long const, CSkill*> >
{
};
#pragma pack(pop)

/* 649 */
#pragma pack(push, 1)
class std::allocator<std::pair<unsigned long const, CSkill*> >::rebind<std::_Tree_nod<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 650 */
#pragma pack(push, 1)
class std::allocator<std::pair<unsigned long const, CSkill*> >::rebind<std::_Tree_nod<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 651 */
#pragma pack(push, 1)
class std::allocator<std::pair<unsigned long const, CSkill*> >::rebind<unsigned long>
{
};
#pragma pack(pop)

/* 652 */
#pragma pack(push, 1)
class std::allocator<std::pair<unsigned long const, CSkill*> >::rebind<char>
{
};
#pragma pack(pop)

/* 653 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<unsigned long, CSkill*, std::less<unsigned long>, std::allocator<std::pair<unsigned long const, CSkill*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 654 */
#pragma pack(push, 1)
class std::_Allocator_base<unsigned long>
{
};
#pragma pack(pop)

/* 655 */
#pragma pack(push, 1)
class std::allocator<unsigned long> : std::_Allocator_base<unsigned long>
{
};
#pragma pack(pop)

/* 656 */
#pragma pack(push, 1)
class CMemoryPool<CSkill>::CPool
{
	CSkill* m_pT;
	CIOSpinLock m_lock;
};
#pragma pack(pop)

/* 657 */
#pragma pack(push, 1)
class CMemoryPool<CSkill>
{
};
#pragma pack(pop)

/* 658 */
#pragma pack(push, 1)
class /*VFT*/ CGunnery_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 659 */
#pragma pack(push, 1)
class CGunnery : CSkill
{
};
#pragma pack(pop)

/* 660 */
#pragma pack(push, 1)
class /*VFT*/ CReturn_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 661 */
#pragma pack(push, 1)
class CReturn : CSkill
{
};
#pragma pack(pop)

/* 662 */
#pragma pack(push, 1)
class /*VFT*/ CBoost_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 663 */
#pragma pack(push, 1)
class CBoost : CSkill
{
};
#pragma pack(pop)

/* 664 */
#pragma pack(push, 1)
class /*VFT*/ CBehead_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 665 */
#pragma pack(push, 1)
class CBehead : CSkill
{
};
#pragma pack(pop)

/* 666 */
#pragma pack(push, 1)
class /*VFT*/ CUpWeapon_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 667 */
#pragma pack(push, 1)
class CUpWeapon : CSkill
{
};
#pragma pack(pop)

/* 668 */
#pragma pack(push, 1)
class /*VFT*/ CUpBow_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 669 */
#pragma pack(push, 1)
class CUpBow : CSkill
{
};
#pragma pack(pop)

/* 670 */
#pragma pack(push, 1)
class /*VFT*/ CUpConCen_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 671 */
#pragma pack(push, 1)
class CUpConCen : CSkill
{
};
#pragma pack(pop)

/* 673 */
#pragma pack(push, 1)
class /*VFT*/ CBlow_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* Apply)(CBlow* this, CPlayer*, CChar*, unsigned int, int*, int*, int*);
	int(__thiscall* GetHit)(CBlow* this);
	void(__thiscall* AddMortal)(CBlow* this, CPlayer*);
};
#pragma pack(pop)

/* 674 */
#pragma pack(push, 1)
class /*VFT*/ CPullSwing_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* Apply)(CBlow* this, CPlayer*, CChar*, unsigned int, int*, int*, int*);
	int(__thiscall* GetHit)(CBlow* this);
	void(__thiscall* AddMortal)(CBlow* this, CPlayer*);
};
#pragma pack(pop)

/* 675 */
#pragma pack(push, 1)
class CPullSwing : CBlow
{
};
#pragma pack(pop)

/* 676 */
#pragma pack(push, 1)
class /*VFT*/ CThunder_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* Apply)(CBlow* this, CPlayer*, CChar*, unsigned int, int*, int*, int*);
	int(__thiscall* GetHit)(CBlow* this);
	void(__thiscall* AddMortal)(CBlow* this, CPlayer*);
};
#pragma pack(pop)

/* 677 */
#pragma pack(push, 1)
class /*VFT*/ CShot_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* Apply)(CBlow* this, CPlayer*, CChar*, unsigned int, int*, int*, int*);
	int(__thiscall* GetHit)(CBlow* this);
	void(__thiscall* AddMortal)(CBlow* this, CPlayer*);
};
#pragma pack(pop)

/* 678 */
#pragma pack(push, 1)
class /*VFT*/ CMock_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 679 */
#pragma pack(push, 1)
class /*VFT*/ CEnrage_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 680 */
#pragma pack(push, 1)
class CEnrage : CMock
{
};
#pragma pack(pop)

/* 681 */
#pragma pack(push, 1)
class /*VFT*/ CNegative_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* Apply)(CBlow* this, CPlayer*, CChar*, unsigned int, int*, int*, int*);
	int(__thiscall* GetHit)(CBlow* this);
	void(__thiscall* AddMortal)(CBlow* this, CPlayer*);
};
#pragma pack(pop)

/* 682 */
#pragma pack(push, 1)
class CNegative : CBlow
{
};
#pragma pack(pop)

/* 683 */
#pragma pack(push, 1)
class /*VFT*/ CFlameArrow_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* Apply)(CBlow* this, CPlayer*, CChar*, unsigned int, int*, int*, int*);
	int(__thiscall* GetHit)(CBlow* this);
	void(__thiscall* AddMortal)(CBlow* this, CPlayer*);
};
#pragma pack(pop)

/* 684 */
#pragma pack(push, 1)
class CFlameArrow : CBlow
{
};
#pragma pack(pop)

/* 685 */
#pragma pack(push, 1)
class /*VFT*/ CTranscendental_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* Apply)(CBlow* this, CPlayer*, CChar*, unsigned int, int*, int*, int*);
	int(__thiscall* GetHit)(CBlow* this);
	void(__thiscall* AddMortal)(CBlow* this, CPlayer*);
};
#pragma pack(pop)

/* 686 */
#pragma pack(push, 1)
class CTranscendental : CBlow
{
};
#pragma pack(pop)

/* 687 */
#pragma pack(push, 1)
class /*VFT*/ CUpperSlash_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* Apply)(CBlow* this, CPlayer*, CChar*, unsigned int, int*, int*, int*);
	int(__thiscall* GetHit)(CBlow* this);
	void(__thiscall* AddMortal)(CBlow* this, CPlayer*);
};
#pragma pack(pop)

/* 688 */
#pragma pack(push, 1)
class CUpperSlash : CBlow
{
};
#pragma pack(pop)

/* 689 */
#pragma pack(push, 1)
class /*VFT*/ CEdge_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* Apply)(CBlow* this, CPlayer*, CChar*, unsigned int, int*, int*, int*);
	int(__thiscall* GetHit)(CBlow* this);
	void(__thiscall* AddMortal)(CBlow* this, CPlayer*);
	int(__thiscall* GetSpendMP)(CEdge* this);
};
#pragma pack(pop)

/* 690 */
#pragma pack(push, 1)
class /*VFT*/ CFatalWound_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* Apply)(CBlow* this, CPlayer*, CChar*, unsigned int, int*, int*, int*);
	int(__thiscall* GetHit)(CBlow* this);
	void(__thiscall* AddMortal)(CBlow* this, CPlayer*);
};
#pragma pack(pop)

/* 691 */
#pragma pack(push, 1)
class CFatalWound : CBlow
{
};
#pragma pack(pop)

/* 692 */
#pragma pack(push, 1)
class /*VFT*/ CUpperSmash_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* Apply)(CBlow* this, CPlayer*, CChar*, unsigned int, int*, int*, int*);
	int(__thiscall* GetHit)(CBlow* this);
	void(__thiscall* AddMortal)(CBlow* this, CPlayer*);
};
#pragma pack(pop)

/* 693 */
#pragma pack(push, 1)
class CUpperSmash : CBlow
{
};
#pragma pack(pop)

/* 694 */
#pragma pack(push, 1)
class /*VFT*/ CInfernal_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* Apply)(CBlow* this, CPlayer*, CChar*, unsigned int, int*, int*, int*);
	int(__thiscall* GetHit)(CBlow* this);
	void(__thiscall* AddMortal)(CBlow* this, CPlayer*);
};
#pragma pack(pop)

/* 695 */
#pragma pack(push, 1)
class /*VFT*/ CShieldAttack_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* Apply)(CBlow* this, CPlayer*, CChar*, unsigned int, int*, int*, int*);
	int(__thiscall* GetHit)(CBlow* this);
	void(__thiscall* AddMortal)(CBlow* this, CPlayer*);
};
#pragma pack(pop)

/* 696 */
#pragma pack(push, 1)
class /*VFT*/ CStunArrow_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* Apply)(CBlow* this, CPlayer*, CChar*, unsigned int, int*, int*, int*);
	int(__thiscall* GetHit)(CBlow* this);
	void(__thiscall* AddMortal)(CBlow* this, CPlayer*);
};
#pragma pack(pop)

/* 697 */
#pragma pack(push, 1)
class CStunArrow : CBlow
{
};
#pragma pack(pop)

/* 698 */
#pragma pack(push, 1)
class /*VFT*/ CExplosion_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* Apply)(CBlow* this, CPlayer*, CChar*, unsigned int, int*, int*, int*);
	int(__thiscall* GetHit)(CBlow* this);
	void(__thiscall* AddMortal)(CBlow* this, CPlayer*);
};
#pragma pack(pop)

/* 699 */
#pragma pack(push, 1)
class /*VFT*/ CGetherShot_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* Apply)(CBlow* this, CPlayer*, CChar*, unsigned int, int*, int*, int*);
	int(__thiscall* GetHit)(CBlow* this);
	void(__thiscall* AddMortal)(CBlow* this, CPlayer*);
};
#pragma pack(pop)

/* 700 */
#pragma pack(push, 1)
class /*VFT*/ CMysticArrow_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* Apply)(CBlow* this, CPlayer*, CChar*, unsigned int, int*, int*, int*);
	int(__thiscall* GetHit)(CBlow* this);
	void(__thiscall* AddMortal)(CBlow* this, CPlayer*);
};
#pragma pack(pop)

/* 701 */
#pragma pack(push, 1)
class /*VFT*/ CMagic_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
};
#pragma pack(pop)

/* 702 */
#pragma pack(push, 1)
class /*VFT*/ CSpiritBlast_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
};
#pragma pack(pop)

/* 703 */
#pragma pack(push, 1)
class CSpiritBlast : CMagic
{
};
#pragma pack(pop)

/* 704 */
#pragma pack(push, 1)
class /*VFT*/ CFire_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
};
#pragma pack(pop)

/* 705 */
#pragma pack(push, 1)
class CFire : CMagic
{
};
#pragma pack(pop)

/* 706 */
#pragma pack(push, 1)
class /*VFT*/ CFireExplosion_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
};
#pragma pack(pop)

/* 707 */
#pragma pack(push, 1)
class CFireExplosion : CFire
{
};
#pragma pack(pop)

/* 708 */
#pragma pack(push, 1)
class /*VFT*/ CFireEruption_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
};
#pragma pack(pop)

/* 709 */
#pragma pack(push, 1)
class CFireEruption : CFire
{
};
#pragma pack(pop)

/* 710 */
#pragma pack(push, 1)
class /*VFT*/ CIce_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
};
#pragma pack(pop)

/* 711 */
#pragma pack(push, 1)
class CIce : CMagic
{
};
#pragma pack(pop)

/* 712 */
#pragma pack(push, 1)
class /*VFT*/ CIceLance_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
};
#pragma pack(pop)

/* 713 */
#pragma pack(push, 1)
class CIceLance : CIce
{
};
#pragma pack(pop)

/* 714 */
#pragma pack(push, 1)
class /*VFT*/ CLitning_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
};
#pragma pack(pop)

/* 716 */
#pragma pack(push, 1)
class /*VFT*/ CShock_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
};
#pragma pack(pop)

/* 717 */
#pragma pack(push, 1)
class CShock : CLitning
{
};
#pragma pack(pop)

/* 718 */
#pragma pack(push, 1)
class /*VFT*/ CSpark_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
};
#pragma pack(pop)

/* 719 */
#pragma pack(push, 1)
class CSpark : CLitning
{
};
#pragma pack(pop)

/* 720 */
#pragma pack(push, 1)
class /*VFT*/ CCallLitning_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
};
#pragma pack(pop)

/* 721 */
#pragma pack(push, 1)
class /*VFT*/ CThunderLitning_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
};
#pragma pack(pop)

/* 722 */
#pragma pack(push, 1)
class CThunderLitning : CLitning
{
};
#pragma pack(pop)

/* 724 */
#pragma pack(push, 1)
class /*VFT*/ CMagicWide_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 725 */
#pragma pack(push, 1)
class /*VFT*/ CMagicWideSelf_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 726 */
#pragma pack(push, 1)
class /*VFT*/ CMagicWidePos_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 727 */
#pragma pack(push, 1)
class CMagicWidePos : CMagicWide
{
};
#pragma pack(pop)

/* 728 */
#pragma pack(push, 1)
class /*VFT*/ CExplosiveBurst_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 729 */
#pragma pack(push, 1)
class CExplosiveBurst : CMagicWidePos
{
};
#pragma pack(pop)

/* 730 */
#pragma pack(push, 1)
class /*VFT*/ CMagicWideFire_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 731 */
#pragma pack(push, 1)
class CMagicWideFire : CMagicWide
{
};
#pragma pack(pop)

/* 732 */
#pragma pack(push, 1)
class /*VFT*/ CMesmerization_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 733 */
#pragma pack(push, 1)
class CMesmerization : CMagicWide
{
};
#pragma pack(pop)

/* 734 */
#pragma pack(push, 1)
class /*VFT*/ CSnowField_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 735 */
#pragma pack(push, 1)
class CSnowField : CMagicWide
{
};
#pragma pack(pop)

/* 736 */
#pragma pack(push, 1)
class /*VFT*/ CChainLitning_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 737 */
#pragma pack(push, 1)
class CChainLitning : CMagicWide
{
};
#pragma pack(pop)

/* 738 */
#pragma pack(push, 1)
class /*VFT*/ CIceRequiem_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 739 */
#pragma pack(push, 1)
class CIceRequiem : CMagicWide
{
};
#pragma pack(pop)

/* 740 */
#pragma pack(push, 1)
class /*VFT*/ CMagicWideIce_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 741 */
#pragma pack(push, 1)
class CMagicWideIce : CMagicWideSelf
{
};
#pragma pack(pop)

/* 742 */
#pragma pack(push, 1)
class CMagicConti : CMagic
{
};
#pragma pack(pop)

/* 743 */
#pragma pack(push, 1)
class /*VFT*/ CMagicConti_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	void(__thiscall* ExcuteM)(CMagicConti* this, CMonster*, tagPOINT);
	int(__thiscall* GetRadiusTile)(CMagicConti* this);
	int(__thiscall* AddMagicMonster)(CMagicConti* this, CPlayer*, tagPOINT);
	int(__thiscall* AddMagicMonsterM)(CMagicConti* this, CMonster*, tagPOINT);
};
#pragma pack(pop)

/* 744 */
#pragma pack(push, 1)
class /*VFT*/ CThunderStorm_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	void(__thiscall* ExcuteM)(CMagicConti* this, CMonster*, tagPOINT);
	int(__thiscall* GetRadiusTile)(CMagicConti* this);
	int(__thiscall* AddMagicMonster)(CMagicConti* this, CPlayer*, tagPOINT);
	int(__thiscall* AddMagicMonsterM)(CMagicConti* this, CMonster*, tagPOINT);
};
#pragma pack(pop)

/* 745 */
#pragma pack(push, 1)
class CThunderStorm : CMagicConti
{
};
#pragma pack(pop)

/* 746 */
#pragma pack(push, 1)
class /*VFT*/ CIceStorm_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	void(__thiscall* ExcuteM)(CMagicConti* this, CMonster*, tagPOINT);
	int(__thiscall* GetRadiusTile)(CMagicConti* this);
	int(__thiscall* AddMagicMonster)(CMagicConti* this, CPlayer*, tagPOINT);
	int(__thiscall* AddMagicMonsterM)(CMagicConti* this, CMonster*, tagPOINT);
};
#pragma pack(pop)

/* 747 */
#pragma pack(push, 1)
class CIceStorm : CMagicConti
{
};
#pragma pack(pop)

/* 748 */
#pragma pack(push, 1)
class /*VFT*/ CFireRain_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	void(__thiscall* ExcuteM)(CMagicConti* this, CMonster*, tagPOINT);
	int(__thiscall* GetRadiusTile)(CMagicConti* this);
	int(__thiscall* AddMagicMonster)(CMagicConti* this, CPlayer*, tagPOINT);
	int(__thiscall* AddMagicMonsterM)(CMagicConti* this, CMonster*, tagPOINT);
};
#pragma pack(pop)

/* 749 */
#pragma pack(push, 1)
class CFireRain : CMagicConti
{
};
#pragma pack(pop)

/* 750 */
#pragma pack(push, 1)
class /*VFT*/ CPoisonCloud_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	void(__thiscall* ExcuteM)(CMagicConti* this, CMonster*, tagPOINT);
	int(__thiscall* GetRadiusTile)(CMagicConti* this);
	int(__thiscall* AddMagicMonster)(CMagicConti* this, CPlayer*, tagPOINT);
	int(__thiscall* AddMagicMonsterM)(CMagicConti* this, CMonster*, tagPOINT);
};
#pragma pack(pop)

/* 751 */
#pragma pack(push, 1)
class CPoisonCloud : CMagicConti
{
};
#pragma pack(pop)

/* 752 */
#pragma pack(push, 1)
class /*VFT*/ CHealing_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 753 */
#pragma pack(push, 1)
class CHealing : CSkill
{
};
#pragma pack(pop)

/* 755 */
#pragma pack(push, 1)
class /*VFT*/ CHealingAny_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetIncHP)(CHealingAny* this, CPlayer*, CChar*);
};
#pragma pack(pop)

/* 756 */
#pragma pack(push, 1)
class CHealingAnyPlus : CHealingAny
{
};
#pragma pack(pop)

/* 757 */
#pragma pack(push, 1)
class /*VFT*/ CHealingAnyPlus_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetIncHP)(CHealingAny* this, CPlayer*, CChar*);
	int(__thiscall* GetSpendMP)(CHealingAnyPlus* this);
};
#pragma pack(pop)

/* 758 */
#pragma pack(push, 1)
class CRestoration : CHealingAny
{
};
#pragma pack(pop)

/* 759 */
#pragma pack(push, 1)
class /*VFT*/ CRestoration_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetIncHP)(CHealingAny* this, CPlayer*, CChar*);
	int(__thiscall* GetSpendMP)(CRestoration* this);
};
#pragma pack(pop)

/* 760 */
#pragma pack(push, 1)
class /*VFT*/ CHealingAnyQuick_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetIncHP)(CHealingAny* this, CPlayer*, CChar*);
};
#pragma pack(pop)

/* 761 */
#pragma pack(push, 1)
class /*VFT*/ CHealingInstance_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetIncHP)(CHealingAny* this, CPlayer*, CChar*);
};
#pragma pack(pop)

/* 762 */
#pragma pack(push, 1)
class CHealingInstance : CHealingAny
{
};
#pragma pack(pop)

/* 763 */
#pragma pack(push, 1)
class /*VFT*/ CHealingGreatRe_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetIncHP)(CHealingAny* this, CPlayer*, CChar*);
};
#pragma pack(pop)

/* 764 */
#pragma pack(push, 1)
class CHealingGreatRe : CHealingAny
{
};
#pragma pack(pop)

/* 765 */
#pragma pack(push, 1)
class /*VFT*/ CRest_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 766 */
#pragma pack(push, 1)
class CRest : CSkill
{
};
#pragma pack(pop)

/* 767 */
#pragma pack(push, 1)
class /*VFT*/ CUpFatal_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 768 */
#pragma pack(push, 1)
class CUpFatal : CSkill
{
};
#pragma pack(pop)

/* 769 */
#pragma pack(push, 1)
class /*VFT*/ CUpFatal2_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 770 */
#pragma pack(push, 1)
class CUpFatal2 : CSkill
{
};
#pragma pack(pop)

/* 771 */
#pragma pack(push, 1)
class /*VFT*/ CUpFatal3_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 772 */
#pragma pack(push, 1)
class CUpFatal3 : CSkill
{
};
#pragma pack(pop)

/* 773 */
#pragma pack(push, 1)
class /*VFT*/ CMeditation_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 774 */
#pragma pack(push, 1)
class /*VFT*/ CUpLitning_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 775 */
#pragma pack(push, 1)
class CUpLitning : CSkill
{
};
#pragma pack(pop)

/* 776 */
#pragma pack(push, 1)
class /*VFT*/ CUpIce_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 777 */
#pragma pack(push, 1)
class CUpIce : CSkill
{
};
#pragma pack(pop)

/* 778 */
#pragma pack(push, 1)
class /*VFT*/ CUpFire_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 779 */
#pragma pack(push, 1)
class CUpFire : CSkill
{
};
#pragma pack(pop)

/* 780 */
#pragma pack(push, 1)
class /*VFT*/ CFatalChance_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 781 */
#pragma pack(push, 1)
class CFatalChance : CSkill
{
};
#pragma pack(pop)

/* 782 */
#pragma pack(push, 1)
class /*VFT*/ CUpBlockShield_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 783 */
#pragma pack(push, 1)
class CUpBlockShield : CSkill
{
};
#pragma pack(pop)

/* 784 */
#pragma pack(push, 1)
class /*VFT*/ CUpParry_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 785 */
#pragma pack(push, 1)
class CUpParry : CSkill
{
};
#pragma pack(pop)

/* 786 */
#pragma pack(push, 1)
class CRevival : CSkill
{
};
#pragma pack(pop)

/* 787 */
#pragma pack(push, 1)
class /*VFT*/ CRevival_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CRevival* this, CPlayer*, CPlayer*);
};
#pragma pack(pop)

/* 788 */
#pragma pack(push, 1)
class /*VFT*/ CResurrection_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CRevival* this, CPlayer*, CPlayer*);
};
#pragma pack(pop)

/* 789 */
#pragma pack(push, 1)
class CResurrection : CRevival
{
};
#pragma pack(pop)

/* 790 */
#pragma pack(push, 1)
class /*VFT*/ CReincarnate_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CRevival* this, CPlayer*, CPlayer*);
};
#pragma pack(pop)

/* 791 */
#pragma pack(push, 1)
class CReincarnate : CRevival
{
};
#pragma pack(pop)

/* 792 */
#pragma pack(push, 1)
class /*VFT*/ CUpEvade_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 793 */
#pragma pack(push, 1)
class CUpEvade : CSkill
{
};
#pragma pack(pop)

/* 794 */
#pragma pack(push, 1)
class /*VFT*/ CUpRFEvade_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 795 */
#pragma pack(push, 1)
class CUpRFEvade : CSkill
{
};
#pragma pack(pop)

/* 796 */
#pragma pack(push, 1)
class /*VFT*/ CStoneShield_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 797 */
#pragma pack(push, 1)
class CStoneShield : CSkill
{
};
#pragma pack(pop)

/* 798 */
#pragma pack(push, 1)
class /*VFT*/ CHaste_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 799 */
#pragma pack(push, 1)
class CHaste : CSkill
{
};
#pragma pack(pop)

/* 800 */
#pragma pack(push, 1)
class /*VFT*/ CFrostBlast_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 801 */
#pragma pack(push, 1)
class CFrostBlast : CSkill
{
};
#pragma pack(pop)

/* 803 */
#pragma pack(push, 1)
class /*VFT*/ CHealingParty_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetSkillAddValue)(CHealingParty* this);
	int(__thiscall* GetIncHP)(CHealingParty* this, CPlayer*);
	int(__thiscall* IsPer)(CHealingParty* this);
};
#pragma pack(pop)

/* 804 */
#pragma pack(push, 1)
class /*VFT*/ CHealingPartyPlus_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetSkillAddValue)(CHealingParty* this);
	int(__thiscall* GetIncHP)(CHealingParty* this, CPlayer*);
	int(__thiscall* IsPer)(CHealingParty* this);
};
#pragma pack(pop)

/* 805 */
#pragma pack(push, 1)
class /*VFT*/ CHealingPartyIns_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetSkillAddValue)(CHealingParty* this);
	int(__thiscall* GetIncHP)(CHealingParty* this, CPlayer*);
	int(__thiscall* IsPer)(CHealingParty* this);
};
#pragma pack(pop)

/* 806 */
#pragma pack(push, 1)
class /*VFT*/ CWildAccuracy_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 807 */
#pragma pack(push, 1)
class CWildAccuracy : CSkill
{
};
#pragma pack(pop)

/* 808 */
#pragma pack(push, 1)
class /*VFT*/ CPoisonArrow_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 809 */
#pragma pack(push, 1)
class /*VFT*/ CWildStrength_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 810 */
#pragma pack(push, 1)
class CWildStrength : CSkill
{
};
#pragma pack(pop)

/* 811 */
#pragma pack(push, 1)
class /*VFT*/ CProtect_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 812 */
#pragma pack(push, 1)
class /*VFT*/ CShieldSmash_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 813 */
#pragma pack(push, 1)
class CShieldSmash : CSkill
{
};
#pragma pack(pop)

/* 814 */
#pragma pack(push, 1)
class /*VFT*/ CSilenceArrow_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 815 */
#pragma pack(push, 1)
class /*VFT*/ CProtectRange_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 816 */
#pragma pack(push, 1)
class CProtectRange : CSkill
{
};
#pragma pack(pop)

/* 817 */
#pragma pack(push, 1)
class /*VFT*/ CUpReinforceVitality_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 818 */
#pragma pack(push, 1)
class CUpReinforceVitality : CSkill
{
};
#pragma pack(pop)

/* 819 */
#pragma pack(push, 1)
class /*VFT*/ CUpAttackRange_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 820 */
#pragma pack(push, 1)
class CUpAttackRange : CSkill
{
};
#pragma pack(pop)

/* 821 */
#pragma pack(push, 1)
class /*VFT*/ CVitalityDrain_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 822 */
#pragma pack(push, 1)
class CVitalityDrain : CSkill
{
};
#pragma pack(pop)

/* 823 */
#pragma pack(push, 1)
class /*VFT*/ CSuffering_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 824 */
#pragma pack(push, 1)
class CSuffering : CSkill
{
};
#pragma pack(pop)

/* 825 */
#pragma pack(push, 1)
class /*VFT*/ CRainforceDefense_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 826 */
#pragma pack(push, 1)
class CRainforceDefense : CSkill
{
};
#pragma pack(pop)

/* 827 */
#pragma pack(push, 1)
class /*VFT*/ CInchantWeapon_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 828 */
#pragma pack(push, 1)
class CInchantWeapon : CSkill
{
};
#pragma pack(pop)

/* 829 */
#pragma pack(push, 1)
class /*VFT*/ CAuraDefense_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 830 */
#pragma pack(push, 1)
class CAuraDefense : CSkill
{
};
#pragma pack(pop)

/* 831 */
#pragma pack(push, 1)
class /*VFT*/ CDash_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 832 */
#pragma pack(push, 1)
class /*VFT*/ CMeshSpeed_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 833 */
#pragma pack(push, 1)
class /*VFT*/ CDarknessVision_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 834 */
#pragma pack(push, 1)
class /*VFT*/ CPurge_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 835 */
#pragma pack(push, 1)
class CPurge : CSkill
{
};
#pragma pack(pop)

/* 836 */
#pragma pack(push, 1)
class /*VFT*/ CReinforceSight_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 837 */
#pragma pack(push, 1)
class CReinforceSight : CSkill
{
};
#pragma pack(pop)

/* 838 */
#pragma pack(push, 1)
class /*VFT*/ CControlAppetite_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 839 */
#pragma pack(push, 1)
class CControlAppetite : CSkill
{
};
#pragma pack(pop)

/* 840 */
#pragma pack(push, 1)
class /*VFT*/ CAmnesia_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 841 */
#pragma pack(push, 1)
class /*VFT*/ CSacrifice_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 842 */
#pragma pack(push, 1)
class /*VFT*/ CChangeVitality_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 843 */
#pragma pack(push, 1)
class CChangeVitality : CSkill
{
};
#pragma pack(pop)

/* 844 */
#pragma pack(push, 1)
class /*VFT*/ CShieldResilience_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 845 */
#pragma pack(push, 1)
class CShieldResilience : CSkill
{
};
#pragma pack(pop)

/* 846 */
#pragma pack(push, 1)
class /*VFT*/ CSilenceShot_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 847 */
#pragma pack(push, 1)
class CSilenceShot : CSkill
{
};
#pragma pack(pop)

/* 849 */
#pragma pack(push, 1)
class /*VFT*/ CSkillBuff_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillBuff* this, CPlayer*, CChar*, int*);
	void(__thiscall* ApplyM)(CSkillBuff* this, CChar*, CChar*);
	int(__thiscall* IsDeBuff)(CSkillBuff* this);
};
#pragma pack(pop)

/* 850 */
#pragma pack(push, 1)
class /*VFT*/ CStrenUpStr_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillBuff* this, CPlayer*, CChar*, int*);
	void(__thiscall* ApplyM)(CSkillBuff* this, CChar*, CChar*);
	int(__thiscall* IsDeBuff)(CSkillBuff* this);
};
#pragma pack(pop)

/* 851 */
#pragma pack(push, 1)
class CStrenUpStr : CSkillBuff
{
};
#pragma pack(pop)

/* 852 */
#pragma pack(push, 1)
class /*VFT*/ CStrenUpHth_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillBuff* this, CPlayer*, CChar*, int*);
	void(__thiscall* ApplyM)(CSkillBuff* this, CChar*, CChar*);
	int(__thiscall* IsDeBuff)(CSkillBuff* this);
};
#pragma pack(pop)

/* 853 */
#pragma pack(push, 1)
class CStrenUpHth : CSkillBuff
{
};
#pragma pack(pop)

/* 854 */
#pragma pack(push, 1)
class /*VFT*/ CStrenUpDex_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillBuff* this, CPlayer*, CChar*, int*);
	void(__thiscall* ApplyM)(CSkillBuff* this, CChar*, CChar*);
	int(__thiscall* IsDeBuff)(CSkillBuff* this);
};
#pragma pack(pop)

/* 855 */
#pragma pack(push, 1)
class CStrenUpDex : CSkillBuff
{
};
#pragma pack(pop)

/* 856 */
#pragma pack(push, 1)
class /*VFT*/ CStrenUpInt_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillBuff* this, CPlayer*, CChar*, int*);
	void(__thiscall* ApplyM)(CSkillBuff* this, CChar*, CChar*);
	int(__thiscall* IsDeBuff)(CSkillBuff* this);
};
#pragma pack(pop)

/* 857 */
#pragma pack(push, 1)
class CStrenUpInt : CSkillBuff
{
};
#pragma pack(pop)

/* 858 */
#pragma pack(push, 1)
class /*VFT*/ CStrenUpFatal_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillBuff* this, CPlayer*, CChar*, int*);
	void(__thiscall* ApplyM)(CSkillBuff* this, CChar*, CChar*);
	int(__thiscall* IsDeBuff)(CSkillBuff* this);
};
#pragma pack(pop)

/* 859 */
#pragma pack(push, 1)
class CStrenUpFatal : CSkillBuff
{
};
#pragma pack(pop)

/* 860 */
#pragma pack(push, 1)
class /*VFT*/ CCloudSight_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillBuff* this, CPlayer*, CChar*, int*);
	void(__thiscall* ApplyM)(CSkillBuff* this, CChar*, CChar*);
	int(__thiscall* IsDeBuff)(CSkillBuff* this);
};
#pragma pack(pop)

/* 861 */
#pragma pack(push, 1)
class CCloudSight : CSkillBuff
{
};
#pragma pack(pop)

/* 862 */
#pragma pack(push, 1)
class /*VFT*/ CManaBurn_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillBuff* this, CPlayer*, CChar*, int*);
	void(__thiscall* ApplyM)(CSkillBuff* this, CChar*, CChar*);
	int(__thiscall* IsDeBuff)(CSkillBuff* this);
};
#pragma pack(pop)

/* 863 */
#pragma pack(push, 1)
class CManaBurn : CSkillBuff
{
};
#pragma pack(pop)

/* 864 */
#pragma pack(push, 1)
class /*VFT*/ CMeshChance_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillBuff* this, CPlayer*, CChar*, int*);
	void(__thiscall* ApplyM)(CSkillBuff* this, CChar*, CChar*);
	int(__thiscall* IsDeBuff)(CSkillBuff* this);
};
#pragma pack(pop)

/* 865 */
#pragma pack(push, 1)
class CMeshChance : CSkillBuff
{
};
#pragma pack(pop)

/* 866 */
#pragma pack(push, 1)
class /*VFT*/ CMeshStr_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillBuff* this, CPlayer*, CChar*, int*);
	void(__thiscall* ApplyM)(CSkillBuff* this, CChar*, CChar*);
	int(__thiscall* IsDeBuff)(CSkillBuff* this);
};
#pragma pack(pop)

/* 867 */
#pragma pack(push, 1)
class /*VFT*/ CMeshHth_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillBuff* this, CPlayer*, CChar*, int*);
	void(__thiscall* ApplyM)(CSkillBuff* this, CChar*, CChar*);
	int(__thiscall* IsDeBuff)(CSkillBuff* this);
};
#pragma pack(pop)

/* 868 */
#pragma pack(push, 1)
class CMeshHth : CSkillBuff
{
};
#pragma pack(pop)

/* 869 */
#pragma pack(push, 1)
class /*VFT*/ CMeshDex_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillBuff* this, CPlayer*, CChar*, int*);
	void(__thiscall* ApplyM)(CSkillBuff* this, CChar*, CChar*);
	int(__thiscall* IsDeBuff)(CSkillBuff* this);
};
#pragma pack(pop)

/* 870 */
#pragma pack(push, 1)
class CMeshDex : CSkillBuff
{
};
#pragma pack(pop)

/* 871 */
#pragma pack(push, 1)
class /*VFT*/ CMeshInt_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillBuff* this, CPlayer*, CChar*, int*);
	void(__thiscall* ApplyM)(CSkillBuff* this, CChar*, CChar*);
	int(__thiscall* IsDeBuff)(CSkillBuff* this);
};
#pragma pack(pop)

/* 872 */
#pragma pack(push, 1)
class CMeshInt : CSkillBuff
{
};
#pragma pack(pop)

/* 873 */
#pragma pack(push, 1)
class /*VFT*/ CMeshWis_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillBuff* this, CPlayer*, CChar*, int*);
	void(__thiscall* ApplyM)(CSkillBuff* this, CChar*, CChar*);
	int(__thiscall* IsDeBuff)(CSkillBuff* this);
};
#pragma pack(pop)

/* 874 */
#pragma pack(push, 1)
class CMeshWis : CSkillBuff
{
};
#pragma pack(pop)

/* 875 */
#pragma pack(push, 1)
class /*VFT*/ CMeshDefense_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillBuff* this, CPlayer*, CChar*, int*);
	void(__thiscall* ApplyM)(CSkillBuff* this, CChar*, CChar*);
	int(__thiscall* IsDeBuff)(CSkillBuff* this);
};
#pragma pack(pop)

/* 876 */
#pragma pack(push, 1)
class /*VFT*/ CVanishConfi_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillBuff* this, CPlayer*, CChar*, int*);
	void(__thiscall* ApplyM)(CSkillBuff* this, CChar*, CChar*);
	int(__thiscall* IsDeBuff)(CSkillBuff* this);
};
#pragma pack(pop)

/* 877 */
#pragma pack(push, 1)
class /*VFT*/ CDestroySight_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillBuff* this, CPlayer*, CChar*, int*);
	void(__thiscall* ApplyM)(CSkillBuff* this, CChar*, CChar*);
	int(__thiscall* IsDeBuff)(CSkillBuff* this);
};
#pragma pack(pop)

/* 878 */
#pragma pack(push, 1)
class /*VFT*/ CBenefitAblation_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillBuff* this, CPlayer*, CChar*, int*);
	void(__thiscall* ApplyM)(CSkillBuff* this, CChar*, CChar*);
	int(__thiscall* IsDeBuff)(CSkillBuff* this);
};
#pragma pack(pop)

/* 879 */
#pragma pack(push, 1)
class CBenefitAblation : CSkillBuff
{
};
#pragma pack(pop)

/* 880 */
#pragma pack(push, 1)
class CSkillSelfBuff : CSkill
{
};
#pragma pack(pop)

/* 881 */
#pragma pack(push, 1)
class /*VFT*/ CSkillSelfBuff_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillSelfBuff* this, CPlayer*);
};
#pragma pack(pop)

/* 882 */
#pragma pack(push, 1)
class /*VFT*/ CBerserk_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillSelfBuff* this, CPlayer*);
};
#pragma pack(pop)

/* 883 */
#pragma pack(push, 1)
class CBerserk : CSkillSelfBuff
{
};
#pragma pack(pop)

/* 884 */
#pragma pack(push, 1)
class /*VFT*/ CResistLightning_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillSelfBuff* this, CPlayer*);
};
#pragma pack(pop)

/* 885 */
#pragma pack(push, 1)
class CResistLightning : CSkillSelfBuff
{
};
#pragma pack(pop)

/* 886 */
#pragma pack(push, 1)
class /*VFT*/ CResistIce_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillSelfBuff* this, CPlayer*);
};
#pragma pack(pop)

/* 887 */
#pragma pack(push, 1)
class CResistIce : CSkillSelfBuff
{
};
#pragma pack(pop)

/* 888 */
#pragma pack(push, 1)
class /*VFT*/ CResistFire_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillSelfBuff* this, CPlayer*);
};
#pragma pack(pop)

/* 889 */
#pragma pack(push, 1)
class CResistFire : CSkillSelfBuff
{
};
#pragma pack(pop)

/* 890 */
#pragma pack(push, 1)
class /*VFT*/ CResistCurse_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillSelfBuff* this, CPlayer*);
};
#pragma pack(pop)

/* 891 */
#pragma pack(push, 1)
class CResistCurse : CSkillSelfBuff
{
};
#pragma pack(pop)

/* 892 */
#pragma pack(push, 1)
class /*VFT*/ CResistPalsy_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillSelfBuff* this, CPlayer*);
};
#pragma pack(pop)

/* 893 */
#pragma pack(push, 1)
class CResistPalsy : CSkillSelfBuff
{
};
#pragma pack(pop)

/* 894 */
#pragma pack(push, 1)
class /*VFT*/ CEmergencyEscape_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillSelfBuff* this, CPlayer*);
};
#pragma pack(pop)

/* 895 */
#pragma pack(push, 1)
class CEmergencyEscape : CSkillSelfBuff
{
};
#pragma pack(pop)

/* 897 */
#pragma pack(push, 1)
class /*VFT*/ CChant_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	CBuff* (__thiscall* CreateBuff)(CChant* this, CPlayer*);
};
#pragma pack(pop)

/* 898 */
#pragma pack(push, 1)
class /*VFT*/ CChantProtect_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	CBuff* (__thiscall* CreateBuff)(CChant* this, CPlayer*);
};
#pragma pack(pop)

/* 899 */
#pragma pack(push, 1)
class CChantProtect : CChant
{
};
#pragma pack(pop)

/* 900 */
#pragma pack(push, 1)
class /*VFT*/ CChantHealing_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	CBuff* (__thiscall* CreateBuff)(CChant* this, CPlayer*);
};
#pragma pack(pop)

/* 901 */
#pragma pack(push, 1)
class /*VFT*/ CChantDefLightning_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	CBuff* (__thiscall* CreateBuff)(CChant* this, CPlayer*);
};
#pragma pack(pop)

/* 902 */
#pragma pack(push, 1)
class CChantDefLightning : CChant
{
};
#pragma pack(pop)

/* 903 */
#pragma pack(push, 1)
class /*VFT*/ CChantDefIce_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	CBuff* (__thiscall* CreateBuff)(CChant* this, CPlayer*);
};
#pragma pack(pop)

/* 904 */
#pragma pack(push, 1)
class CChantDefIce : CChant
{
};
#pragma pack(pop)

/* 905 */
#pragma pack(push, 1)
class /*VFT*/ CChantDefFire_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	CBuff* (__thiscall* CreateBuff)(CChant* this, CPlayer*);
};
#pragma pack(pop)

/* 906 */
#pragma pack(push, 1)
class CChantDefFire : CChant
{
};
#pragma pack(pop)

/* 907 */
#pragma pack(push, 1)
class /*VFT*/ CChantAccuracy_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	CBuff* (__thiscall* CreateBuff)(CChant* this, CPlayer*);
};
#pragma pack(pop)

/* 908 */
#pragma pack(push, 1)
class CChantAccuracy : CChant
{
};
#pragma pack(pop)

/* 909 */
#pragma pack(push, 1)
class /*VFT*/ CChantBattle_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	CBuff* (__thiscall* CreateBuff)(CChant* this, CPlayer*);
};
#pragma pack(pop)

/* 910 */
#pragma pack(push, 1)
class CChantBattle : CChant
{
};
#pragma pack(pop)

/* 911 */
#pragma pack(push, 1)
class /*VFT*/ CTLitningBlast_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
};
#pragma pack(pop)

/* 912 */
#pragma pack(push, 1)
class CTLitningBlast : CMagic
{
};
#pragma pack(pop)

/* 913 */
#pragma pack(push, 1)
class /*VFT*/ CTTempest_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 914 */
#pragma pack(push, 1)
class CTTempest : CMagicWideSelf
{
};
#pragma pack(pop)

/* 915 */
#pragma pack(push, 1)
class /*VFT*/ CTPhoenix_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 916 */
#pragma pack(push, 1)
class CTPhoenix : CSkill
{
};
#pragma pack(pop)

/* 917 */
#pragma pack(push, 1)
class /*VFT*/ CTFatalBlow_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* Apply)(CBlow* this, CPlayer*, CChar*, unsigned int, int*, int*, int*);
	int(__thiscall* GetHit)(CBlow* this);
	void(__thiscall* AddMortal)(CBlow* this, CPlayer*);
};
#pragma pack(pop)

/* 918 */
#pragma pack(push, 1)
class CTFatalBlow : CBlow
{
};
#pragma pack(pop)

/* 919 */
#pragma pack(push, 1)
class /*VFT*/ CTDemolition_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* Apply)(CBlow* this, CPlayer*, CChar*, unsigned int, int*, int*, int*);
	int(__thiscall* GetHit)(CBlow* this);
	void(__thiscall* AddMortal)(CBlow* this, CPlayer*);
};
#pragma pack(pop)

/* 920 */
#pragma pack(push, 1)
class CTDemolition : CBlow
{
};
#pragma pack(pop)

/* 921 */
#pragma pack(push, 1)
class /*VFT*/ CTFury_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 922 */
#pragma pack(push, 1)
class CTFury : CSkill
{
};
#pragma pack(pop)

/* 923 */
#pragma pack(push, 1)
class /*VFT*/ CTGroundSplinter_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* Apply)(CBlow* this, CPlayer*, CChar*, unsigned int, int*, int*, int*);
	int(__thiscall* GetHit)(CBlow* this);
	void(__thiscall* AddMortal)(CBlow* this, CPlayer*);
};
#pragma pack(pop)

/* 924 */
#pragma pack(push, 1)
class /*VFT*/ CTShadowFang_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 925 */
#pragma pack(push, 1)
class CTShadowFang : CSkill
{
};
#pragma pack(pop)

/* 926 */
#pragma pack(push, 1)
class /*VFT*/ CTDiamondClow_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 927 */
#pragma pack(push, 1)
class CTDiamondClow : CSkill
{
};
#pragma pack(pop)

/* 928 */
#pragma pack(push, 1)
class /*VFT*/ CDoRage_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 929 */
#pragma pack(push, 1)
class CDoRage : CMagicWideSelf
{
};
#pragma pack(pop)

/* 930 */
#pragma pack(push, 1)
class /*VFT*/ CDoFury_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 931 */
#pragma pack(push, 1)
class CDoFury : CMagicWideSelf
{
};
#pragma pack(pop)

/* 932 */
#pragma pack(push, 1)
class /*VFT*/ CDoGroundFeal_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 933 */
#pragma pack(push, 1)
class CDoGroundFeal : CMagicWideSelf
{
};
#pragma pack(pop)

/* 934 */
#pragma pack(push, 1)
class /*VFT*/ CDoAscension_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 935 */
#pragma pack(push, 1)
class /*VFT*/ CSummon_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 936 */
#pragma pack(push, 1)
class CSummon : CSkill
{
};
#pragma pack(pop)

/* 937 */
#pragma pack(push, 1)
class /*VFT*/ CDoTele_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 938 */
#pragma pack(push, 1)
class /*VFT*/ CDoSpiritAbsorb_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 939 */
#pragma pack(push, 1)
class CDoSpiritAbsorb : CSkill
{
};
#pragma pack(pop)

/* 940 */
#pragma pack(push, 1)
class /*VFT*/ CDoAbsorb_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillBuff* this, CPlayer*, CChar*, int*);
	void(__thiscall* ApplyM)(CSkillBuff* this, CChar*, CChar*);
	int(__thiscall* IsDeBuff)(CSkillBuff* this);
};
#pragma pack(pop)

/* 941 */
#pragma pack(push, 1)
class CDoAbsorb : CSkillBuff
{
};
#pragma pack(pop)

/* 942 */
#pragma pack(push, 1)
class /*VFT*/ CDoResistAll_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	void(__thiscall* Apply)(CSkillBuff* this, CPlayer*, CChar*, int*);
	void(__thiscall* ApplyM)(CSkillBuff* this, CChar*, CChar*);
	int(__thiscall* IsDeBuff)(CSkillBuff* this);
};
#pragma pack(pop)

/* 943 */
#pragma pack(push, 1)
class CDoResistAll : CSkillBuff
{
};
#pragma pack(pop)

/* 944 */
#pragma pack(push, 1)
class /*VFT*/ CDoOverrun_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 945 */
#pragma pack(push, 1)
class CDoOverrun : CMagicWide
{
};
#pragma pack(pop)

/* 946 */
#pragma pack(push, 1)
class /*VFT*/ CSkill_MonsterMagic_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 947 */
#pragma pack(push, 1)
class CSkill_MonsterMagic : CMagicWideSelf
{
};
#pragma pack(pop)

/* 948 */
#pragma pack(push, 1)
class /*VFT*/ CMThunderStorm_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 949 */
#pragma pack(push, 1)
class CMThunderStorm : CSkill_MonsterMagic
{
};
#pragma pack(pop)

/* 950 */
#pragma pack(push, 1)
class /*VFT*/ CMIceStorm_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 951 */
#pragma pack(push, 1)
class CMIceStorm : CSkill_MonsterMagic
{
};
#pragma pack(pop)

/* 952 */
#pragma pack(push, 1)
class /*VFT*/ CMFireRain_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 953 */
#pragma pack(push, 1)
class CMFireRain : CSkill_MonsterMagic
{
};
#pragma pack(pop)

/* 954 */
#pragma pack(push, 1)
class /*VFT*/ CMPoisonCloud_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 955 */
#pragma pack(push, 1)
class CMPoisonCloud : CSkill_MonsterMagic
{
};
#pragma pack(pop)

/* 956 */
#pragma pack(push, 1)
class /*VFT*/ CHatchingLarva_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 957 */
#pragma pack(push, 1)
class CHatchingLarva : CSkill
{
};
#pragma pack(pop)

/* 958 */
#pragma pack(push, 1)
class /*VFT*/ CEggSummon_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 959 */
#pragma pack(push, 1)
class CEggSummon : CSkill
{
};
#pragma pack(pop)

/* 960 */
#pragma pack(push, 1)
class /*VFT*/ CPerfectDeath_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 961 */
#pragma pack(push, 1)
class CPerfectDeath : CSkill
{
};
#pragma pack(pop)

/* 962 */
#pragma pack(push, 1)
class /*VFT*/ CSwing1_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 963 */
#pragma pack(push, 1)
class CSwing1 : CMagicWideSelf
{
};
#pragma pack(pop)

/* 964 */
#pragma pack(push, 1)
class /*VFT*/ CSwing2_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 965 */
#pragma pack(push, 1)
class CSwing2 : CMagicWideSelf
{
};
#pragma pack(pop)

/* 966 */
#pragma pack(push, 1)
class /*VFT*/ CGroundFeal2_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 967 */
#pragma pack(push, 1)
class CGroundFeal2 : CDoGroundFeal
{
};
#pragma pack(pop)

/* 968 */
#pragma pack(push, 1)
class /*VFT*/ CFlamePlantSummon_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 969 */
#pragma pack(push, 1)
class CFlamePlantSummon : CSkill
{
};
#pragma pack(pop)

/* 970 */
#pragma pack(push, 1)
class /*VFT*/ CHydrochloricAcid_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
};
#pragma pack(pop)

/* 971 */
#pragma pack(push, 1)
class CHydrochloricAcid : CMagic
{
};
#pragma pack(pop)

/* 972 */
#pragma pack(push, 1)
class /*VFT*/ CCompleteFire_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 973 */
#pragma pack(push, 1)
class CCompleteFire : CMagicWide
{
};
#pragma pack(pop)

/* 974 */
#pragma pack(push, 1)
class /*VFT*/ CShootingFire_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 975 */
#pragma pack(push, 1)
class CPurgatorialFlame : CMagicConti
{
};
#pragma pack(pop)

/* 976 */
#pragma pack(push, 1)
class /*VFT*/ CPurgatorialFlame_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	void(__thiscall* ExcuteM)(CMagicConti* this, CMonster*, tagPOINT);
	int(__thiscall* GetRadiusTile)(CMagicConti* this);
	int(__thiscall* AddMagicMonster)(CMagicConti* this, CPlayer*, tagPOINT);
	int(__thiscall* AddMagicMonsterM)(CMagicConti* this, CMonster*, tagPOINT);
	int(__thiscall* AddMagicMonster)(CPurgatorialFlame* this, CMonster*, tagPOINT);
};
#pragma pack(pop)

/* 977 */
#pragma pack(push, 1)
class /*VFT*/ CDeclassionFlame_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
};
#pragma pack(pop)

/* 978 */
#pragma pack(push, 1)
class CDeclassionFlame : CMagic
{
};
#pragma pack(pop)

/* 979 */
#pragma pack(push, 1)
class /*VFT*/ CDemonBeastSummon_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 980 */
#pragma pack(push, 1)
class CDemonBeastSummon : CSkill
{
};
#pragma pack(pop)

/* 981 */
#pragma pack(push, 1)
class /*VFT*/ CMLitning_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
};
#pragma pack(pop)

/* 983 */
#pragma pack(push, 1)
class CMSpark : CMLitning
{
};
#pragma pack(pop)

/* 984 */
#pragma pack(push, 1)
class /*VFT*/ CMSpark_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetSpendMP)(CMSpark* this, CMonster*);
};
#pragma pack(pop)

/* 985 */
#pragma pack(push, 1)
class /*VFT*/ CMFire_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
};
#pragma pack(pop)

/* 986 */
#pragma pack(push, 1)
class CMFire : CMagic
{
};
#pragma pack(pop)

/* 987 */
#pragma pack(push, 1)
class /*VFT*/ CMShock_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetSpendMP)(CMShock* this, CMonster*);
};
#pragma pack(pop)

/* 988 */
#pragma pack(push, 1)
class /*VFT*/ CMMagicWideFire_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 989 */
#pragma pack(push, 1)
class CMMagicWideFire : CMagicWide
{
};
#pragma pack(pop)

/* 990 */
#pragma pack(push, 1)
class /*VFT*/ CMPurgatorialFlame_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 991 */
#pragma pack(push, 1)
class CMPurgatorialFlame : CMFireRain
{
};
#pragma pack(pop)

/* 992 */
#pragma pack(push, 1)
class /*VFT*/ CMFireFlowerExplosion_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 993 */
#pragma pack(push, 1)
class CMFireFlowerExplosion : CMagicWideSelf
{
};
#pragma pack(pop)

/* 994 */
#pragma pack(push, 1)
class /*VFT*/ CMSiegeGunFire_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 995 */
#pragma pack(push, 1)
class CMSiegeGunFire : CSkill
{
};
#pragma pack(pop)

/* 996 */
#pragma pack(push, 1)
class /*VFT*/ CMSiegeGunBallExplosion_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* GetResistNum)(CMagic* this);
	void(__thiscall* Apply)(CMagic* this, CPlayer*, CChar*, unsigned int, int, int);
	int(__thiscall* GetMagicM)(CMagic* this, CMonster*);
	int(__thiscall* GetRadiusTile)(CMagicWide* this);
	int(__thiscall* GetAddValueType)(CMagicWide* this);
	int(__thiscall* IsDamage)(CMagicWide* this);
	void(__thiscall* ApplyM)(CMagicWide* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 997 */
#pragma pack(push, 1)
class /*VFT*/ CSpecPrty_vtbl
{
	void(__thiscall* ApplySpec)(CSpec* this, CPlayer*);
	void(__thiscall* FreeSpec)(CSpec* this, CPlayer*);
	int(__thiscall* Use)(CSpec* this, CPlayer*);
	int(__thiscall* Enchant)(CSpec* this, CPlayer*, CItem*);
};
#pragma pack(pop)

/* 998 */
#pragma pack(push, 1)
class CSpecPrty : CSpec
{
	int m_bPt;
	int m_nPrtyType;
};
#pragma pack(pop)

/* 999 */
#pragma pack(push, 1)
class /*VFT*/ CSpecGState_vtbl
{
	void(__thiscall* ApplySpec)(CSpec* this, CPlayer*);
	void(__thiscall* FreeSpec)(CSpec* this, CPlayer*);
	int(__thiscall* Use)(CSpec* this, CPlayer*);
	int(__thiscall* Enchant)(CSpec* this, CPlayer*, CItem*);
};
#pragma pack(pop)

/* 1000 */
#pragma pack(push, 1)
class CSpecGState : CSpec
{
};
#pragma pack(pop)

/* 1001 */
#pragma pack(push, 1)
class /*VFT*/ CSpecTeleport_vtbl
{
	void(__thiscall* ApplySpec)(CSpec* this, CPlayer*);
	void(__thiscall* FreeSpec)(CSpec* this, CPlayer*);
	int(__thiscall* Use)(CSpec* this, CPlayer*);
	int(__thiscall* Enchant)(CSpec* this, CPlayer*, CItem*);
};
#pragma pack(pop)

/* 1002 */
#pragma pack(push, 1)
class CSpecTeleport : CSpec
{
};
#pragma pack(pop)

/* 1003 */
#pragma pack(push, 1)
class /*VFT*/ CSpecRefresh_vtbl
{
	void(__thiscall* ApplySpec)(CSpec* this, CPlayer*);
	void(__thiscall* FreeSpec)(CSpec* this, CPlayer*);
	int(__thiscall* Use)(CSpec* this, CPlayer*);
	int(__thiscall* Enchant)(CSpec* this, CPlayer*, CItem*);
};
#pragma pack(pop)

/* 1004 */
#pragma pack(push, 1)
class CSpecRefresh : CSpec
{
};
#pragma pack(pop)

/* 1005 */
#pragma pack(push, 1)
class /*VFT*/ CSpecCharming_vtbl
{
	void(__thiscall* ApplySpec)(CSpec* this, CPlayer*);
	void(__thiscall* FreeSpec)(CSpec* this, CPlayer*);
	int(__thiscall* Use)(CSpec* this, CPlayer*);
	int(__thiscall* Enchant)(CSpec* this, CPlayer*, CItem*);
};
#pragma pack(pop)

/* 1006 */
#pragma pack(push, 1)
class CSpecCharming : CSpec
{
};
#pragma pack(pop)

/* 1007 */
#pragma pack(push, 1)
class /*VFT*/ CSpecRepair_vtbl
{
	void(__thiscall* ApplySpec)(CSpec* this, CPlayer*);
	void(__thiscall* FreeSpec)(CSpec* this, CPlayer*);
	int(__thiscall* Use)(CSpec* this, CPlayer*);
	int(__thiscall* Enchant)(CSpec* this, CPlayer*, CItem*);
};
#pragma pack(pop)

/* 1008 */
#pragma pack(push, 1)
class CSpecRepair : CSpec
{
};
#pragma pack(pop)

/* 1009 */
#pragma pack(push, 1)
class /*VFT*/ CSpecChangePrefix_vtbl
{
	void(__thiscall* ApplySpec)(CSpec* this, CPlayer*);
	void(__thiscall* FreeSpec)(CSpec* this, CPlayer*);
	int(__thiscall* Use)(CSpec* this, CPlayer*);
	int(__thiscall* Enchant)(CSpec* this, CPlayer*, CItem*);
};
#pragma pack(pop)

/* 1010 */
#pragma pack(push, 1)
class CSpecChangePrefix : CSpec
{
	int m_nRate[2];
	int m_nPrefix[2];
};
#pragma pack(pop)

/* 1011 */
#pragma pack(push, 1)
class /*VFT*/ CSpecProtect_vtbl
{
	void(__thiscall* ApplySpec)(CSpec* this, CPlayer*);
	void(__thiscall* FreeSpec)(CSpec* this, CPlayer*);
	int(__thiscall* Use)(CSpec* this, CPlayer*);
	int(__thiscall* Enchant)(CSpec* this, CPlayer*, CItem*);
};
#pragma pack(pop)

/* 1012 */
#pragma pack(push, 1)
class CSpecProtect : CSpec
{
};
#pragma pack(pop)

/* 1013 */
#pragma pack(push, 1)
class /*VFT*/ CSpecBuff_vtbl
{
	void(__thiscall* ApplySpec)(CSpec* this, CPlayer*);
	void(__thiscall* FreeSpec)(CSpec* this, CPlayer*);
	int(__thiscall* Use)(CSpec* this, CPlayer*);
	int(__thiscall* Enchant)(CSpec* this, CPlayer*, CItem*);
};
#pragma pack(pop)

/* 1014 */
#pragma pack(push, 1)
class CSpecBuff : CSpec
{
	unsigned int m_dwTime;
	int m_nAmount;
};
#pragma pack(pop)

/* 1015 */
#pragma pack(push, 1)
class /*VFT*/ CSpecRevival_vtbl
{
	void(__thiscall* ApplySpec)(CSpec* this, CPlayer*);
	void(__thiscall* FreeSpec)(CSpec* this, CPlayer*);
	int(__thiscall* Use)(CSpec* this, CPlayer*);
	int(__thiscall* Enchant)(CSpec* this, CPlayer*, CItem*);
};
#pragma pack(pop)

/* 1016 */
#pragma pack(push, 1)
class CSpecRevival : CSpec
{
};
#pragma pack(pop)

/* 1017 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<enum Symbol const, CSpec*>, int, std::pair<enum Symbol const, CSpec*> const*, std::pair<enum Symbol const, CSpec*> const&>
{
};
#pragma pack(pop)

/* 1018 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<enum Symbol const, CSpec*>, int, std::pair<enum Symbol const, CSpec*> const*, std::pair<enum Symbol const, CSpec*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<enum Symbol const, CSpec*>, int, std::pair<enum Symbol const, CSpec*> const*, std::pair<enum Symbol const, CSpec*> const&>
{
};
#pragma pack(pop)

/* 1019 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >::const_iterator : std::_Bidit<std::pair<enum Symbol const, CSpec*>, int, std::pair<enum Symbol const, CSpec*> const*, std::pair<enum Symbol const, CSpec*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 1020 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 1021 */
#pragma pack(push, 1)
class std::allocator<std::pair<enum Symbol const, CSpec*> >::rebind<std::pair<enum Symbol const, CSpec*> >
{
};
#pragma pack(pop)

/* 1022 */
#pragma pack(push, 1)
class std::allocator<std::pair<enum Symbol const, CSpec*> >::rebind<std::_Tree_nod<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 1023 */
#pragma pack(push, 1)
class std::allocator<std::pair<enum Symbol const, CSpec*> >::rebind<std::_Tree_nod<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 1024 */
#pragma pack(push, 1)
class std::allocator<std::pair<enum Symbol const, CSpec*> >::rebind<enum Symbol>
{
};
#pragma pack(pop)

/* 1025 */
#pragma pack(push, 1)
class std::allocator<std::pair<enum Symbol const, CSpec*> >::rebind<char>
{
};
#pragma pack(pop)

/* 1026 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<enum Symbol, CSpec*, std::less<enum Symbol>, std::allocator<std::pair<enum Symbol const, CSpec*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 1027 */
#pragma pack(push, 1)
class std::_Allocator_base<enum Symbol>
{
};
#pragma pack(pop)

/* 1028 */
#pragma pack(push, 1)
class std::allocator<enum Symbol> : std::_Allocator_base<enum Symbol>
{
};
#pragma pack(pop)

/* 1029 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CInitItem*>, int, std::pair<int const, CInitItem*> const*, std::pair<int const, CInitItem*> const&>
{
};
#pragma pack(pop)

/* 1030 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, CInitItem*>, int, std::pair<int const, CInitItem*> const*, std::pair<int const, CInitItem*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CInitItem*>, int, std::pair<int const, CInitItem*> const*, std::pair<int const, CInitItem*> const&>
{
};
#pragma pack(pop)

/* 1031 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, CInitItem*>, int, std::pair<int const, CInitItem*> const*, std::pair<int const, CInitItem*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 1032 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 1033 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CPrefix*>, int, std::pair<int const, CPrefix*> const*, std::pair<int const, CPrefix*> const&>
{
};
#pragma pack(pop)

/* 1034 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, CPrefix*>, int, std::pair<int const, CPrefix*> const*, std::pair<int const, CPrefix*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CPrefix*>, int, std::pair<int const, CPrefix*> const*, std::pair<int const, CPrefix*> const&>
{
};
#pragma pack(pop)

/* 1035 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, CPrefix*>, int, std::pair<int const, CPrefix*> const*, std::pair<int const, CPrefix*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 1036 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 1037 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CItemGroup*>, int, std::pair<int const, CItemGroup*> const*, std::pair<int const, CItemGroup*> const&>
{
};
#pragma pack(pop)

/* 1038 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, CItemGroup*>, int, std::pair<int const, CItemGroup*> const*, std::pair<int const, CItemGroup*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CItemGroup*>, int, std::pair<int const, CItemGroup*> const*, std::pair<int const, CItemGroup*> const&>
{
};
#pragma pack(pop)

/* 1039 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, CItemGroup*>, int, std::pair<int const, CItemGroup*> const*, std::pair<int const, CItemGroup*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 1040 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 1041 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CInitItem*> >::rebind<std::pair<int const, CInitItem*> >
{
};
#pragma pack(pop)

/* 1042 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CInitItem*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 1043 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CInitItem*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 1044 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CInitItem*> >::rebind<int>
{
};
#pragma pack(pop)

/* 1045 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CInitItem*> >::rebind<char>
{
};
#pragma pack(pop)

/* 1046 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, CInitItem*, std::less<int>, std::allocator<std::pair<int const, CInitItem*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 1047 */
#pragma pack(push, 1)
class std::_Allocator_base<int>
{
};
#pragma pack(pop)

/* 1048 */
#pragma pack(push, 1)
class std::allocator<int> : std::_Allocator_base<int>
{
};
#pragma pack(pop)

/* 1049 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CPrefix*> >::rebind<std::pair<int const, CPrefix*> >
{
};
#pragma pack(pop)

/* 1050 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CPrefix*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 1051 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CPrefix*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 1052 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CPrefix*> >::rebind<int>
{
};
#pragma pack(pop)

/* 1053 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CPrefix*> >::rebind<char>
{
};
#pragma pack(pop)

/* 1054 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, CPrefix*, std::less<int>, std::allocator<std::pair<int const, CPrefix*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 1055 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CItemGroup*> >::rebind<std::pair<int const, CItemGroup*> >
{
};
#pragma pack(pop)

/* 1056 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CItemGroup*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 1057 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CItemGroup*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 1058 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CItemGroup*> >::rebind<int>
{
};
#pragma pack(pop)

/* 1059 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CItemGroup*> >::rebind<char>
{
};
#pragma pack(pop)

/* 1060 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, CItemGroup*, std::less<int>, std::allocator<std::pair<int const, CItemGroup*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 1061 */
#pragma pack(push, 1)
class CItemMask : CItemDefense
{
};
#pragma pack(pop)

/* 1062 */
#pragma pack(push, 1)
class /*VFT*/ CItemMask_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	void(__thiscall* PutInfo)(CItem* this, char**, int);
	_BYTE gap4C[4];
	void(__thiscall* Init)(CItem* this, int, char**);
	void(__thiscall* SetWearState)(CItem* this, CPlayer*);
	int(__thiscall* Trash)(CItem* this, CPlayer*, int);
	void(__thiscall* Erase)(CItem* this, int);
	void(__thiscall* PutOn)(CItem* this, CPlayer*);
	void(__thiscall* PutOff)(CItem* this, CPlayer*);
	void(__thiscall* ApplySpec)(CItem* this, CPlayer*);
	void(__thiscall* FreeSpec)(CItem* this, CPlayer*);
	_BYTE gap70[4];
	void(__thiscall* Insert)(CItem* this, int, int);
	int(__thiscall* UpdateNum)(CItem* this, CPlayer*, int, int);
	void(__thiscall* Drop)(CItem* this, CChar*, const tagPOINT*, const tagPOINT*, int, int, int);
	int(__thiscall* Use)(CItem* this, CPlayer*);
	CItem* (__thiscall* Trade)(CItem* this, CPlayer*, int, int);
	int(__thiscall* CanSell)(CItem* this, int);
	int(__thiscall* CanTrade)(CItem* this, int, CPlayer*, CPlayer*);
	int(__thiscall* CanDrop)(CItem* this, int, CPlayer*);
	int(__thiscall* CanMerge)(CItem* this, CItem*);
	int(__thiscall* StorageIn)(CItem* this, CPlayer*, int);
	int(__thiscall* StorageOut)(CItem* this, CPlayer*, int, int, int*);
	void(__thiscall* ForcedStorageIn)(CItem* this, int, int, char*, int);
	int(__thiscall* IsMoney)(CItem* this);
	int(__thiscall* IsBroken)(CItem* this);
	int(__thiscall* Enchant)(CItem* this, CPlayer*, CItem*);
	int(__thiscall* Charming)(CItem* this, CPlayer*, int);
	int(__thiscall* CharmingCheat)(CItem* this, CPlayer*, int, int);
	int(__thiscall* Repair)(CItem* this, CPlayer*);
	int(__thiscall* ChangePrefix)(CItem* this, CPlayer*, int, int*, int*);
	int(__thiscall* Protect)(CItem* this, CPlayer*);
	int(__thiscall* IsQuestItem)(CItem* this);
	int(__thiscall* GetSellMoney)(CItem* this, int);
	void(__thiscall* SetEtc)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeDestroy)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeRateUp)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeLevel)(CItem* this, CPlayer*);
};
#pragma pack(pop)

/* 1063 */
#pragma pack(push, 1)
class CItemQuest : CItem
{
};
#pragma pack(pop)

/* 1064 */
#pragma pack(push, 1)
class /*VFT*/ CItemQuest_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	void(__thiscall* PutInfo)(CItem* this, char**, int);
	_BYTE gap4C[4];
	void(__thiscall* Init)(CItem* this, int, char**);
	void(__thiscall* SetWearState)(CItem* this, CPlayer*);
	int(__thiscall* Trash)(CItem* this, CPlayer*, int);
	void(__thiscall* Erase)(CItem* this, int);
	void(__thiscall* PutOn)(CItem* this, CPlayer*);
	void(__thiscall* PutOff)(CItem* this, CPlayer*);
	void(__thiscall* ApplySpec)(CItem* this, CPlayer*);
	void(__thiscall* FreeSpec)(CItem* this, CPlayer*);
	_BYTE gap70[4];
	void(__thiscall* Insert)(CItem* this, int, int);
	int(__thiscall* UpdateNum)(CItem* this, CPlayer*, int, int);
	void(__thiscall* Drop)(CItem* this, CChar*, const tagPOINT*, const tagPOINT*, int, int, int);
	int(__thiscall* Use)(CItem* this, CPlayer*);
	CItem* (__thiscall* Trade)(CItem* this, CPlayer*, int, int);
	int(__thiscall* CanSell)(CItem* this, int);
	int(__thiscall* CanTrade)(CItem* this, int, CPlayer*, CPlayer*);
	int(__thiscall* CanDrop)(CItem* this, int, CPlayer*);
	int(__thiscall* CanMerge)(CItem* this, CItem*);
	int(__thiscall* StorageIn)(CItem* this, CPlayer*, int);
	int(__thiscall* StorageOut)(CItem* this, CPlayer*, int, int, int*);
	void(__thiscall* ForcedStorageIn)(CItem* this, int, int, char*, int);
	int(__thiscall* IsMoney)(CItem* this);
	int(__thiscall* IsBroken)(CItem* this);
	int(__thiscall* Enchant)(CItem* this, CPlayer*, CItem*);
	int(__thiscall* Charming)(CItem* this, CPlayer*, int);
	int(__thiscall* CharmingCheat)(CItem* this, CPlayer*, int, int);
	int(__thiscall* Repair)(CItem* this, CPlayer*);
	int(__thiscall* ChangePrefix)(CItem* this, CPlayer*, int, int*, int*);
	int(__thiscall* Protect)(CItem* this, CPlayer*);
	int(__thiscall* IsQuestItem)(CItem* this);
	int(__thiscall* GetSellMoney)(CItem* this, int);
	void(__thiscall* SetEtc)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeDestroy)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeRateUp)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeLevel)(CItem* this, CPlayer*);
};
#pragma pack(pop)

/* 1065 */
#pragma pack(push, 1)
class HWND__
{
	int unused;
};
#pragma pack(pop)

/* 1066 */
#pragma pack(push, 1)
class std::iterator<std::random_access_iterator_tag, TRADEITEM, int, TRADEITEM const*, TRADEITEM const&>
{
};
#pragma pack(pop)

/* 1067 */
#pragma pack(push, 1)
class std::_Ranit<TRADEITEM, int, TRADEITEM const*, TRADEITEM const&> : std::iterator<std::random_access_iterator_tag, TRADEITEM, int, TRADEITEM const*, TRADEITEM const&>
{
};
#pragma pack(pop)

/* 1068 */
#pragma pack(push, 1)
class std::vector<TRADEITEM>::const_iterator : std::_Ranit<TRADEITEM, int, TRADEITEM const*, TRADEITEM const&>
{
	TRADEITEM* _Myptr;
};
#pragma pack(pop)

/* 1069 */
#pragma pack(push, 1)
class std::vector<TRADEITEM>::iterator : std::vector<TRADEITEM>::const_iterator
{
};
#pragma pack(pop)

/* 1070 */
#pragma pack(push, 1)
class PKBULLETININFO
{
	char szNameGuild[17];
	char szNameCatch[17];
	char szNameAssassin[17];
};
#pragma pack(pop)

/* 1071 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CItem*>, int, std::pair<int const, CItem*> const*, std::pair<int const, CItem*> const&>
{
};
#pragma pack(pop)

/* 1072 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, CItem*>, int, std::pair<int const, CItem*> const*, std::pair<int const, CItem*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CItem*>, int, std::pair<int const, CItem*> const*, std::pair<int const, CItem*> const&>
{
};
#pragma pack(pop)

/* 1073 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, CItem*>, int, std::pair<int const, CItem*> const*, std::pair<int const, CItem*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 1074 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 1075 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, ITEMINFO>, int, std::pair<int const, ITEMINFO> const*, std::pair<int const, ITEMINFO> const&>
{
};
#pragma pack(pop)

/* 1076 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, ITEMINFO>, int, std::pair<int const, ITEMINFO> const*, std::pair<int const, ITEMINFO> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, ITEMINFO>, int, std::pair<int const, ITEMINFO> const*, std::pair<int const, ITEMINFO> const&>
{
};
#pragma pack(pop)

/* 1077 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, ITEMINFO>, int, std::pair<int const, ITEMINFO> const*, std::pair<int const, ITEMINFO> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 1078 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 1079 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, STALLITEMINFO>, int, std::pair<int const, STALLITEMINFO> const*, std::pair<int const, STALLITEMINFO> const&>
{
};
#pragma pack(pop)

/* 1080 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, STALLITEMINFO>, int, std::pair<int const, STALLITEMINFO> const*, std::pair<int const, STALLITEMINFO> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, STALLITEMINFO>, int, std::pair<int const, STALLITEMINFO> const*, std::pair<int const, STALLITEMINFO> const&>
{
};
#pragma pack(pop)

/* 1081 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, STALLITEMINFO>, int, std::pair<int const, STALLITEMINFO> const*, std::pair<int const, STALLITEMINFO> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 1082 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 1083 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, MYQUEST>, int, std::pair<int const, MYQUEST> const*, std::pair<int const, MYQUEST> const&>
{
};
#pragma pack(pop)

/* 1084 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, MYQUEST>, int, std::pair<int const, MYQUEST> const*, std::pair<int const, MYQUEST> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, MYQUEST>, int, std::pair<int const, MYQUEST> const*, std::pair<int const, MYQUEST> const&>
{
};
#pragma pack(pop)

/* 1085 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, MYQUEST>, int, std::pair<int const, MYQUEST> const*, std::pair<int const, MYQUEST> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 1086 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 1087 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, FRDINFO>, int, std::pair<int const, FRDINFO> const*, std::pair<int const, FRDINFO> const&>
{
};
#pragma pack(pop)

/* 1088 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, FRDINFO>, int, std::pair<int const, FRDINFO> const*, std::pair<int const, FRDINFO> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, FRDINFO>, int, std::pair<int const, FRDINFO> const*, std::pair<int const, FRDINFO> const&>
{
};
#pragma pack(pop)

/* 1089 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, FRDINFO>, int, std::pair<int const, FRDINFO> const*, std::pair<int const, FRDINFO> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 1090 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 1091 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, MAILINFO>, int, std::pair<int const, MAILINFO> const*, std::pair<int const, MAILINFO> const&>
{
};
#pragma pack(pop)

/* 1092 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, MAILINFO>, int, std::pair<int const, MAILINFO> const*, std::pair<int const, MAILINFO> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, MAILINFO>, int, std::pair<int const, MAILINFO> const*, std::pair<int const, MAILINFO> const&>
{
};
#pragma pack(pop)

/* 1093 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, MAILINFO>, int, std::pair<int const, MAILINFO> const*, std::pair<int const, MAILINFO> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 1094 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 1095 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<std::string const, TELPT>, int, std::pair<std::string const, TELPT> const*, std::pair<std::string const, TELPT> const&>
{
};
#pragma pack(pop)

/* 1096 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<std::string const, TELPT>, int, std::pair<std::string const, TELPT> const*, std::pair<std::string const, TELPT> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<std::string const, TELPT>, int, std::pair<std::string const, TELPT> const*, std::pair<std::string const, TELPT> const&>
{
};
#pragma pack(pop)

/* 1097 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::const_iterator : std::_Bidit<std::pair<std::string const, TELPT>, int, std::pair<std::string const, TELPT> const*, std::pair<std::string const, TELPT> const&>
{
	std::_Tree_nod<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 1098 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 1099 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CPlayer*>, int, std::pair<int const, CPlayer*> const*, std::pair<int const, CPlayer*> const&>
{
};
#pragma pack(pop)

/* 1100 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, CPlayer*>, int, std::pair<int const, CPlayer*> const*, std::pair<int const, CPlayer*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CPlayer*>, int, std::pair<int const, CPlayer*> const*, std::pair<int const, CPlayer*> const&>
{
};
#pragma pack(pop)

/* 1101 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, CPlayer*>, int, std::pair<int const, CPlayer*> const*, std::pair<int const, CPlayer*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 1102 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 1103 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<char const* const, CPlayer*>, int, std::pair<char const* const, CPlayer*> const*, std::pair<char const* const, CPlayer*> const&>
{
};
#pragma pack(pop)

/* 1104 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<char const* const, CPlayer*>, int, std::pair<char const* const, CPlayer*> const*, std::pair<char const* const, CPlayer*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<char const* const, CPlayer*>, int, std::pair<char const* const, CPlayer*> const*, std::pair<char const* const, CPlayer*> const&>
{
};
#pragma pack(pop)

/* 1105 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::const_iterator : std::_Bidit<std::pair<char const* const, CPlayer*>, int, std::pair<char const* const, CPlayer*> const*, std::pair<char const* const, CPlayer*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 1106 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 1107 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CPlayer*> >::rebind<std::pair<int const, CPlayer*> >
{
};
#pragma pack(pop)

/* 1108 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CPlayer*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 1109 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CPlayer*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 1110 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CPlayer*> >::rebind<int>
{
};
#pragma pack(pop)

/* 1111 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CPlayer*> >::rebind<char>
{
};
#pragma pack(pop)

/* 1112 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 1113 */
#pragma pack(push, 1)
class std::pair<std::_Tree<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::iterator, std::_Tree<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::iterator>
{
	std::_Tree<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::iterator first;
	std::_Tree<std::_Tmap_traits<int, CPlayer*, std::less<int>, std::allocator<std::pair<int const, CPlayer*> >, 0> >::iterator second;
};
#pragma pack(pop)

/* 1114 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, CPlayer*> >::rebind<std::pair<char const* const, CPlayer*> >
{
};
#pragma pack(pop)

/* 1115 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, CPlayer*> >::rebind<std::_Tree_nod<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 1116 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, CPlayer*> >::rebind<std::_Tree_nod<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 1117 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, CPlayer*> >::rebind<char const*>
{
};
#pragma pack(pop)

/* 1118 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, CPlayer*> >::rebind<char>
{
};
#pragma pack(pop)

/* 1119 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 1120 */
#pragma pack(push, 1)
class std::pair<std::_Tree<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::iterator, std::_Tree<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::iterator>
{
	std::_Tree<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::iterator first;
	std::_Tree<std::_Tmap_traits<char const*, CPlayer*, StrCmp, std::allocator<std::pair<char const* const, CPlayer*> >, 0> >::iterator second;
};
#pragma pack(pop)

/* 1121 */
#pragma pack(push, 1)
class std::_Allocator_base<char const*>
{
};
#pragma pack(pop)

/* 1122 */
#pragma pack(push, 1)
class std::allocator<char const*> : std::_Allocator_base<char const*>
{
};
#pragma pack(pop)

/* 1123 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 1124 */
#pragma pack(push, 1)
class std::pair<std::_Tree<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::iterator, std::_Tree<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::iterator>
{
	std::_Tree<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::iterator first;
	std::_Tree<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::iterator second;
};
#pragma pack(pop)

/* 1125 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CItem*> >::rebind<std::pair<int const, CItem*> >
{
};
#pragma pack(pop)

/* 1126 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CItem*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 1127 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CItem*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CItem*, std::less<int>, std::allocator<std::pair<int const, CItem*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 1128 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CItem*> >::rebind<int>
{
};
#pragma pack(pop)

/* 1129 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CItem*> >::rebind<char>
{
};
#pragma pack(pop)

/* 1130 */
#pragma pack(push, 1)
class std::input_iterator_tag
{
};
#pragma pack(pop)

/* 1131 */
#pragma pack(push, 1)
class std::forward_iterator_tag : std::input_iterator_tag
{
};
#pragma pack(pop)

/* 1132 */
#pragma pack(push, 1)
class std::bidirectional_iterator_tag : std::forward_iterator_tag
{
};
#pragma pack(pop)

/* 1133 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 1134 */
#pragma pack(push, 1)
class std::pair<std::_Tree<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::iterator, std::_Tree<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::iterator>
{
	std::_Tree<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::iterator first;
	std::_Tree<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::iterator second;
};
#pragma pack(pop)

/* 1135 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, ITEMINFO> >::rebind<std::pair<int const, ITEMINFO> >
{
};
#pragma pack(pop)

/* 1136 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, ITEMINFO> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 1137 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, ITEMINFO> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, ITEMINFO, std::less<int>, std::allocator<std::pair<int const, ITEMINFO> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 1138 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, ITEMINFO> >::rebind<int>
{
};
#pragma pack(pop)

/* 1139 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, ITEMINFO> >::rebind<char>
{
};
#pragma pack(pop)

/* 1140 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 1141 */
#pragma pack(push, 1)
class std::pair<std::_Tree<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::iterator, std::_Tree<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::iterator>
{
	std::_Tree<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::iterator first;
	std::_Tree<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::iterator second;
};
#pragma pack(pop)

/* 1142 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, STALLITEMINFO> >::rebind<std::pair<int const, STALLITEMINFO> >
{
};
#pragma pack(pop)

/* 1143 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, STALLITEMINFO> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 1144 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, STALLITEMINFO> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, STALLITEMINFO, std::less<int>, std::allocator<std::pair<int const, STALLITEMINFO> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 1145 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, STALLITEMINFO> >::rebind<int>
{
};
#pragma pack(pop)

/* 1146 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, STALLITEMINFO> >::rebind<char>
{
};
#pragma pack(pop)

/* 1147 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 1148 */
#pragma pack(push, 1)
class std::pair<std::_Tree<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::iterator, std::_Tree<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::iterator>
{
	std::_Tree<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::iterator first;
	std::_Tree<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::iterator second;
};
#pragma pack(pop)

/* 1149 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, MYQUEST> >::rebind<std::pair<int const, MYQUEST> >
{
};
#pragma pack(pop)

/* 1150 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, MYQUEST> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 1151 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, MYQUEST> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, MYQUEST, std::less<int>, std::allocator<std::pair<int const, MYQUEST> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 1152 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, MYQUEST> >::rebind<int>
{
};
#pragma pack(pop)

/* 1153 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, MYQUEST> >::rebind<char>
{
};
#pragma pack(pop)

/* 1154 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 1155 */
#pragma pack(push, 1)
class std::pair<std::_Tree<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::iterator, std::_Tree<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::iterator>
{
	std::_Tree<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::iterator first;
	std::_Tree<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::iterator second;
};
#pragma pack(pop)

/* 1156 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, FRDINFO> >::rebind<std::pair<int const, FRDINFO> >
{
};
#pragma pack(pop)

/* 1157 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, FRDINFO> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 1158 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, FRDINFO> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, FRDINFO, std::less<int>, std::allocator<std::pair<int const, FRDINFO> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 1159 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, FRDINFO> >::rebind<int>
{
};
#pragma pack(pop)

/* 1160 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, FRDINFO> >::rebind<char>
{
};
#pragma pack(pop)

/* 1161 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 1162 */
#pragma pack(push, 1)
class std::pair<std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::iterator, std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::iterator>
{
	std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::iterator first;
	std::_Tree<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::iterator second;
};
#pragma pack(pop)

/* 1163 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, MAILINFO> >::rebind<std::pair<int const, MAILINFO> >
{
};
#pragma pack(pop)

/* 1164 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, MAILINFO> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 1165 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, MAILINFO> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, MAILINFO, std::less<int>, std::allocator<std::pair<int const, MAILINFO> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 1166 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, MAILINFO> >::rebind<int>
{
};
#pragma pack(pop)

/* 1167 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, MAILINFO> >::rebind<char>
{
};
#pragma pack(pop)

/* 1168 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 1169 */
#pragma pack(push, 1)
class std::pair<std::_Tree<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::iterator, std::_Tree<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::iterator>
{
	std::_Tree<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::iterator first;
	std::_Tree<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::iterator second;
};
#pragma pack(pop)

/* 1170 */
#pragma pack(push, 1)
class std::allocator<std::pair<std::string const, TELPT> >::rebind<std::pair<std::string const, TELPT> >
{
};
#pragma pack(pop)

/* 1171 */
#pragma pack(push, 1)
class std::allocator<std::pair<std::string const, TELPT> >::rebind<std::_Tree_nod<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 1172 */
#pragma pack(push, 1)
class std::allocator<std::pair<std::string const, TELPT> >::rebind<std::_Tree_nod<std::_Tmap_traits<std::string, TELPT, iless, std::allocator<std::pair<std::string const, TELPT> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 1173 */
#pragma pack(push, 1)
class std::allocator<std::pair<std::string const, TELPT> >::rebind<std::string >
{
};
#pragma pack(pop)

/* 1174 */
#pragma pack(push, 1)
class std::allocator<std::pair<std::string const, TELPT> >::rebind<char>
{
};
#pragma pack(pop)

/* 1175 */
#pragma pack(push, 1)
class std::iterator<std::random_access_iterator_tag, char, int, char const*, char const&>
{
};
#pragma pack(pop)

/* 1176 */
#pragma pack(push, 1)
class std::_Ranit<char, int, char const*, char const&> : std::iterator<std::random_access_iterator_tag, char, int, char const*, char const&>
{
};
#pragma pack(pop)

/* 1177 */
#pragma pack(push, 1)
class std::string::const_iterator : std::_Ranit<char, int, char const*, char const&>
{
	const char* _Myptr;
};
#pragma pack(pop)

/* 1178 */
#pragma pack(push, 1)
class std::string::iterator : std::string::const_iterator
{
};
#pragma pack(pop)

/* 1179 */
#pragma pack(push, 1)
class std::char_traits<char>
{
};
#pragma pack(pop)

/* 1180 */
#pragma pack(push, 1)
class std::allocator<TRADEITEM>::rebind<TRADEITEM>
{
};
#pragma pack(pop)

/* 1181 */
#pragma pack(push, 1)
class std::_Allocator_base<std::string >
{
};
#pragma pack(pop)

/* 1182 */
#pragma pack(push, 1)
class std::allocator<std::string > : std::_Allocator_base<std::string >
{
};
#pragma pack(pop)

/* 1183 */
#pragma pack(push, 1)
class HPMP_REVISE_FORLEVELUP
{
	int nValue;
	int nExtra;
};
#pragma pack(pop)

/* 1184 */
#pragma pack(push, 1)
class VILLAGELOC
{
	int nMap;
	tagPOINT ptPLoc;
	int nZ;
	int bSkip;
};
#pragma pack(pop)

/* 1185 */
#pragma pack(push, 1)
class REVIVALLOC
{
	int nMap;
	tagPOINT ptPLoc;
	int nZ;
	int nCID;
	int nLinkedGate;
	int nResetGate;
};
#pragma pack(pop)

/* 1186 */
#pragma pack(push, 1)
class TELEPORTLOC
{
	int nMap;
	tagPOINT ptPLoc;
	int nZ;
};
#pragma pack(pop)

/* 1187 */
#pragma pack(push, 1)
class CTables
{
};
#pragma pack(pop)

/* 1189 */
#pragma pack(push, 1)
class BASEPROPERTY
{
	int prty[5];
	int nHP;
	int nMP;
};
#pragma pack(pop)

/* 1190 */
#pragma pack(push, 1)
class tagEMR
{
	unsigned int iType;
	unsigned int nSize;
};
#pragma pack(pop)

/* 1191 */
#pragma pack(push, 1)
class _RECTL
{
	int left;
	int top;
	int right;
	int bottom;
};
#pragma pack(pop)

/* 1192 */
#pragma pack(push, 1)
class _POINTL
{
	int x;
	int y;
};
#pragma pack(pop)

/* 1193 */
#pragma pack(push, 1)
class tagEMRPOLYLINE
{
	tagEMR emr;
	_RECTL rclBounds;
	unsigned int cptl;
	_POINTL aptl[1];
};
#pragma pack(pop)

/* 1194 */
#pragma pack(push, 1)
class tagXFORM
{
	float eM11;
	float eM12;
	float eM21;
	float eM22;
	float eDx;
	float eDy;
};
#pragma pack(pop)

/* 1195 */
#pragma pack(push, 1)
class tagEMRTRANSPARENTBLT
{
	tagEMR emr;
	_RECTL rclBounds;
	int xDest;
	int yDest;
	int cxDest;
	int cyDest;
	unsigned int dwRop;
	int xSrc;
	int ySrc;
	tagXFORM xformSrc;
	unsigned int crBkColorSrc;
	unsigned int iUsageSrc;
	unsigned int offBmiSrc;
	unsigned int cbBmiSrc;
	unsigned int offBitsSrc;
	unsigned int cbBitsSrc;
	int cxSrc;
	int cySrc;
};
#pragma pack(pop)

/* 1196 */
#pragma pack(push, 1)
class _TAPE_SET_DRIVE_PARAMETERS
{
	unsigned __int8 ECC;
	unsigned __int8 Compression;
	unsigned __int8 DataPadding;
	unsigned __int8 ReportSetmarks;
	unsigned int EOTWarningZoneSize;
};
#pragma pack(pop)

/* 1197 */
#pragma pack(push, 1)
class tagCBTACTIVATEclass
{
	int fMouse;
	HWND__* hWndActive;
};
#pragma pack(pop)

/* 1198 */
#pragma pack(push, 1)
class _NETRESOURCEW
{
	unsigned int dwScope;
	unsigned int dwType;
	unsigned int dwDisplayType;
	unsigned int dwUsage;
	unsigned __int16* lpLocalName;
	unsigned __int16* lpRemoteName;
	unsigned __int16* lpComment;
	unsigned __int16* lpProvider;
};
#pragma pack(pop)

/* 1199 */
#pragma pack(push, 1)
class _GUID
{
	unsigned int Data1;
	unsigned __int16 Data2;
	unsigned __int16 Data3;
	unsigned __int8 Data4[8];
};
#pragma pack(pop)

/* 1200 */
#pragma pack(push, 1)
class _WSAVersion
{
	unsigned int dwVersion;
	_WSAEcomparator ecHow;
};
#pragma pack(pop)

/* 1201 */
#pragma pack(push, 1)
class _AFPROTOCOLS
{
	int iAddressFamily;
	int iProtocol;
};
#pragma pack(pop)

/* 1202 */
#pragma pack(push, 1)
class _SOCKET_ADDRESS
{
	sockaddr* lpSockaddr;
	int iSockaddrLength;
};
#pragma pack(pop)

/* 1203 */
#pragma pack(push, 1)
class _CSADDR_INFO
{
	_SOCKET_ADDRESS LocalAddr;
	_SOCKET_ADDRESS RemoteAddr;
	int iSocketType;
	int iProtocol;
};
#pragma pack(pop)

/* 1204 */
#pragma pack(push, 1)
class _BLOB
{
	unsigned int cbSize;
	unsigned __int8* pBlobData;
};
#pragma pack(pop)

/* 1205 */
#pragma pack(push, 1)
class _WSAQuerySetA
{
	unsigned int dwSize;
	char* lpszServiceInstanceName;
	_GUID* lpServiceClassId;
	_WSAVersion* lpVersion;
	char* lpszComment;
	unsigned int dwNameSpace;
	_GUID* lpNSProviderId;
	char* lpszContext;
	unsigned int dwNumberOfProtocols;
	_AFPROTOCOLS* lpafpProtocols;
	char* lpszQueryString;
	unsigned int dwNumberOfCsAddrs;
	_CSADDR_INFO* lpcsaBuffer;
	unsigned int dwOutputFlags;
	_BLOB* lpBlob;
};
#pragma pack(pop)

/* 1206 */
#pragma pack(push, 1)
class _CRYPTOAPI_BLOB
{
	unsigned int cbData;
	unsigned __int8* pbData;
};
#pragma pack(pop)

/* 1207 */
#pragma pack(push, 1)
class _CRYPT_ALGORITHM_IDENTIFIER
{
	char* pszObjId;
	_CRYPTOAPI_BLOB Parameters;
};
#pragma pack(pop)

/* 1208 */
#pragma pack(push, 1)
class _CRYPT_BIT_BLOB
{
	unsigned int cbData;
	unsigned __int8* pbData;
	unsigned int cUnusedBits;
};
#pragma pack(pop)

/* 1209 */
#pragma pack(push, 1)
class _CERT_PUBLIC_KEY_INFO
{
	_CRYPT_ALGORITHM_IDENTIFIER Algorithm;
	_CRYPT_BIT_BLOB PublicKey;
};
#pragma pack(pop)

/* 1210 */
#pragma pack(push, 1)
class _CERT_EXTENSION
{
	char* pszObjId;
	int fCritical;
	_CRYPTOAPI_BLOB Value;
};
#pragma pack(pop)

/* 1211 */
#pragma pack(push, 1)
class _CERT_INFO
{
	unsigned int dwVersion;
	_CRYPTOAPI_BLOB SerialNumber;
	_CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
	_CRYPTOAPI_BLOB Issuer;
	_FILETIME NotBefore;
	_FILETIME NotAfter;
	_CRYPTOAPI_BLOB Subject;
	_CERT_PUBLIC_KEY_INFO SubjectPublicKeyInfo;
	_CRYPT_BIT_BLOB IssuerUniqueId;
	_CRYPT_BIT_BLOB SubjectUniqueId;
	unsigned int cExtension;
	_CERT_EXTENSION* rgExtension;
};
#pragma pack(pop)

/* 1212 */
#pragma pack(push, 1)
class _CMSG_ENVELOPED_ENCODE_INFO
{
	unsigned int cbSize;
	unsigned int hCryptProv;
	_CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
	void* pvEncryptionAuxInfo;
	unsigned int cRecipients;
	_CERT_INFO** rgpRecipients;
};
#pragma pack(pop)

/* 1213 */
#pragma pack(push, 1)
class _CRYPT_TRUST_REG_ENTRY
{
	unsigned int cbclass;
	unsigned __int16* pwszDLLName;
	unsigned __int16* pwszFunctionName;
};
#pragma pack(pop)

/* 1214 */
#pragma pack(push, 1)
class _CRYPT_REGISTER_ACTIONID
{
	unsigned int cbclass;
	_CRYPT_TRUST_REG_ENTRY sInitProvider;
	_CRYPT_TRUST_REG_ENTRY sObjectProvider;
	_CRYPT_TRUST_REG_ENTRY sSignatureProvider;
	_CRYPT_TRUST_REG_ENTRY sCertificateProvider;
	_CRYPT_TRUST_REG_ENTRY sCertificatePolicyProvider;
	_CRYPT_TRUST_REG_ENTRY sFinalPolicyProvider;
	_CRYPT_TRUST_REG_ENTRY sTestPolicyProvider;
	_CRYPT_TRUST_REG_ENTRY sCleanupProvider;
};
#pragma pack(pop)

/* 1215 */
#pragma pack(push, 1)
class _QUERY_SERVICE_CONFIGA
{
	unsigned int dwServiceType;
	unsigned int dwStartType;
	unsigned int dwErrorControl;
	char* lpBinaryPathName;
	char* lpLoadOrderGroup;
	unsigned int dwTagId;
	char* lpDependencies;
	char* lpServiceStartName;
	char* lpDisplayName;
};
#pragma pack(pop)

/* 1216 */
#pragma pack(push, 1)
class _TOKEN_PRIMARY_GROUP
{
	void* PrimaryGroup;
};
#pragma pack(pop)

/* 1217 */
#pragma pack(push, 1)
class $AC3CC93FF2393A79A2006C75C47A801C
{
	void* hMem;
	unsigned int dwReserved[3];
};
#pragma pack(pop)

/* 1218 */
#pragma pack(push, 1)
class $198F028743F5D31A320CCE89F06CEFB4
{
	unsigned int dwCommittedSize;
	unsigned int dwUnCommittedSize;
	void* lpFirstBlock;
	void* lpLastBlock;
};
#pragma pack(pop)

/* 1219 */
#pragma pack(push, 1)
union $EF368D1F721AD60A289EF06DB56A3264
{
	$AC3CC93FF2393A79A2006C75C47A801C Block;
	$198F028743F5D31A320CCE89F06CEFB4 Region;
};
#pragma pack(pop)

/* 1220 */
#pragma pack(push, 1)
class _PROCESS_HEAP_ENTRY
{
	void* lpData;
	unsigned int cbData;
	unsigned __int8 cbOverhead;
	unsigned __int8 iRegionIndex;
	unsigned __int16 wFlags;
	$EF368D1F721AD60A289EF06DB56A3264 ___u5;
};
#pragma pack(pop)

/* 1221 */
#pragma pack(push, 1)
class tagEMREOF
{
	tagEMR emr;
	unsigned int nPalEntries;
	unsigned int offPalEntries;
	unsigned int nSizeLast;
};
#pragma pack(pop)

/* 1222 */
#pragma pack(push, 1)
class _CERT_ISSUER_SERIAL_NUMBER
{
	_CRYPTOAPI_BLOB Issuer;
	_CRYPTOAPI_BLOB SerialNumber;
};
#pragma pack(pop)

/* 1223 */
#pragma pack(push, 1)
union $8B5E8AE0463E4D803148AF5DFC6BBD7E
{
	_CERT_ISSUER_SERIAL_NUMBER IssuerSerialNumber;
	_CRYPTOAPI_BLOB KeyId;
	_CRYPTOAPI_BLOB HashId;
};
#pragma pack(pop)

/* 1224 */
#pragma pack(push, 1)
class _CERT_ID
{
	unsigned int dwIdChoice;
	$8B5E8AE0463E4D803148AF5DFC6BBD7E ___u1;
};
#pragma pack(pop)

/* 1225 */
#pragma pack(push, 1)
class _CRYPT_ATTRIBUTE_TYPE_VALUE
{
	char* pszObjId;
	_CRYPTOAPI_BLOB Value;
};
#pragma pack(pop)

/* 1226 */
#pragma pack(push, 1)
class _CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO
{
	unsigned int cbSize;
	_CRYPT_BIT_BLOB RecipientPublicKey;
	_CERT_ID RecipientId;
	_FILETIME Date;
	_CRYPT_ATTRIBUTE_TYPE_VALUE* pOtherAttr;
};
#pragma pack(pop)

/* 1227 */
#pragma pack(push, 1)
union $A4EA7291B9B29A4F196A542F0EDE30BA
{
	_CRYPT_ALGORITHM_IDENTIFIER* pEphemeralAlgorithm;
	_CERT_ID* pSenderId;
};
#pragma pack(pop)

/* 1228 */
#pragma pack(push, 1)
class _CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO
{
	unsigned int cbSize;
	_CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
	void* pvKeyEncryptionAuxInfo;
	_CRYPT_ALGORITHM_IDENTIFIER KeyWrapAlgorithm;
	void* pvKeyWrapAuxInfo;
	unsigned int hCryptProv;
	unsigned int dwKeySpec;
	unsigned int dwKeyChoice;
	$A4EA7291B9B29A4F196A542F0EDE30BA ___u8;
	_CRYPTOAPI_BLOB UserKeyingMaterial;
	unsigned int cRecipientEncryptedKeys;
	_CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO** rgpRecipientEncryptedKeys;
};
#pragma pack(pop)

/* 1229 */
#pragma pack(push, 1)
class _CMSG_RECIPIENT_ENCRYPTED_KEY_INFO
{
	_CERT_ID RecipientId;
	_CRYPTOAPI_BLOB EncryptedKey;
	_FILETIME Date;
	_CRYPT_ATTRIBUTE_TYPE_VALUE* pOtherAttr;
};
#pragma pack(pop)

/* 1230 */
#pragma pack(push, 1)
class __declspec(align(8)) _SYMBOL_INFO_PACKAGE
{
	_SYMBOL_INFO si;
	char name[2001];
};
#pragma pack(pop)

/* 1231 */
#pragma pack(push, 1)
class _SID_AND_ATTRIBUTES
{
	void* Sid;
	unsigned int Attributes;
};
#pragma pack(pop)

/* 1232 */
#pragma pack(push, 1)
class _MEMORY_BASIC_INFORMATION64
{
	unsigned __int64 BaseAddress;
	unsigned __int64 AllocationBase;
	unsigned int AllocationProtect;
	unsigned int __alignment1;
	unsigned __int64 RegionSize;
	unsigned int State;
	unsigned int Protect;
	unsigned int Type;
	unsigned int __alignment2;
};
#pragma pack(pop)

/* 1233 */
#pragma pack(push, 1)
class _PROCESSOR_POWER_POLICY_INFO
{
	unsigned int TimeCheck;
	unsigned int DemoteLimit;
	unsigned int PromoteLimit;
	unsigned __int8 DemotePercent;
	unsigned __int8 PromotePercent;
	unsigned __int8 Spare[2];
	unsigned __int32 AllowDemotion : 1;
	unsigned __int32 AllowPromotion : 1;
	unsigned __int32 Reserved : 30;
};
#pragma pack(pop)

/* 1234 */
#pragma pack(push, 1)
class _PROCESSOR_POWER_POLICY
{
	unsigned int Revision;
	unsigned __int8 DynamicThrottle;
	unsigned __int8 Spare[3];
	unsigned __int32 DisableCStates : 1;
	unsigned __int32 Reserved : 31;
	unsigned int PolicyCount;
	_PROCESSOR_POWER_POLICY_INFO Policy[3];
};
#pragma pack(pop)

/* 1235 */
#pragma pack(push, 1)
class tagTOGGLEKEYS
{
	unsigned int cbSize;
	unsigned int dwFlags;
};
#pragma pack(pop)

/* 1236 */
#pragma pack(push, 1)
class _tagADDRESS64
{
	unsigned __int64 Offset;
	unsigned __int16 Segment;
	__declspec(align(4)) ADDRESS_MODE Mode;
};
#pragma pack(pop)

/* 1237 */
#pragma pack(push, 1)
class __unaligned __declspec(align(2)) tagBITMAPFILEHEADER
{
	unsigned __int16 bfType;
	unsigned int bfSize;
	unsigned __int16 bfReserved1;
	unsigned __int16 bfReserved2;
	unsigned int bfOffBits;
};
#pragma pack(pop)

/* 1238 */
#pragma pack(push, 1)
class _MINIDUMP_STRING
{
	unsigned int Length;
	unsigned __int16 Buffer[];
};
#pragma pack(pop)

/* 1239 */
#pragma pack(push, 1)
class tagEMRARC
{
	tagEMR emr;
	_RECTL rclBox;
	_POINTL ptlStart;
	_POINTL ptlEnd;
};
#pragma pack(pop)

/* 1240 */
#pragma pack(push, 1)
class tagNMHDR
{
	HWND__* hwndFrom;
	unsigned int idFrom;
	unsigned int code;
};
#pragma pack(pop)

/* 1241 */
#pragma pack(push, 1)
class tagLOGFONTW
{
	int lfHeight;
	int lfWidth;
	int lfEscapement;
	int lfOrientation;
	int lfWeight;
	unsigned __int8 lfItalic;
	unsigned __int8 lfUnderline;
	unsigned __int8 lfStrikeOut;
	unsigned __int8 lfCharSet;
	unsigned __int8 lfOutPrecision;
	unsigned __int8 lfClipPrecision;
	unsigned __int8 lfQuality;
	unsigned __int8 lfPitchAndFamily;
	unsigned __int16 lfFaceName[32];
};
#pragma pack(pop)

/* 1242 */
#pragma pack(push, 1)
class tagICONMETRICSW
{
	unsigned int cbSize;
	int iHorzSpacing;
	int iVertSpacing;
	int iTitleWrap;
	tagLOGFONTW lfFont;
};
#pragma pack(pop)

/* 1243 */
#pragma pack(push, 1)
class _currencyfmtA
{
	unsigned int NumDigits;
	unsigned int LeadingZero;
	unsigned int Grouping;
	char* lpDecimalSep;
	char* lpThousandSep;
	unsigned int NegativeOrder;
	unsigned int PositiveOrder;
	char* lpCurrencySymbol;
};
#pragma pack(pop)

/* 1244 */
#pragma pack(push, 1)
class val_context
{
	int valuelen;
	void* value_context;
	void* val_buff_ptr;
};
#pragma pack(pop)

/* 1245 */
#pragma pack(push, 1)
class _CERT_CONTEXT
{
	unsigned int dwCertEncodingType;
	unsigned __int8* pbCertEncoded;
	unsigned int cbCertEncoded;
	_CERT_INFO* pCertInfo;
	void* hCertStore;
};
#pragma pack(pop)

/* 1246 */
#pragma pack(push, 1)
class _CERT_TRUST_STATUS
{
	unsigned int dwErrorStatus;
	unsigned int dwInfoStatus;
};
#pragma pack(pop)

/* 1247 */
#pragma pack(push, 1)
class _CRL_ENTRY
{
	_CRYPTOAPI_BLOB SerialNumber;
	_FILETIME RevocationDate;
	unsigned int cExtension;
	_CERT_EXTENSION* rgExtension;
};
#pragma pack(pop)

/* 1248 */
#pragma pack(push, 1)
class _CRL_INFO
{
	unsigned int dwVersion;
	_CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
	_CRYPTOAPI_BLOB Issuer;
	_FILETIME ThisUpdate;
	_FILETIME NextUpdate;
	unsigned int cCRLEntry;
	_CRL_ENTRY* rgCRLEntry;
	unsigned int cExtension;
	_CERT_EXTENSION* rgExtension;
};
#pragma pack(pop)

/* 1249 */
#pragma pack(push, 1)
const class _CRL_CONTEXT
{
	unsigned int dwCertEncodingType;
	unsigned __int8* pbCrlEncoded;
	unsigned int cbCrlEncoded;
	_CRL_INFO* pCrlInfo;
	void* hCertStore;
};
#pragma pack(pop)

/* 1250 */
#pragma pack(push, 1)
class _CERT_REVOCATION_CRL_INFO
{
	unsigned int cbSize;
	const _CRL_CONTEXT* pBaseCrlContext;
	const _CRL_CONTEXT* pDeltaCrlContext;
	_CRL_ENTRY* pCrlEntry;
	int fDeltaCrlEntry;
};
#pragma pack(pop)

/* 1251 */
#pragma pack(push, 1)
class _CERT_REVOCATION_INFO
{
	unsigned int cbSize;
	unsigned int dwRevocationResult;
	const char* pszRevocationOid;
	void* pvOidSpecificInfo;
	int fHasFreshnessTime;
	unsigned int dwFreshnessTime;
	_CERT_REVOCATION_CRL_INFO* pCrlInfo;
};
#pragma pack(pop)

/* 1252 */
#pragma pack(push, 1)
class _CTL_USAGE
{
	unsigned int cUsageIdentifier;
	char** rgpszUsageIdentifier;
};
#pragma pack(pop)

/* 1253 */
#pragma pack(push, 1)
class _CERT_CHAIN_ELEMENT
{
	unsigned int cbSize;
	const _CERT_CONTEXT* pCertContext;
	_CERT_TRUST_STATUS TrustStatus;
	_CERT_REVOCATION_INFO* pRevocationInfo;
	_CTL_USAGE* pIssuanceUsage;
	_CTL_USAGE* pApplicationUsage;
	const unsigned __int16* pwszExtendedErrorInfo;
};
#pragma pack(pop)

/* 1254 */
#pragma pack(push, 1)
class _ACTIVATION_CONTEXT_QUERY_INDEX
{
	unsigned int ulAssemblyIndex;
	unsigned int ulFileIndexInAssembly;
};
#pragma pack(pop)

/* 1255 */
#pragma pack(push, 1)
class _CRYPT_ATTRIBUTE
{
	char* pszObjId;
	unsigned int cValue;
	_CRYPTOAPI_BLOB* rgValue;
};
#pragma pack(pop)

/* 1256 */
#pragma pack(push, 1)
class _CRYPT_ATTRIBUTES
{
	unsigned int cAttr;
	_CRYPT_ATTRIBUTE* rgAttr;
};
#pragma pack(pop)

/* 1257 */
#pragma pack(push, 1)
class _CMC_ADD_EXTENSIONS_INFO
{
	unsigned int dwCmcDataReference;
	unsigned int cCertReference;
	unsigned int* rgdwCertReference;
	unsigned int cExtension;
	_CERT_EXTENSION* rgExtension;
};
#pragma pack(pop)

/* 1258 */
#pragma pack(push, 1)
class _CRYPT_URL_ARRAY
{
	unsigned int cUrl;
	unsigned __int16** rgwszUrl;
};
#pragma pack(pop)

/* 1259 */
#pragma pack(push, 1)
union $9F611DDC5EAA7CDE9EB10D7C6AB5827F
{
	unsigned int Reserved;
	unsigned int TimeDateStamp;
};
#pragma pack(pop)

/* 1260 */
#pragma pack(push, 1)
class _MINIDUMP_HEADER
{
	unsigned int Signature;
	unsigned int Version;
	unsigned int NumberOfStreams;
	unsigned int StreamDirectoryRva;
	unsigned int CheckSum;
	$9F611DDC5EAA7CDE9EB10D7C6AB5827F ___u5;
	unsigned __int64 Flags;
};
#pragma pack(pop)

/* 1261 */
#pragma pack(push, 1)
class _OSVERSIONINFOEXW
{
	unsigned int dwOSVersionInfoSize;
	unsigned int dwMajorVersion;
	unsigned int dwMinorVersion;
	unsigned int dwBuildNumber;
	unsigned int dwPlatformId;
	unsigned __int16 szCSDVersion[128];
	unsigned __int16 wServicePackMajor;
	unsigned __int16 wServicePackMinor;
	unsigned __int16 wSuiteMask;
	unsigned __int8 wProductType;
	unsigned __int8 wReserved;
};
#pragma pack(pop)

/* 1262 */
#pragma pack(push, 1)
class _DCB
{
	unsigned int DCBlength;
	unsigned int BaudRate;
	unsigned __int32 fBinary : 1;
	unsigned __int32 fParity : 1;
	unsigned __int32 fOutxCtsFlow : 1;
	unsigned __int32 fOutxDsrFlow : 1;
	unsigned __int32 fDtrControl : 2;
	unsigned __int32 fDsrSensitivity : 1;
	unsigned __int32 fTXContinueOnXoff : 1;
	unsigned __int32 fOutX : 1;
	unsigned __int32 fInX : 1;
	unsigned __int32 fErrorChar : 1;
	unsigned __int32 fNull : 1;
	unsigned __int32 fRtsControl : 2;
	unsigned __int32 fAbortOnError : 1;
	unsigned __int32 fDummy2 : 17;
	unsigned __int16 wReserved;
	unsigned __int16 XonLim;
	unsigned __int16 XoffLim;
	unsigned __int8 ByteSize;
	unsigned __int8 Parity;
	unsigned __int8 StopBits;
	char XonChar;
	char XoffChar;
	char ErrorChar;
	char EofChar;
	char EvtChar;
	unsigned __int16 wReserved1;
};
#pragma pack(pop)

/* 1263 */
#pragma pack(push, 1)
class __declspec(align(4)) _COMMCONFIG
{
	unsigned int dwSize;
	unsigned __int16 wVersion;
	unsigned __int16 wReserved;
	_DCB dcb;
	unsigned int dwProviderSubType;
	unsigned int dwProviderOffset;
	unsigned int dwProviderSize;
	unsigned __int16 wcProviderData[1];
};
#pragma pack(pop)

/* 1264 */
#pragma pack(push, 1)
class tagPALETTEENTRY
{
	unsigned __int8 peRed;
	unsigned __int8 peGreen;
	unsigned __int8 peBlue;
	unsigned __int8 peFlags;
};
#pragma pack(pop)

/* 1265 */
#pragma pack(push, 1)
class tagPANOSE
{
	unsigned __int8 bFamilyType;
	unsigned __int8 bSerifStyle;
	unsigned __int8 bWeight;
	unsigned __int8 bProportion;
	unsigned __int8 bContrast;
	unsigned __int8 bStrokeVariation;
	unsigned __int8 bArmStyle;
	unsigned __int8 bLetterform;
	unsigned __int8 bMidline;
	unsigned __int8 bXHeight;
};
#pragma pack(pop)

/* 1266 */
#pragma pack(push, 1)
class __declspec(align(4)) tagEXTLOGFONTW
{
	tagLOGFONTW elfLogFont;
	unsigned __int16 elfFullName[64];
	unsigned __int16 elfStyle[32];
	unsigned int elfVersion;
	unsigned int elfStyleSize;
	unsigned int elfMatch;
	unsigned int elfReserved;
	unsigned __int8 elfVendorId[4];
	unsigned int elfCulture;
	tagPANOSE elfPanose;
};
#pragma pack(pop)

/* 1267 */
#pragma pack(push, 1)
class tagEMREXTCREATEFONTINDIRECTW
{
	tagEMR emr;
	unsigned int ihFont;
	tagEXTLOGFONTW elfw;
};
#pragma pack(pop)

/* 1268 */
#pragma pack(push, 1)
class _CRYPT_KEY_PROV_PARAM
{
	unsigned int dwParam;
	unsigned __int8* pbData;
	unsigned int cbData;
	unsigned int dwFlags;
};
#pragma pack(pop)

/* 1269 */
#pragma pack(push, 1)
class _CRYPT_KEY_PROV_INFO
{
	unsigned __int16* pwszContainerName;
	unsigned __int16* pwszProvName;
	unsigned int dwProvType;
	unsigned int dwFlags;
	unsigned int cProvParam;
	_CRYPT_KEY_PROV_PARAM* rgProvParam;
	unsigned int dwKeySpec;
};
#pragma pack(pop)

/* 1270 */
#pragma pack(push, 1)
class _SID_IDENTIFIER_AUTHORITY
{
	unsigned __int8 Value[6];
};
#pragma pack(pop)

/* 1271 */
#pragma pack(push, 1)
class _IMAGE_BOUND_IMPORT_DESCRIPTOR
{
	unsigned int TimeDateStamp;
	unsigned __int16 OffsetModuleName;
	unsigned __int16 NumberOfModuleForwarderRefs;
};
#pragma pack(pop)

/* 1272 */
#pragma pack(push, 1)
class tagEMROFFSETCLIPRGN
{
	tagEMR emr;
	_POINTL ptlOffset;
};
#pragma pack(pop)

/* 1273 */
#pragma pack(push, 1)
class tagSCROLLINFO
{
	unsigned int cbSize;
	unsigned int fMask;
	int nMin;
	int nMax;
	unsigned int nPage;
	int nPos;
	int nTrackPos;
};
#pragma pack(pop)

/* 1274 */
#pragma pack(push, 1)
class tagREGISTERWORDW
{
	unsigned __int16* lpReading;
	unsigned __int16* lpWord;
};
#pragma pack(pop)

/* 1275 */
#pragma pack(push, 1)
union $44514BD6B8C462303D7502E635917A21
{
	unsigned int hKeyEncryptionKey;
	void* pvKeyEncryptionKey;
};
#pragma pack(pop)

/* 1276 */
#pragma pack(push, 1)
class _CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO
{
	unsigned int cbSize;
	_CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
	void* pvKeyEncryptionAuxInfo;
	unsigned int hCryptProv;
	unsigned int dwKeyChoice;
	$44514BD6B8C462303D7502E635917A21 ___u5;
	_CRYPTOAPI_BLOB KeyId;
	_FILETIME Date;
	_CRYPT_ATTRIBUTE_TYPE_VALUE* pOtherAttr;
};
#pragma pack(pop)

/* 1277 */
#pragma pack(push, 1)
class _LUID
{
	unsigned int LowPart;
	int HighPart;
};
#pragma pack(pop)

/* 1278 */
#pragma pack(push, 1)
class _LUID_AND_ATTRIBUTES
{
	_LUID Luid;
	unsigned int Attributes;
};
#pragma pack(pop)

/* 1279 */
#pragma pack(push, 1)
class tagPOLYTEXTA
{
	int x;
	int y;
	unsigned int n;
	const char* lpstr;
	unsigned int uiFlags;
	tagRECT rcl;
	int* pdx;
};
#pragma pack(pop)

/* 1280 */
#pragma pack(push, 1)
class tagEMRSELECTOBJECT
{
	tagEMR emr;
	unsigned int ihObject;
};
#pragma pack(pop)

/* 1281 */
#pragma pack(push, 1)
class __declspec(align(4)) tagEMRPOLYDRAW
{
	tagEMR emr;
	_RECTL rclBounds;
	unsigned int cptl;
	_POINTL aptl[1];
	unsigned __int8 abTypes[1];
};
#pragma pack(pop)

/* 1282 */
#pragma pack(push, 1)
class tagCOPYDATAclass
{
	unsigned int dwData;
	unsigned int cbData;
	void* lpData;
};
#pragma pack(pop)

/* 1283 */
#pragma pack(push, 1)
class tagREGISTERWORDA
{
	char* lpReading;
	char* lpWord;
};
#pragma pack(pop)

/* 1284 */
#pragma pack(push, 1)
class _IMAGE_FILE_HEADER
{
	unsigned __int16 Machine;
	unsigned __int16 NumberOfSections;
	unsigned int TimeDateStamp;
	unsigned int PointerToSymbolTable;
	unsigned int NumberOfSymbols;
	unsigned __int16 SizeOfOptionalHeader;
	unsigned __int16 Characteristics;
};
#pragma pack(pop)

/* 1285 */
#pragma pack(push, 1)
class _IMAGE_DATA_DIRECTORY
{
	unsigned int VirtualAddress;
	unsigned int Size;
};
#pragma pack(pop)

/* 1286 */
#pragma pack(push, 1)
class _IMAGE_OPTIONAL_HEADER
{
	unsigned __int16 Magic;
	unsigned __int8 MajorLinkerVersion;
	unsigned __int8 MinorLinkerVersion;
	unsigned int SizeOfCode;
	unsigned int SizeOfInitializedData;
	unsigned int SizeOfUninitializedData;
	unsigned int AddressOfEntryPoint;
	unsigned int BaseOfCode;
	unsigned int BaseOfData;
	unsigned int ImageBase;
	unsigned int SectionAlignment;
	unsigned int FileAlignment;
	unsigned __int16 MajorOperatingSystemVersion;
	unsigned __int16 MinorOperatingSystemVersion;
	unsigned __int16 MajorImageVersion;
	unsigned __int16 MinorImageVersion;
	unsigned __int16 MajorSubsystemVersion;
	unsigned __int16 MinorSubsystemVersion;
	unsigned int Win32VersionValue;
	unsigned int SizeOfImage;
	unsigned int SizeOfHeaders;
	unsigned int CheckSum;
	unsigned __int16 Subsystem;
	unsigned __int16 DllCharacteristics;
	unsigned int SizeOfStackReserve;
	unsigned int SizeOfStackCommit;
	unsigned int SizeOfHeapReserve;
	unsigned int SizeOfHeapCommit;
	unsigned int LoaderFlags;
	unsigned int NumberOfRvaAndSizes;
	_IMAGE_DATA_DIRECTORY DataDirectory[16];
};
#pragma pack(pop)

/* 1287 */
#pragma pack(push, 1)
class _IMAGE_NT_HEADERS
{
	unsigned int Signature;
	_IMAGE_FILE_HEADER FileHeader;
	_IMAGE_OPTIONAL_HEADER OptionalHeader;
};
#pragma pack(pop)

/* 1288 */
#pragma pack(push, 1)
union $6C3E4C218082EF99BEEA2E2017022367
{
	unsigned int PhysicalAddress;
	unsigned int VirtualSize;
};
#pragma pack(pop)

/* 1289 */
#pragma pack(push, 1)
class _IMAGE_SECTION_HEADER
{
	unsigned __int8 Name[8];
	$6C3E4C218082EF99BEEA2E2017022367 Misc;
	unsigned int VirtualAddress;
	unsigned int SizeOfRawData;
	unsigned int PointerToRawData;
	unsigned int PointerToRelocations;
	unsigned int PointerToLinenumbers;
	unsigned __int16 NumberOfRelocations;
	unsigned __int16 NumberOfLinenumbers;
	unsigned int Characteristics;
};
#pragma pack(pop)

/* 1290 */
#pragma pack(push, 1)
class _LOADED_IMAGE
{
	char* ModuleName;
	void* hFile;
	unsigned __int8* MappedAddress;
	_IMAGE_NT_HEADERS* FileHeader;
	_IMAGE_SECTION_HEADER* LastRvaSection;
	unsigned int NumberOfSections;
	_IMAGE_SECTION_HEADER* Sections;
	unsigned int Characteristics;
	unsigned __int8 fSystemImage;
	unsigned __int8 fDOSImage;
	__declspec(align(4)) _LIST_ENTRY Links;
	unsigned int SizeOfImage;
};
#pragma pack(pop)

/* 1291 */
#pragma pack(push, 1)
class _IMAGE_BOUND_FORWARDER_REF
{
	unsigned int TimeDateStamp;
	unsigned __int16 OffsetModuleName;
	unsigned __int16 Reserved;
};
#pragma pack(pop)

/* 1292 */
#pragma pack(push, 1)
class tagMINMAXINFO
{
	tagPOINT ptReserved;
	tagPOINT ptMaxSize;
	tagPOINT ptMaxPosition;
	tagPOINT ptMinTrackSize;
	tagPOINT ptMaxTrackSize;
};
#pragma pack(pop)

/* 1293 */
#pragma pack(push, 1)
class _SERVICE_TABLE_ENTRYW
{
	unsigned __int16* lpServiceName;
	void(__stdcall* lpServiceProc)(unsigned int, unsigned __int16**);
};
#pragma pack(pop)

/* 1294 */
#pragma pack(push, 1)
class _JOBOBJECT_END_OF_JOB_TIME_INFORMATION
{
	unsigned int EndOfJobTimeAction;
};
#pragma pack(pop)

/* 1295 */
#pragma pack(push, 1)
class HINSTANCE__
{
	int unused;
};
#pragma pack(pop)

/* 1296 */
#pragma pack(push, 1)
class tagDEBUGHOOKINFO
{
	unsigned int idThread;
	unsigned int idThreadInstaller;
	int lParam;
	unsigned int wParam;
	int code;
};
#pragma pack(pop)

/* 1297 */
#pragma pack(push, 1)
class _CRYPT_SIGN_MESSAGE_PARA
{
	unsigned int cbSize;
	unsigned int dwMsgEncodingType;
	const _CERT_CONTEXT* pSigningCert;
	_CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
	void* pvHashAuxInfo;
	unsigned int cMsgCert;
	const _CERT_CONTEXT** rgpMsgCert;
	unsigned int cMsgCrl;
	const _CRL_CONTEXT** rgpMsgCrl;
	unsigned int cAuthAttr;
	_CRYPT_ATTRIBUTE* rgAuthAttr;
	unsigned int cUnauthAttr;
	_CRYPT_ATTRIBUTE* rgUnauthAttr;
	unsigned int dwFlags;
	unsigned int dwInnerContentType;
};
#pragma pack(pop)

/* 1298 */
#pragma pack(push, 1)
class tagWINDOWINFO
{
	unsigned int cbSize;
	tagRECT rcWindow;
	tagRECT rcClient;
	unsigned int dwStyle;
	unsigned int dwExStyle;
	unsigned int dwWindowStatus;
	unsigned int cxWindowBorders;
	unsigned int cyWindowBorders;
	unsigned __int16 atomWindowType;
	unsigned __int16 wCreatorVersion;
};
#pragma pack(pop)

/* 1299 */
#pragma pack(push, 1)
class _CMSG_KEY_TRANS_RECIPIENT_INFO
{
	unsigned int dwVersion;
	_CERT_ID RecipientId;
	_CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
	_CRYPTOAPI_BLOB EncryptedKey;
};
#pragma pack(pop)

/* 1300 */
#pragma pack(push, 1)
union $BD3DB4AA86CAA71A375F508BBF1007E2
{
	_CERT_ID OriginatorCertId;
	_CERT_PUBLIC_KEY_INFO OriginatorPublicKeyInfo;
};
#pragma pack(pop)

/* 1301 */
#pragma pack(push, 1)
class _CMSG_KEY_AGREE_RECIPIENT_INFO
{
	unsigned int dwVersion;
	unsigned int dwOriginatorChoice;
	$BD3DB4AA86CAA71A375F508BBF1007E2 ___u2;
	_CRYPTOAPI_BLOB UserKeyingMaterial;
	_CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
	unsigned int cRecipientEncryptedKeys;
	_CMSG_RECIPIENT_ENCRYPTED_KEY_INFO** rgpRecipientEncryptedKeys;
};
#pragma pack(pop)

/* 1302 */
#pragma pack(push, 1)
class _CMSG_MAIL_LIST_RECIPIENT_INFO
{
	unsigned int dwVersion;
	_CRYPTOAPI_BLOB KeyId;
	_CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
	_CRYPTOAPI_BLOB EncryptedKey;
	_FILETIME Date;
	_CRYPT_ATTRIBUTE_TYPE_VALUE* pOtherAttr;
};
#pragma pack(pop)

/* 1303 */
#pragma pack(push, 1)
union $478611811A8E74747E39D579A728AFEF
{
	_CMSG_KEY_TRANS_RECIPIENT_INFO* pKeyTrans;
	_CMSG_KEY_AGREE_RECIPIENT_INFO* pKeyAgree;
	_CMSG_MAIL_LIST_RECIPIENT_INFO* pMailList;
};
#pragma pack(pop)

/* 1304 */
#pragma pack(push, 1)
class _CMSG_CMS_RECIPIENT_INFO
{
	unsigned int dwRecipientChoice;
	$478611811A8E74747E39D579A728AFEF ___u1;
};
#pragma pack(pop)

/* 1305 */
#pragma pack(push, 1)
class __declspec(align(8)) _IMAGEHLP_MODULE64
{
	unsigned int SizeOfclass;
	__declspec(align(8)) unsigned __int64 BaseOfImage;
	unsigned int ImageSize;
	unsigned int TimeDateStamp;
	unsigned int CheckSum;
	unsigned int NumSyms;
	SYM_TYPE SymType;
	char ModuleName[32];
	char ImageName[256];
	char LoadedImageName[256];
};
#pragma pack(pop)

/* 1306 */
#pragma pack(push, 1)
class tagRGBTRIPLE
{
	unsigned __int8 rgbtBlue;
	unsigned __int8 rgbtGreen;
	unsigned __int8 rgbtRed;
};
#pragma pack(pop)

/* 1307 */
#pragma pack(push, 1)
class tagEMRSELECTCLIPPATH
{
	tagEMR emr;
	unsigned int iMode;
};
#pragma pack(pop)

/* 1308 */
#pragma pack(push, 1)
class _CERT_CHAIN_FIND_BY_ISSUER_PARA
{
	unsigned int cbSize;
	const char* pszUsageIdentifier;
	unsigned int dwKeySpec;
	unsigned int dwAcquirePrivateKeyFlags;
	unsigned int cIssuer;
	_CRYPTOAPI_BLOB* rgIssuer;
	int(__stdcall* pfnFindCallback)(const _CERT_CONTEXT*, void*);
	void* pvFindArg;
};
#pragma pack(pop)

/* 1309 */
#pragma pack(push, 1)
class _IMAGEHLP_DEFERRED_SYMBOL_LOAD
{
	unsigned int SizeOfclass;
	unsigned int BaseOfImage;
	unsigned int CheckSum;
	unsigned int TimeDateStamp;
	char FileName[260];
	unsigned __int8 Reparse;
	__declspec(align(4)) void* hFile;
};
#pragma pack(pop)

/* 1310 */
#pragma pack(push, 1)
class _COMSTAT
{
	unsigned __int32 fCtsHold : 1;
	unsigned __int32 fDsrHold : 1;
	unsigned __int32 fRlsdHold : 1;
	unsigned __int32 fXoffHold : 1;
	unsigned __int32 fXoffSent : 1;
	unsigned __int32 fEof : 1;
	unsigned __int32 fTxim : 1;
	unsigned __int32 fReserved : 25;
	unsigned int cbInQue;
	unsigned int cbOutQue;
};
#pragma pack(pop)

/* 1311 */
#pragma pack(push, 1)
class __unaligned __declspec(align(2)) DLGITEMTEMPLATE
{
	unsigned int style;
	unsigned int dwExtendedStyle;
	__int16 x;
	__int16 y;
	__int16 cx;
	__int16 cy;
	unsigned __int16 id;
};
#pragma pack(pop)

/* 1312 */
#pragma pack(push, 1)
class _HMAC_Info
{
	unsigned int HashAlgid;
	unsigned __int8* pbInnerString;
	unsigned int cbInnerString;
	unsigned __int8* pbOuterString;
	unsigned int cbOuterString;
};
#pragma pack(pop)

/* 1313 */
#pragma pack(push, 1)
class _CMSG_SIGNER_INFO
{
	unsigned int dwVersion;
	_CRYPTOAPI_BLOB Issuer;
	_CRYPTOAPI_BLOB SerialNumber;
	_CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
	_CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;
	_CRYPTOAPI_BLOB EncryptedHash;
	_CRYPT_ATTRIBUTES AuthAttrs;
	_CRYPT_ATTRIBUTES UnauthAttrs;
};
#pragma pack(pop)

/* 1314 */
#pragma pack(push, 1)
class WINTRUST_SGNR_INFO_
{
	unsigned int cbclass;
	const unsigned __int16* pcwszDisplayName;
	_CMSG_SIGNER_INFO* psSignerInfo;
	unsigned int chStores;
	void** pahStores;
};
#pragma pack(pop)

/* 1315 */
#pragma pack(push, 1)
class _TOKEN_SOURCE
{
	char SourceName[8];
	_LUID SourceIdentifier;
};
#pragma pack(pop)

/* 1316 */
#pragma pack(push, 1)
class _TOKEN_CONTROL
{
	_LUID TokenId;
	_LUID AuthenticationId;
	_LUID ModifiedId;
	_TOKEN_SOURCE TokenSource;
};
#pragma pack(pop)

/* 1317 */
#pragma pack(push, 1)
class _DISPLAY_DEVICEW
{
	unsigned int cb;
	unsigned __int16 DeviceName[32];
	unsigned __int16 DeviceString[128];
	unsigned int StateFlags;
	unsigned __int16 DeviceID[128];
	unsigned __int16 DeviceKey[128];
};
#pragma pack(pop)

/* 1318 */
#pragma pack(push, 1)
class tagABORTPATH
{
	tagEMR emr;
};
#pragma pack(pop)

/* 1319 */
#pragma pack(push, 1)
class _COORD
{
	__int16 X;
	__int16 Y;
};
#pragma pack(pop)

/* 1320 */
#pragma pack(push, 1)
class _SMALL_RECT
{
	__int16 Left;
	__int16 Top;
	__int16 Right;
	__int16 Bottom;
};
#pragma pack(pop)

/* 1321 */
#pragma pack(push, 1)
class _CONSOLE_SCREEN_BUFFER_INFO
{
	_COORD dwSize;
	_COORD dwCursorPosition;
	unsigned __int16 wAttributes;
	_SMALL_RECT srWindow;
	_COORD dwMaximumWindowSize;
};
#pragma pack(pop)

/* 1322 */
#pragma pack(push, 1)
class _CRYPT_OID_FUNC_ENTRY
{
	const char* pszOID;
	void* pvFuncAddr;
};
#pragma pack(pop)

/* 1323 */
#pragma pack(push, 1)
class tagCOLORCORRECTPALETTE
{
	tagEMR emr;
	unsigned int ihPalette;
	unsigned int nFirstEntry;
	unsigned int nPalEntries;
	unsigned int nReserved;
};
#pragma pack(pop)

/* 1324 */
#pragma pack(push, 1)
class HMENU__
{
	int unused;
};
#pragma pack(pop)

/* 1325 */
#pragma pack(push, 1)
class tagCREATEclassA
{
	void* lpCreateParams;
	HINSTANCE__* hInstance;
	HMENU__* hMenu;
	HWND__* hwndParent;
	int cy;
	int cx;
	int y;
	int x;
	int style;
	const char* lpszName;
	const char* lpszClass;
	unsigned int dwExStyle;
};
#pragma pack(pop)

/* 1326 */
#pragma pack(push, 1)
class tagMINIMIZEDMETRICS
{
	unsigned int cbSize;
	int iWidth;
	int iHorzGap;
	int iVertGap;
	int iArrange;
};
#pragma pack(pop)

/* 1327 */
#pragma pack(push, 1)
class _CRYPT_DECRYPT_MESSAGE_PARA
{
	unsigned int cbSize;
	unsigned int dwMsgAndCertEncodingType;
	unsigned int cCertStore;
	void** rghCertStore;
};
#pragma pack(pop)

/* 1328 */
#pragma pack(push, 1)
class _TypeDescriptor
{
	const void* pVFTable;
	void* spare;
	char name[];
};
#pragma pack(pop)

/* 1329 */
#pragma pack(push, 1)
class _PMD
{
	int mdisp;
	int pdisp;
	int vdisp;
};
#pragma pack(pop)

/* 1330 */
#pragma pack(push, 1)
class _s__CatchableType
{
	unsigned int properties;
	_TypeDescriptor* pType;
	_PMD thisDisplacement;
	int sizeOrOffset;
	void(__cdecl* copyFunction)();
};
#pragma pack(pop)

/* 1331 */
#pragma pack(push, 1)
class _s__CatchableTypeArray
{
	int nCatchableTypes;
	const _s__CatchableType* arrayOfCatchableTypes[];
};
#pragma pack(pop)

/* 1332 */
#pragma pack(push, 1)
class tagCIEXYZ
{
	int ciexyzX;
	int ciexyzY;
	int ciexyzZ;
};
#pragma pack(pop)

/* 1333 */
#pragma pack(push, 1)
class tagICEXYZTRIPLE
{
	tagCIEXYZ ciexyzRed;
	tagCIEXYZ ciexyzGreen;
	tagCIEXYZ ciexyzBlue;
};
#pragma pack(pop)

/* 1334 */
#pragma pack(push, 1)
class tagLOGCOLORSPACEW
{
	unsigned int lcsSignature;
	unsigned int lcsVersion;
	unsigned int lcsSize;
	int lcsCSType;
	int lcsIntent;
	tagICEXYZTRIPLE lcsEndpoints;
	unsigned int lcsGammaRed;
	unsigned int lcsGammaGreen;
	unsigned int lcsGammaBlue;
	unsigned __int16 lcsFilename[260];
};
#pragma pack(pop)

/* 1335 */
#pragma pack(push, 1)
class __declspec(align(4)) tagEMRCREATECOLORSPACEW
{
	tagEMR emr;
	unsigned int ihCS;
	tagLOGCOLORSPACEW lcs;
	unsigned int dwFlags;
	unsigned int cbData;
	unsigned __int8 Data[1];
};
#pragma pack(pop)

/* 1336 */
#pragma pack(push, 1)
class _CTL_ENTRY
{
	_CRYPTOAPI_BLOB SubjectIdentifier;
	unsigned int cAttribute;
	_CRYPT_ATTRIBUTE* rgAttribute;
};
#pragma pack(pop)

/* 1337 */
#pragma pack(push, 1)
class _CTL_INFO
{
	unsigned int dwVersion;
	_CTL_USAGE SubjectUsage;
	_CRYPTOAPI_BLOB ListIdentifier;
	_CRYPTOAPI_BLOB SequenceNumber;
	_FILETIME ThisUpdate;
	_FILETIME NextUpdate;
	_CRYPT_ALGORITHM_IDENTIFIER SubjectAlgorithm;
	unsigned int cCTLEntry;
	_CTL_ENTRY* rgCTLEntry;
	unsigned int cExtension;
	_CERT_EXTENSION* rgExtension;
};
#pragma pack(pop)

/* 1338 */
#pragma pack(push, 1)
class _CTL_CONTEXT
{
	unsigned int dwMsgAndCertEncodingType;
	unsigned __int8* pbCtlEncoded;
	unsigned int cbCtlEncoded;
	_CTL_INFO* pCtlInfo;
	void* hCertStore;
	void* hCryptMsg;
	unsigned __int8* pbCtlContent;
	unsigned int cbCtlContent;
};
#pragma pack(pop)

/* 1339 */
#pragma pack(push, 1)
class _CTL_VERIFY_USAGE_STATUS
{
	unsigned int cbSize;
	unsigned int dwError;
	unsigned int dwFlags;
	const _CTL_CONTEXT** ppCtl;
	unsigned int dwCtlEntryIndex;
	const _CERT_CONTEXT** ppSigner;
	unsigned int dwSignerIndex;
};
#pragma pack(pop)

/* 1340 */
#pragma pack(push, 1)
class _CRYPT_BLOB_ARRAY
{
	unsigned int cBlob;
	_CRYPTOAPI_BLOB* rgBlob;
};
#pragma pack(pop)

/* 1341 */
#pragma pack(push, 1)
class _CERT_TRUST_LIST_INFO
{
	unsigned int cbSize;
	_CTL_ENTRY* pCtlEntry;
	const _CTL_CONTEXT* pCtlContext;
};
#pragma pack(pop)

/* 1342 */
#pragma pack(push, 1)
class _CERT_SIMPLE_CHAIN
{
	unsigned int cbSize;
	_CERT_TRUST_STATUS TrustStatus;
	unsigned int cElement;
	_CERT_CHAIN_ELEMENT** rgpElement;
	_CERT_TRUST_LIST_INFO* pTrustListInfo;
	int fHasRevocationFreshnessTime;
	unsigned int dwRevocationFreshnessTime;
};
#pragma pack(pop)

/* 1343 */
#pragma pack(push, 1)
class _CERT_CHAIN_CONTEXT
{
	unsigned int cbSize;
	_CERT_TRUST_STATUS TrustStatus;
	unsigned int cChain;
	_CERT_SIMPLE_CHAIN** rgpChain;
	unsigned int cLowerQualityChainContext;
	const _CERT_CHAIN_CONTEXT** rgpLowerQualityChainContext;
	int fHasRevocationFreshnessTime;
	unsigned int dwRevocationFreshnessTime;
};
#pragma pack(pop)

/* 1344 */
#pragma pack(push, 1)
class __declspec(align(4)) tagEMRFILLRGN
{
	tagEMR emr;
	_RECTL rclBounds;
	unsigned int cbRgnData;
	unsigned int ihBrush;
	unsigned __int8 RgnData[1];
};
#pragma pack(pop)

/* 1345 */
#pragma pack(push, 1)
class tagMULTIKEYHELPW
{
	unsigned int mkSize;
	unsigned __int16 mkKeylist;
	unsigned __int16 szKeyphrase[1];
};
#pragma pack(pop)

/* 1346 */
#pragma pack(push, 1)
class __declspec(align(4)) tagHELPWININFOA
{
	int wclassSize;
	int x;
	int y;
	int dx;
	int dy;
	int wMax;
	char rgchMember[2];
};
#pragma pack(pop)

/* 1347 */
#pragma pack(push, 1)
class tagSIZE
{
	int cx;
	int cy;
};
#pragma pack(pop)

/* 1348 */
#pragma pack(push, 1)
class __declspec(align(4)) tagEMRFRAMERGN
{
	tagEMR emr;
	_RECTL rclBounds;
	unsigned int cbRgnData;
	unsigned int ihBrush;
	tagSIZE szlStroke;
	unsigned __int8 RgnData[1];
};
#pragma pack(pop)

/* 1349 */
#pragma pack(push, 1)
class tagMEASUREITEMclass
{
	unsigned int CtlType;
	unsigned int CtlID;
	unsigned int itemID;
	unsigned int itemWidth;
	unsigned int itemHeight;
	unsigned int itemData;
};
#pragma pack(pop)

/* 1350 */
#pragma pack(push, 1)
class _CERT_LDAP_STORE_OPENED_PARA
{
	void* pvLdapSessionHandle;
	const unsigned __int16* pwszLdapUrl;
};
#pragma pack(pop)

/* 1351 */
#pragma pack(push, 1)
class __declspec(align(4)) _CREATE_PROCESS_DEBUG_INFO
{
	void* hFile;
	void* hProcess;
	void* hThread;
	void* lpBaseOfImage;
	unsigned int dwDebugInfoFileOffset;
	unsigned int nDebugInfoSize;
	void* lpThreadLocalBase;
	unsigned int(__stdcall* lpStartAddress)(void*);
	void* lpImageName;
	unsigned __int16 fUnicode;
};
#pragma pack(pop)

/* 1352 */
#pragma pack(push, 1)
class _CERT_POLICY_QUALIFIER_NOTICE_REFERENCE
{
	char* pszOrganization;
	unsigned int cNoticeNumbers;
	int* rgNoticeNumbers;
};
#pragma pack(pop)

/* 1353 */
#pragma pack(push, 1)
class _CERT_POLICY_QUALIFIER_USER_NOTICE
{
	_CERT_POLICY_QUALIFIER_NOTICE_REFERENCE* pNoticeReference;
	unsigned __int16* pszDisplayText;
};
#pragma pack(pop)

/* 1354 */
#pragma pack(push, 1)
class _IMAGEHLP_MODULEW
{
	unsigned int SizeOfclass;
	unsigned int BaseOfImage;
	unsigned int ImageSize;
	unsigned int TimeDateStamp;
	unsigned int CheckSum;
	unsigned int NumSyms;
	SYM_TYPE SymType;
	unsigned __int16 ModuleName[32];
	unsigned __int16 ImageName[256];
	unsigned __int16 LoadedImageName[256];
};
#pragma pack(pop)

/* 1355 */
#pragma pack(push, 1)
class _ACE_HEADER
{
	unsigned __int8 AceType;
	unsigned __int8 AceFlags;
	unsigned __int16 AceSize;
};
#pragma pack(pop)

/* 1356 */
#pragma pack(push, 1)
class HGLRC__
{
	int unused;
};
#pragma pack(pop)

/* 1357 */
#pragma pack(push, 1)
class tagEMREXCLUDECLIPRECT
{
	tagEMR emr;
	_RECTL rclClip;
};
#pragma pack(pop)

/* 1358 */
#pragma pack(push, 1)
class tagEMRPOLYPOLYLINE
{
	tagEMR emr;
	_RECTL rclBounds;
	unsigned int nPolys;
	unsigned int cptl;
	unsigned int aPolyCounts[1];
	_POINTL aptl[1];
};
#pragma pack(pop)

/* 1359 */
#pragma pack(push, 1)
class tagUSEROBJECTFLAGS
{
	int fInherit;
	int fReserved;
	unsigned int dwFlags;
};
#pragma pack(pop)

/* 1360 */
#pragma pack(push, 1)
class fd_set
{
	unsigned int fd_count;
	unsigned int fd_array[64];
};
#pragma pack(pop)

/* 1361 */
#pragma pack(push, 1)
class _CMSG_CTRL_MAIL_LIST_DECRYPT_PARA
{
	unsigned int cbSize;
	unsigned int hCryptProv;
	_CMSG_MAIL_LIST_RECIPIENT_INFO* pMailList;
	unsigned int dwRecipientIndex;
	unsigned int dwKeyChoice;
	$44514BD6B8C462303D7502E635917A21 ___u5;
};
#pragma pack(pop)

/* 1362 */
#pragma pack(push, 1)
class _NON_PAGED_DEBUG_INFO
{
	unsigned __int16 Signature;
	unsigned __int16 Flags;
	unsigned int Size;
	unsigned __int16 Machine;
	unsigned __int16 Characteristics;
	unsigned int TimeDateStamp;
	unsigned int CheckSum;
	unsigned int SizeOfImage;
	unsigned __int64 ImageBase;
};
#pragma pack(pop)

/* 1363 */
#pragma pack(push, 1)
class _CRYPT_CREDENTIALS
{
	unsigned int cbSize;
	const char* pszCredentialsOid;
	void* pvCredentials;
};
#pragma pack(pop)

/* 1364 */
#pragma pack(push, 1)
class _CRYPT_HASH_INFO
{
	_CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
	_CRYPTOAPI_BLOB Hash;
};
#pragma pack(pop)

/* 1365 */
#pragma pack(push, 1)
class _CERT_OTHER_NAME
{
	char* pszObjId;
	_CRYPTOAPI_BLOB Value;
};
#pragma pack(pop)

/* 1366 */
#pragma pack(push, 1)
union $AAF32AB9CB9DB357A4B3B51DF9B21299
{
	_CERT_OTHER_NAME* pOtherName;
	unsigned __int16* pwszRfc822Name;
	unsigned __int16* pwszDNSName;
	_CRYPTOAPI_BLOB DirectoryName;
	unsigned __int16* pwszURL;
	_CRYPTOAPI_BLOB IPAddress;
	char* pszRegisteredID;
};
#pragma pack(pop)

/* 1367 */
#pragma pack(push, 1)
class _CERT_ALT_NAME_ENTRY
{
	unsigned int dwAltNameChoice;
	$AAF32AB9CB9DB357A4B3B51DF9B21299 ___u1;
};
#pragma pack(pop)

/* 1368 */
#pragma pack(push, 1)
class _CERT_ACCESS_DESCRIPTION
{
	char* pszAccessMethod;
	_CERT_ALT_NAME_ENTRY AccessLocation;
};
#pragma pack(pop)

/* 1369 */
#pragma pack(push, 1)
class WINTRUST_BLOB_INFO_
{
	unsigned int cbclass;
	_GUID gSubject;
	const unsigned __int16* pcwszDisplayName;
	unsigned int cbMemObject;
	unsigned __int8* pbMemObject;
	unsigned int cbMemSignedMsg;
	unsigned __int8* pbMemSignedMsg;
};
#pragma pack(pop)

/* 1370 */
#pragma pack(push, 1)
class HRGN__
{
	int unused;
};
#pragma pack(pop)

/* 1371 */
#pragma pack(push, 1)
class _CERT_SIGNED_CONTENT_INFO
{
	_CRYPTOAPI_BLOB ToBeSigned;
	_CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
	_CRYPT_BIT_BLOB Signature;
};
#pragma pack(pop)

/* 1372 */
#pragma pack(push, 1)
class _CMC_TAGGED_ATTRIBUTE
{
	unsigned int dwBodyPartID;
	_CRYPT_ATTRIBUTE Attribute;
};
#pragma pack(pop)

/* 1373 */
#pragma pack(push, 1)
class _CRYPT_PROVIDER_DEFUSAGE
{
	unsigned int cbclass;
	_GUID gActionID;
	void* pDefPolicyCallbackData;
	void* pDefSIPClientData;
};
#pragma pack(pop)

/* 1374 */
#pragma pack(push, 1)
class _JOBOBJECT_JOBSET_INFORMATION
{
	unsigned int MemberLevel;
};
#pragma pack(pop)

/* 1375 */
#pragma pack(push, 1)
class _WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT
{
	void* hClientToken;
	_GUID* SubjectType;
	void* Subject;
};
#pragma pack(pop)

/* 1376 */
#pragma pack(push, 1)
class $8F5949B57C6E63ECE80FB545D62E839A
{
	unsigned int LowPart;
	int HighPart;
};
#pragma pack(pop)

/* 1377 */
#pragma pack(push, 1)
union _LARGE_INTEGER
{
	$8F5949B57C6E63ECE80FB545D62E839A __s0;
	$8F5949B57C6E63ECE80FB545D62E839A u;
	__int64 QuadPart;
};
#pragma pack(pop)

/* 1378 */
#pragma pack(push, 1)
class CM_Power_Data_s
{
	unsigned int PD_Size;
	_DEVICE_POWER_STATE PD_MostRecentPowerState;
	unsigned int PD_Capabilities;
	unsigned int PD_D1Latency;
	unsigned int PD_D2Latency;
	unsigned int PD_D3Latency;
	_DEVICE_POWER_STATE PD_PowerStateMapping[7];
	_SYSTEM_POWER_STATE PD_DeepestSystemWake;
};
#pragma pack(pop)

/* 1379 */
#pragma pack(push, 1)
class BITMAPV5HEADER
{
	unsigned int bV5Size;
	int bV5Width;
	int bV5Height;
	unsigned __int16 bV5Planes;
	unsigned __int16 bV5BitCount;
	unsigned int bV5Compression;
	unsigned int bV5SizeImage;
	int bV5XPelsPerMeter;
	int bV5YPelsPerMeter;
	unsigned int bV5ClrUsed;
	unsigned int bV5ClrImportant;
	unsigned int bV5RedMask;
	unsigned int bV5GreenMask;
	unsigned int bV5BlueMask;
	unsigned int bV5AlphaMask;
	unsigned int bV5CSType;
	tagICEXYZTRIPLE bV5Endpoints;
	unsigned int bV5GammaRed;
	unsigned int bV5GammaGreen;
	unsigned int bV5GammaBlue;
	unsigned int bV5Intent;
	unsigned int bV5ProfileData;
	unsigned int bV5ProfileSize;
	unsigned int bV5Reserved;
};
#pragma pack(pop)

/* 1380 */
#pragma pack(push, 1)
class tagANIMATIONINFO
{
	unsigned int cbSize;
	int iMinAnimate;
};
#pragma pack(pop)

/* 1381 */
#pragma pack(push, 1)
class _CTL_FIND_USAGE_PARA
{
	unsigned int cbSize;
	_CTL_USAGE SubjectUsage;
	_CRYPTOAPI_BLOB ListIdentifier;
	_CERT_INFO* pSigner;
};
#pragma pack(pop)

/* 1382 */
#pragma pack(push, 1)
class _CTL_FIND_SUBJECT_PARA
{
	unsigned int cbSize;
	_CTL_FIND_USAGE_PARA* pUsagePara;
	unsigned int dwSubjectType;
	void* pvSubject;
};
#pragma pack(pop)

/* 1383 */
#pragma pack(push, 1)
class _MINIDUMP_HANDLE_DATA_STREAM
{
	unsigned int SizeOfHeader;
	unsigned int SizeOfDescriptor;
	unsigned int NumberOfDescriptors;
	unsigned int Reserved;
};
#pragma pack(pop)

/* 1384 */
#pragma pack(push, 1)
class _VIDEOPARAMETERS
{
	_GUID Guid;
	unsigned int dwOffset;
	unsigned int dwCommand;
	unsigned int dwFlags;
	unsigned int dwMode;
	unsigned int dwTVStandard;
	unsigned int dwAvailableModes;
	unsigned int dwAvailableTVStandard;
	unsigned int dwFlickerFilter;
	unsigned int dwOverScanX;
	unsigned int dwOverScanY;
	unsigned int dwMaxUnscaledX;
	unsigned int dwMaxUnscaledY;
	unsigned int dwPositionX;
	unsigned int dwPositionY;
	unsigned int dwBrightness;
	unsigned int dwContrast;
	unsigned int dwCPType;
	unsigned int dwCPCommand;
	unsigned int dwCPStandard;
	unsigned int dwCPKey;
	unsigned int bCP_APSTriggerBits;
	unsigned __int8 bOEMCopyProtection[256];
};
#pragma pack(pop)

/* 1385 */
#pragma pack(push, 1)
class _CMC_TAGGED_CONTENT_INFO
{
	unsigned int dwBodyPartID;
	_CRYPTOAPI_BLOB EncodedContentInfo;
};
#pragma pack(pop)

/* 1386 */
#pragma pack(push, 1)
class _CMC_TAGGED_OTHER_MSG
{
	unsigned int dwBodyPartID;
	char* pszObjId;
	_CRYPTOAPI_BLOB Value;
};
#pragma pack(pop)

/* 1387 */
#pragma pack(push, 1)
class _CMC_RESPONSE_INFO
{
	unsigned int cTaggedAttribute;
	_CMC_TAGGED_ATTRIBUTE* rgTaggedAttribute;
	unsigned int cTaggedContentInfo;
	_CMC_TAGGED_CONTENT_INFO* rgTaggedContentInfo;
	unsigned int cTaggedOtherMsg;
	_CMC_TAGGED_OTHER_MSG* rgTaggedOtherMsg;
};
#pragma pack(pop)

/* 1388 */
#pragma pack(push, 1)
class tagBITMAPCOREHEADER
{
	unsigned int bcSize;
	unsigned __int16 bcWidth;
	unsigned __int16 bcHeight;
	unsigned __int16 bcPlanes;
	unsigned __int16 bcBitCount;
};
#pragma pack(pop)

/* 1389 */
#pragma pack(push, 1)
class __declspec(align(2)) tagBITMAPCOREINFO
{
	tagBITMAPCOREHEADER bmciHeader;
	tagRGBTRIPLE bmciColors[1];
};
#pragma pack(pop)

/* 1390 */
#pragma pack(push, 1)
class tagPIXELFORMATDESCRIPTOR
{
	unsigned __int16 nSize;
	unsigned __int16 nVersion;
	unsigned int dwFlags;
	unsigned __int8 iPixelType;
	unsigned __int8 cColorBits;
	unsigned __int8 cRedBits;
	unsigned __int8 cRedShift;
	unsigned __int8 cGreenBits;
	unsigned __int8 cGreenShift;
	unsigned __int8 cBlueBits;
	unsigned __int8 cBlueShift;
	unsigned __int8 cAlphaBits;
	unsigned __int8 cAlphaShift;
	unsigned __int8 cAccumBits;
	unsigned __int8 cAccumRedBits;
	unsigned __int8 cAccumGreenBits;
	unsigned __int8 cAccumBlueBits;
	unsigned __int8 cAccumAlphaBits;
	unsigned __int8 cDepthBits;
	unsigned __int8 cStencilBits;
	unsigned __int8 cAuxBuffers;
	unsigned __int8 iLayerType;
	unsigned __int8 bReserved;
	unsigned int dwLayerMask;
	unsigned int dwVisibleMask;
	unsigned int dwDamageMask;
};
#pragma pack(pop)

/* 1391 */
#pragma pack(push, 1)
class tagEMRFILLPATH
{
	tagEMR emr;
	_RECTL rclBounds;
};
#pragma pack(pop)

/* 1392 */
#pragma pack(push, 1)
class _WSAPROTOCOLCHAIN
{
	int ChainLen;
	unsigned int ChainEntries[7];
};
#pragma pack(pop)

/* 1393 */
#pragma pack(push, 1)
class _WSAPROTOCOL_INFOA
{
	unsigned int dwServiceFlags1;
	unsigned int dwServiceFlags2;
	unsigned int dwServiceFlags3;
	unsigned int dwServiceFlags4;
	unsigned int dwProviderFlags;
	_GUID ProviderId;
	unsigned int dwCatalogEntryId;
	_WSAPROTOCOLCHAIN ProtocolChain;
	int iVersion;
	int iAddressFamily;
	int iMaxSockAddr;
	int iMinSockAddr;
	int iSocketType;
	int iProtocol;
	int iProtocolMaxOffset;
	int iNetworkByteOrder;
	int iSecurityScheme;
	unsigned int dwMessageSize;
	unsigned int dwProviderReserved;
	char szProtocol[256];
};
#pragma pack(pop)

/* 1394 */
#pragma pack(push, 1)
class WINTRUST_FILE_INFO_
{
	unsigned int cbclass;
	const unsigned __int16* pcwszFilePath;
	void* hFile;
	_GUID* pgKnownSubject;
};
#pragma pack(pop)

/* 1395 */
#pragma pack(push, 1)
class WINTRUST_CATALOG_INFO_
{
	unsigned int cbclass;
	unsigned int dwCatalogVersion;
	const unsigned __int16* pcwszCatalogFilePath;
	const unsigned __int16* pcwszMemberTag;
	const unsigned __int16* pcwszMemberFilePath;
	void* hMemberFile;
	unsigned __int8* pbCalculatedFileHash;
	unsigned int cbCalculatedFileHash;
	const _CTL_CONTEXT* pcCatalogContext;
};
#pragma pack(pop)

/* 1396 */
#pragma pack(push, 1)
class WINTRUST_CERT_INFO_
{
	unsigned int cbclass;
	const unsigned __int16* pcwszDisplayName;
	_CERT_CONTEXT* psCertContext;
	unsigned int chStores;
	void** pahStores;
	unsigned int dwFlags;
	_FILETIME* psftVerifyAsOf;
};
#pragma pack(pop)

/* 1397 */
#pragma pack(push, 1)
union $6E5C438BF0541C6517373E01EE895433
{
	WINTRUST_FILE_INFO_* pFile;
	WINTRUST_CATALOG_INFO_* pCatalog;
	WINTRUST_BLOB_INFO_* pBlob;
	WINTRUST_SGNR_INFO_* pSgnr;
	WINTRUST_CERT_INFO_* pCert;
};
#pragma pack(pop)

/* 1398 */
#pragma pack(push, 1)
class _WINTRUST_DATA
{
	unsigned int cbclass;
	void* pPolicyCallbackData;
	void* pSIPClientData;
	unsigned int dwUIChoice;
	unsigned int fdwRevocationChecks;
	unsigned int dwUnionChoice;
	$6E5C438BF0541C6517373E01EE895433 ___u6;
	unsigned int dwStateAction;
	void* hWVTStateData;
	unsigned __int16* pwszURLReference;
	unsigned int dwProvFlags;
};
#pragma pack(pop)

/* 1399 */
#pragma pack(push, 1)
class _CRYPT_PROVIDER_DATA
{
	unsigned int cbclass;
	_WINTRUST_DATA* pWintrustData;
	int fOpenedFile;
	HWND__* hWndParent;
	_GUID* pgActionID;
	unsigned int hProv;
	unsigned int dwError;
	unsigned int dwRegSecuritySettings;
	unsigned int dwRegPolicySettings;
	_CRYPT_PROVIDER_FUNCTIONS* psPfns;
	unsigned int cdwTrustStepErrors;
	unsigned int* padwTrustStepErrors;
	unsigned int chStores;
	void** pahStores;
	unsigned int dwEncoding;
	void* hMsg;
	unsigned int csSigners;
	_CRYPT_PROVIDER_SGNR* pasSigners;
	unsigned int csProvPrivData;
	_CRYPT_PROVIDER_PRIVDATA* pasProvPrivData;
	unsigned int dwSubjectChoice;
	_PROVDATA_SIP* pPDSip;
	char* pszUsageOID;
	int fRecallWithState;
	_FILETIME sftSystemTime;
	char* pszCTLSignerUsageOID;
	unsigned int dwProvFlags;
	unsigned int dwFinalError;
	_CERT_USAGE_MATCH* pRequestUsage;
	unsigned int dwTrustPubSettings;
};
#pragma pack(pop)

/* 1405 */
#pragma pack(push, 1)
class _CRYPT_PROVIDER_FUNCTIONS
{
	unsigned int cbclass;
	void* (__cdecl* pfnAlloc)(unsigned int);
	void(__cdecl* pfnFree)(void*);
	int(__cdecl* pfnAddStore2Chain)(_CRYPT_PROVIDER_DATA*, void*);
	int(__cdecl* pfnAddSgnr2Chain)(_CRYPT_PROVIDER_DATA*, int, unsigned int, _CRYPT_PROVIDER_SGNR*);
	int(__cdecl* pfnAddCert2Chain)(_CRYPT_PROVIDER_DATA*, unsigned int, int, unsigned int, const _CERT_CONTEXT*);
	int(__cdecl* pfnAddPrivData2Chain)(_CRYPT_PROVIDER_DATA*, _CRYPT_PROVIDER_PRIVDATA*);
	HRESULT(__cdecl* pfnInitialize)(_CRYPT_PROVIDER_DATA*);
	HRESULT(__cdecl* pfnObjectTrust)(_CRYPT_PROVIDER_DATA*);
	HRESULT(__cdecl* pfnSignatureTrust)(_CRYPT_PROVIDER_DATA*);
	HRESULT(__cdecl* pfnCertificateTrust)(_CRYPT_PROVIDER_DATA*);
	HRESULT(__cdecl* pfnFinalPolicy)(_CRYPT_PROVIDER_DATA*);
	int(__cdecl* pfnCertCheckPolicy)(_CRYPT_PROVIDER_DATA*, unsigned int, int, unsigned int);
	HRESULT(__cdecl* pfnTestFinalPolicy)(_CRYPT_PROVIDER_DATA*);
	_CRYPT_PROVUI_FUNCS* psUIpfns;
	HRESULT(__cdecl* pfnCleanupPolicy)(_CRYPT_PROVIDER_DATA*);
};
#pragma pack(pop)

/* 1401 */
#pragma pack(push, 1)
class _CRYPT_PROVIDER_SGNR
{
	unsigned int cbclass;
	_FILETIME sftVerifyAsOf;
	unsigned int csCertChain;
	_CRYPT_PROVIDER_CERT* pasCertChain;
	unsigned int dwSignerType;
	_CMSG_SIGNER_INFO* psSigner;
	unsigned int dwError;
	unsigned int csCounterSigners;
	_CRYPT_PROVIDER_SGNR* pasCounterSigners;
	const _CERT_CHAIN_CONTEXT* pChainContext;
};
#pragma pack(pop)

/* 1402 */
#pragma pack(push, 1)
class _CRYPT_PROVIDER_PRIVDATA
{
	unsigned int cbclass;
	_GUID gProviderID;
	unsigned int cbProvData;
	void* pvProvData;
};
#pragma pack(pop)

/* 1406 */
#pragma pack(push, 1)
class _PROVDATA_SIP
{
	unsigned int cbclass;
	_GUID gSubject;
	class SIP_DISPATCH_INFO_* pSip;
	class SIP_DISPATCH_INFO_* pCATSip;
	class SIP_SUBJECTINFO_* psSipSubjectInfo;
	class SIP_SUBJECTINFO_* psSipCATSubjectInfo;
	class SIP_INDIRECT_DATA_* psIndirectData;
};
#pragma pack(pop)

/* 1407 */
#pragma pack(push, 1)
class _CERT_USAGE_MATCH
{
	unsigned int dwType;
	_CTL_USAGE Usage;
};
#pragma pack(pop)

/* 1404 */
#pragma pack(push, 1)
class _CRYPT_PROVUI_FUNCS
{
	unsigned int cbclass;
	_CRYPT_PROVUI_DATA* psUIData;
	int(__cdecl* pfnOnMoreInfoClick)(HWND__*, _CRYPT_PROVIDER_DATA*);
	int(__cdecl* pfnOnMoreInfoClickDefault)(HWND__*, _CRYPT_PROVIDER_DATA*);
	int(__cdecl* pfnOnAdvancedClick)(HWND__*, _CRYPT_PROVIDER_DATA*);
	int(__cdecl* pfnOnAdvancedClickDefault)(HWND__*, _CRYPT_PROVIDER_DATA*);
};
#pragma pack(pop)

/* 1400 */
#pragma pack(push, 1)
class _CRYPT_PROVIDER_CERT
{
	unsigned int cbclass;
	const _CERT_CONTEXT* pCert;
	int fCommercial;
	int fTrustedRoot;
	int fSelfSigned;
	int fTestCert;
	unsigned int dwRevokedReason;
	unsigned int dwConfidence;
	unsigned int dwError;
	_CTL_CONTEXT* pTrustListContext;
	int fTrustListSignerCert;
	const _CTL_CONTEXT* pCtlContext;
	unsigned int dwCtlError;
	int fIsCyclic;
	_CERT_CHAIN_ELEMENT* pChainElement;
};
#pragma pack(pop)

/* 1403 */
#pragma pack(push, 1)
class _CRYPT_PROVUI_DATA
{
	unsigned int cbclass;
	unsigned int dwFinalError;
	unsigned __int16* pYesButtonText;
	unsigned __int16* pNoButtonText;
	unsigned __int16* pMoreInfoButtonText;
	unsigned __int16* pAdvancedLinkText;
	unsigned __int16* pCopyActionText;
	unsigned __int16* pCopyActionTextNoTS;
	unsigned __int16* pCopyActionTextNotSigned;
};
#pragma pack(pop)

/* 1408 */
#pragma pack(push, 1)
class _MINIDUMP_EXCEPTION
{
	unsigned int ExceptionCode;
	unsigned int ExceptionFlags;
	unsigned __int64 ExceptionRecord;
	unsigned __int64 ExceptionAddress;
	unsigned int NumberParameters;
	unsigned int __unusedAlignment;
	unsigned __int64 ExceptionInformation[15];
};
#pragma pack(pop)

/* 1409 */
#pragma pack(push, 1)
class _MINIDUMP_LOCATION_DESCRIPTOR
{
	unsigned int DataSize;
	unsigned int Rva;
};
#pragma pack(pop)

/* 1410 */
#pragma pack(push, 1)
class MINIDUMP_EXCEPTION_STREAM
{
	unsigned int ThreadId;
	unsigned int __alignment;
	_MINIDUMP_EXCEPTION ExceptionRecord;
	_MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
};
#pragma pack(pop)

/* 1411 */
#pragma pack(push, 1)
class _FLOAT128
{
	__int64 LowPart;
	__int64 HighPart;
};
#pragma pack(pop)

/* 1412 */
#pragma pack(push, 1)
class $5D52FF973EE5B8C4EFF70C329B5F96F2
{
	unsigned __int8 BaseMid;
	unsigned __int8 Flags1;
	unsigned __int8 Flags2;
	unsigned __int8 BaseHi;
};
#pragma pack(pop)

/* 1413 */
#pragma pack(push, 1)
class $16668D611EE0C2028AE3EC88D2F6339F
{
	unsigned __int32 BaseMid : 8;
	unsigned __int32 Type : 5;
	unsigned __int32 Dpl : 2;
	unsigned __int32 Pres : 1;
	unsigned __int32 LimitHi : 4;
	unsigned __int32 Sys : 1;
	unsigned __int32 Reserved_0 : 1;
	unsigned __int32 Default_Big : 1;
	unsigned __int32 Granularity : 1;
	unsigned __int32 BaseHi : 8;
};
#pragma pack(pop)

/* 1414 */
#pragma pack(push, 1)
union $F3A845D068C72D07E232505880AA3A29
{
	$5D52FF973EE5B8C4EFF70C329B5F96F2 Bytes;
	$16668D611EE0C2028AE3EC88D2F6339F Bits;
};
#pragma pack(pop)

/* 1415 */
#pragma pack(push, 1)
class _LDT_ENTRY
{
	unsigned __int16 LimitLow;
	unsigned __int16 BaseLow;
	$F3A845D068C72D07E232505880AA3A29 HighWord;
};
#pragma pack(pop)

/* 1416 */
#pragma pack(push, 1)
class __declspec(align(8)) _JOBOBJECT_BASIC_LIMIT_INFORMATION
{
	_LARGE_INTEGER PerProcessUserTimeLimit;
	_LARGE_INTEGER PerJobUserTimeLimit;
	unsigned int LimitFlags;
	unsigned int MinimumWorkingSetSize;
	unsigned int MaximumWorkingSetSize;
	unsigned int ActiveProcessLimit;
	unsigned int Affinity;
	unsigned int PriorityClass;
	unsigned int SchedulingClass;
};
#pragma pack(pop)

/* 1417 */
#pragma pack(push, 1)
class __unaligned __declspec(align(2)) tagMETAHEADER
{
	unsigned __int16 mtType;
	unsigned __int16 mtHeaderSize;
	unsigned __int16 mtVersion;
	unsigned int mtSize;
	unsigned __int16 mtNoObjects;
	unsigned int mtMaxRecord;
	unsigned __int16 mtNoParameters;
};
#pragma pack(pop)

/* 1418 */
#pragma pack(push, 1)
class HICON__
{
	int unused;
};
#pragma pack(pop)

/* 1419 */
#pragma pack(push, 1)
class HBRUSH__
{
	int unused;
};
#pragma pack(pop)

/* 1420 */
#pragma pack(push, 1)
class tagWNDCLASSEXA
{
	unsigned int cbSize;
	unsigned int style;
	int(__stdcall* lpfnWndProc)(HWND__*, unsigned int, unsigned int, int);
	int cbClsExtra;
	int cbWndExtra;
	HINSTANCE__* hInstance;
	HICON__* hIcon;
	HICON__* hCursor;
	HBRUSH__* hbrBackground;
	const char* lpszMenuName;
	const char* lpszClassName;
	HICON__* hIconSm;
};
#pragma pack(pop)

/* 1421 */
#pragma pack(push, 1)
class _CRYPT_SMIME_CAPABILITY
{
	char* pszObjId;
	_CRYPTOAPI_BLOB Parameters;
};
#pragma pack(pop)

/* 1422 */
#pragma pack(push, 1)
class _CRYPT_SMIME_CAPABILITIES
{
	unsigned int cCapability;
	_CRYPT_SMIME_CAPABILITY* rgCapability;
};
#pragma pack(pop)

/* 1423 */
#pragma pack(push, 1)
class _AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA
{
	unsigned int cbSize;
	unsigned int dwRegPolicySettings;
	int fCommercial;
};
#pragma pack(pop)

/* 1424 */
#pragma pack(push, 1)
class HKL__
{
	int unused;
};
#pragma pack(pop)

/* 1425 */
#pragma pack(push, 1)
class tagLOGFONTA
{
	int lfHeight;
	int lfWidth;
	int lfEscapement;
	int lfOrientation;
	int lfWeight;
	unsigned __int8 lfItalic;
	unsigned __int8 lfUnderline;
	unsigned __int8 lfStrikeOut;
	unsigned __int8 lfCharSet;
	unsigned __int8 lfOutPrecision;
	unsigned __int8 lfClipPrecision;
	unsigned __int8 lfQuality;
	unsigned __int8 lfPitchAndFamily;
	char lfFaceName[32];
};
#pragma pack(pop)

/* 1426 */
#pragma pack(push, 1)
class tagCWPRETclass
{
	int lResult;
	int lParam;
	unsigned int wParam;
	unsigned int message;
	HWND__* hwnd;
};
#pragma pack(pop)

/* 1427 */
#pragma pack(push, 1)
class HIMCC__
{
	int unused;
};
#pragma pack(pop)

/* 1428 */
#pragma pack(push, 1)
class _MEMORY_BASIC_INFORMATION32
{
	unsigned int BaseAddress;
	unsigned int AllocationBase;
	unsigned int AllocationProtect;
	unsigned int RegionSize;
	unsigned int State;
	unsigned int Protect;
	unsigned int Type;
};
#pragma pack(pop)

/* 1429 */
#pragma pack(push, 1)
class tagENHMETARECORD
{
	unsigned int iType;
	unsigned int nSize;
	unsigned int dParm[1];
};
#pragma pack(pop)

/* 1430 */
#pragma pack(push, 1)
class __declspec(align(4)) tagTEXTMETRICA
{
	int tmHeight;
	int tmAscent;
	int tmDescent;
	int tmInternalLeading;
	int tmExternalLeading;
	int tmAveCharWidth;
	int tmMaxCharWidth;
	int tmWeight;
	int tmOverhang;
	int tmDigitizedAspectX;
	int tmDigitizedAspectY;
	unsigned __int8 tmFirstChar;
	unsigned __int8 tmLastChar;
	unsigned __int8 tmDefaultChar;
	unsigned __int8 tmBreakChar;
	unsigned __int8 tmItalic;
	unsigned __int8 tmUnderlined;
	unsigned __int8 tmStruckOut;
	unsigned __int8 tmPitchAndFamily;
	unsigned __int8 tmCharSet;
};
#pragma pack(pop)

/* 1431 */
#pragma pack(push, 1)
class _MINIDUMP_FUNCTION_TABLE_DESCRIPTOR
{
	unsigned __int64 MinimumAddress;
	unsigned __int64 MaximumAddress;
	unsigned __int64 BaseAddress;
	unsigned int EntryCount;
	unsigned int SizeOfAlignPad;
};
#pragma pack(pop)

/* 1432 */
#pragma pack(push, 1)
class HWINSTA__
{
	int unused;
};
#pragma pack(pop)

/* 1433 */
#pragma pack(push, 1)
class _OFclass
{
	unsigned __int8 cBytes;
	unsigned __int8 fFixedDisk;
	unsigned __int16 nErrCode;
	unsigned __int16 Reserved1;
	unsigned __int16 Reserved2;
	char szPathName[128];
};
#pragma pack(pop)

/* 1434 */
#pragma pack(push, 1)
class _FIXED
{
	unsigned __int16 fract;
	__int16 value;
};
#pragma pack(pop)

/* 1435 */
#pragma pack(push, 1)
class _MAT2
{
	_FIXED eM11;
	_FIXED eM12;
	_FIXED eM21;
	_FIXED eM22;
};
#pragma pack(pop)

/* 1436 */
#pragma pack(push, 1)
class __declspec(align(4)) tagEMRNAMEDESCAPE
{
	tagEMR emr;
	int iEscape;
	int cbDriver;
	int cbEscData;
	unsigned __int8 EscData[1];
};
#pragma pack(pop)

/* 1437 */
#pragma pack(push, 1)
class tagHELPINFO
{
	unsigned int cbSize;
	int iContextType;
	int iCtrlId;
	void* hItemHandle;
	unsigned int dwContextId;
	tagPOINT MousePos;
};
#pragma pack(pop)

/* 1438 */
#pragma pack(push, 1)
class tagMSGBOXPARAMSA
{
	unsigned int cbSize;
	HWND__* hwndOwner;
	HINSTANCE__* hInstance;
	const char* lpszText;
	const char* lpszCaption;
	unsigned int dwStyle;
	const char* lpszIcon;
	unsigned int dwContextHelpId;
	void(__stdcall* lpfnMsgBoxCallback)(tagHELPINFO*);
	unsigned int dwLanguageId;
};
#pragma pack(pop)

/* 1439 */
#pragma pack(push, 1)
class tagCLIENTCREATEclass
{
	void* hWindowMenu;
	unsigned int idFirstChild;
};
#pragma pack(pop)

/* 1440 */
#pragma pack(push, 1)
class __declspec(align(4)) _IMAGEHLP_SYMBOL64
{
	unsigned int SizeOfclass;
	__declspec(align(8)) unsigned __int64 Address;
	unsigned int Size;
	unsigned int Flags;
	unsigned int MaxNameLength;
	char Name[1];
};
#pragma pack(pop)

/* 1441 */
#pragma pack(push, 1)
class _OUTPUT_DEBUG_STRING_INFO
{
	char* lpDebugStringData;
	unsigned __int16 fUnicode;
	unsigned __int16 nDebugStringLength;
};
#pragma pack(pop)

/* 1442 */
#pragma pack(push, 1)
class tagEVENTMSG
{
	unsigned int message;
	unsigned int paramL;
	unsigned int paramH;
	unsigned int time;
	HWND__* hwnd;
};
#pragma pack(pop)

/* 1443 */
#pragma pack(push, 1)
class _UNIVERSAL_NAME_INFOA
{
	char* lpUniversalName;
};
#pragma pack(pop)

/* 1444 */
#pragma pack(push, 1)
class _IMAGE_OPTIONAL_HEADER64
{
	unsigned __int16 Magic;
	unsigned __int8 MajorLinkerVersion;
	unsigned __int8 MinorLinkerVersion;
	unsigned int SizeOfCode;
	unsigned int SizeOfInitializedData;
	unsigned int SizeOfUninitializedData;
	unsigned int AddressOfEntryPoint;
	unsigned int BaseOfCode;
	unsigned __int64 ImageBase;
	unsigned int SectionAlignment;
	unsigned int FileAlignment;
	unsigned __int16 MajorOperatingSystemVersion;
	unsigned __int16 MinorOperatingSystemVersion;
	unsigned __int16 MajorImageVersion;
	unsigned __int16 MinorImageVersion;
	unsigned __int16 MajorSubsystemVersion;
	unsigned __int16 MinorSubsystemVersion;
	unsigned int Win32VersionValue;
	unsigned int SizeOfImage;
	unsigned int SizeOfHeaders;
	unsigned int CheckSum;
	unsigned __int16 Subsystem;
	unsigned __int16 DllCharacteristics;
	unsigned __int64 SizeOfStackReserve;
	unsigned __int64 SizeOfStackCommit;
	unsigned __int64 SizeOfHeapReserve;
	unsigned __int64 SizeOfHeapCommit;
	unsigned int LoaderFlags;
	unsigned int NumberOfRvaAndSizes;
	_IMAGE_DATA_DIRECTORY DataDirectory[16];
};
#pragma pack(pop)

/* 1445 */
#pragma pack(push, 1)
class tagEMRSETVIEWPORTEXTEX
{
	tagEMR emr;
	tagSIZE szlExtent;
};
#pragma pack(pop)

/* 1446 */
#pragma pack(push, 1)
class tagTRACKMOUSEEVENT
{
	unsigned int cbSize;
	unsigned int dwFlags;
	HWND__* hwndTrack;
	unsigned int dwHoverTime;
};
#pragma pack(pop)

/* 1447 */
#pragma pack(push, 1)
class tagCOMBOBOXINFO
{
	unsigned int cbSize;
	tagRECT rcItem;
	tagRECT rcButton;
	unsigned int stateButton;
	HWND__* hwndCombo;
	HWND__* hwndItem;
	HWND__* hwndList;
};
#pragma pack(pop)

/* 1448 */
#pragma pack(push, 1)
const class _s__RTTIBaseClassDescriptor
{
	_TypeDescriptor* pTypeDescriptor;
	unsigned int numContainedBases;
	_PMD where;
	unsigned int attributes;
};
#pragma pack(pop)

/* 1449 */
#pragma pack(push, 1)
const class __unaligned __declspec(align(1)) _s__RTTIBaseClassArray
{
	const _s__RTTIBaseClassDescriptor* arrayOfBaseClassDescriptors[];
};
#pragma pack(pop)

/* 1450 */
#pragma pack(push, 1)
class _s__RTTIClassHierarchyDescriptor
{
	unsigned int signature;
	unsigned int attributes;
	unsigned int numBaseClasses;
	const _s__RTTIBaseClassArray* pBaseClassArray;
};
#pragma pack(pop)

/* 1451 */
#pragma pack(push, 1)
class _s__RTTICompleteObjectLocator
{
	unsigned int signature;
	unsigned int offset;
	unsigned int cdOffset;
	_TypeDescriptor* pTypeDescriptor;
	const _s__RTTIClassHierarchyDescriptor* pClassDescriptor;
};
#pragma pack(pop)

/* 1452 */
#pragma pack(push, 1)
class $F6F6B771D28F56CF8230860379CA5475
{
	unsigned __int16 Linenumber;
	unsigned __int16 Size;
};
#pragma pack(pop)

/* 1453 */
#pragma pack(push, 1)
union $0CC27D745363019A2F31E8654C024AAB
{
	$F6F6B771D28F56CF8230860379CA5475 LnSz;
	unsigned int TotalSize;
};
#pragma pack(pop)

/* 1454 */
#pragma pack(push, 1)
class $C22CCCB59BAB498242CAB4879A986C2C
{
	unsigned int PointerToLinenumber;
	unsigned int PointerToNextFunction;
};
#pragma pack(pop)

/* 1455 */
#pragma pack(push, 1)
class $796BE606B5416B0A58238B2FE25AC6C2
{
	unsigned __int16 Dimension[4];
};
#pragma pack(pop)

/* 1456 */
#pragma pack(push, 1)
union $CF83064ADDD0E5F2BFD9C9F2BB0F4480
{
	$C22CCCB59BAB498242CAB4879A986C2C Function;
	$796BE606B5416B0A58238B2FE25AC6C2 Array;
};
#pragma pack(pop)

/* 1457 */
#pragma pack(push, 1)
class __unaligned __declspec(align(2)) $3A5C72EFA68395EAE0B5ED9BA3AE568B
{
	unsigned int TagIndex;
	$0CC27D745363019A2F31E8654C024AAB Misc;
	$CF83064ADDD0E5F2BFD9C9F2BB0F4480 FcnAry;
	unsigned __int16 TvIndex;
};
#pragma pack(pop)

/* 1458 */
#pragma pack(push, 1)
class $9FEEED0EF4880E6EAD23163C50932975
{
	unsigned __int8 Name[18];
};
#pragma pack(pop)

/* 1459 */
#pragma pack(push, 1)
class __declspec(align(2)) $9F4D4D9025C72CED31C72631A5FB5D1B
{
	unsigned int Length;
	unsigned __int16 NumberOfRelocations;
	unsigned __int16 NumberOfLinenumbers;
	unsigned int CheckSum;
	__int16 Number;
	unsigned __int8 Selection;
};
#pragma pack(pop)

/* 1460 */
#pragma pack(push, 1)
union _IMAGE_AUX_SYMBOL
{
	$3A5C72EFA68395EAE0B5ED9BA3AE568B Sym;
	$9FEEED0EF4880E6EAD23163C50932975 File;
	$9F4D4D9025C72CED31C72631A5FB5D1B Section;
};
#pragma pack(pop)

/* 1461 */
#pragma pack(push, 1)
class _BY_HANDLE_FILE_INFORMATION
{
	unsigned int dwFileAttributes;
	_FILETIME ftCreationTime;
	_FILETIME ftLastAccessTime;
	_FILETIME ftLastWriteTime;
	unsigned int dwVolumeSerialNumber;
	unsigned int nFileSizeHigh;
	unsigned int nFileSizeLow;
	unsigned int nNumberOfLinks;
	unsigned int nFileIndexHigh;
	unsigned int nFileIndexLow;
};
#pragma pack(pop)

/* 1462 */
#pragma pack(push, 1)
class _STARTUPINFOA
{
	unsigned int cb;
	char* lpReserved;
	char* lpDesktop;
	char* lpTitle;
	unsigned int dwX;
	unsigned int dwY;
	unsigned int dwXSize;
	unsigned int dwYSize;
	unsigned int dwXCountChars;
	unsigned int dwYCountChars;
	unsigned int dwFillAttribute;
	unsigned int dwFlags;
	unsigned __int16 wShowWindow;
	unsigned __int16 cbReserved2;
	unsigned __int8* lpReserved2;
	void* hStdInput;
	void* hStdOutput;
	void* hStdError;
};
#pragma pack(pop)

/* 1463 */
#pragma pack(push, 1)
class _CRYPT_X942_OTHER_INFO
{
	char* pszContentEncryptionObjId;
	unsigned __int8 rgbCounter[4];
	unsigned __int8 rgbKeyLength[4];
	_CRYPTOAPI_BLOB PubInfo;
};
#pragma pack(pop)

/* 1464 */
#pragma pack(push, 1)
class _EVENTLOGRECORD
{
	unsigned int Length;
	unsigned int Reserved;
	unsigned int RecordNumber;
	unsigned int TimeGenerated;
	unsigned int TimeWritten;
	unsigned int EventID;
	unsigned __int16 EventType;
	unsigned __int16 NumStrings;
	unsigned __int16 EventCategory;
	unsigned __int16 ReservedFlags;
	unsigned int ClosingRecordNumber;
	unsigned int StringOffset;
	unsigned int UserSidLength;
	unsigned int UserSidOffset;
	unsigned int DataLength;
	unsigned int DataOffset;
};
#pragma pack(pop)

/* 1465 */
#pragma pack(push, 1)
class tagSTYLEclass
{
	unsigned int styleOld;
	unsigned int styleNew;
};
#pragma pack(pop)

/* 1466 */
#pragma pack(push, 1)
class _cpinfoexA
{
	unsigned int MaxCharSize;
	unsigned __int8 DefaultChar[2];
	unsigned __int8 LeadByte[12];
	unsigned __int16 UnicodeDefaultChar;
	unsigned int CodePage;
	char CodePageName[260];
};
#pragma pack(pop)

/* 1467 */
#pragma pack(push, 1)
class _MINIDUMP_MEMORY_DESCRIPTOR
{
	unsigned __int64 StartOfMemoryRange;
	_MINIDUMP_LOCATION_DESCRIPTOR Memory;
};
#pragma pack(pop)

/* 1468 */
#pragma pack(push, 1)
class HMONITOR__
{
	int unused;
};
#pragma pack(pop)

/* 1469 */
#pragma pack(push, 1)
class tagEMRMODIFYWORLDTRANSFORM
{
	tagEMR emr;
	tagXFORM xform;
	unsigned int iMode;
};
#pragma pack(pop)

/* 1470 */
#pragma pack(push, 1)
class __declspec(align(4)) tagEXTLOGFONTA
{
	tagLOGFONTA elfLogFont;
	unsigned __int8 elfFullName[64];
	unsigned __int8 elfStyle[32];
	unsigned int elfVersion;
	unsigned int elfStyleSize;
	unsigned int elfMatch;
	unsigned int elfReserved;
	unsigned __int8 elfVendorId[4];
	unsigned int elfCulture;
	tagPANOSE elfPanose;
};
#pragma pack(pop)

/* 1471 */
#pragma pack(push, 1)
class HBITMAP__
{
	int unused;
};
#pragma pack(pop)

/* 1472 */
#pragma pack(push, 1)
class tagMENUITEMINFOA
{
	unsigned int cbSize;
	unsigned int fMask;
	unsigned int fType;
	unsigned int fState;
	unsigned int wID;
	HMENU__* hSubMenu;
	HBITMAP__* hbmpChecked;
	HBITMAP__* hbmpUnchecked;
	unsigned int dwItemData;
	char* dwTypeData;
	unsigned int cch;
	HBITMAP__* hbmpItem;
};
#pragma pack(pop)

/* 1473 */
#pragma pack(push, 1)
class _CERT_ALT_NAME_INFO
{
	unsigned int cAltEntry;
	_CERT_ALT_NAME_ENTRY* rgAltEntry;
};
#pragma pack(pop)

/* 1474 */
#pragma pack(push, 1)
class _IMAGE_FUNCTION_ENTRY
{
	unsigned int StartingAddress;
	unsigned int EndingAddress;
	unsigned int EndOfPrologue;
};
#pragma pack(pop)

/* 1475 */
#pragma pack(push, 1)
class _FPO_DATA
{
	unsigned int ulOffStart;
	unsigned int cbProcSize;
	unsigned int cdwLocals;
	unsigned __int16 cdwParams;
	unsigned __int16 cbProlog : 8;
	unsigned __int16 cbRegs : 3;
	unsigned __int16 fHasSEH : 1;
	unsigned __int16 fUseBP : 1;
	unsigned __int16 reserved : 1;
	unsigned __int16 cbFrame : 2;
};
#pragma pack(pop)

/* 1476 */
#pragma pack(push, 1)
class _IMAGE_COFF_SYMBOLS_HEADER
{
	unsigned int NumberOfSymbols;
	unsigned int LvaToFirstSymbol;
	unsigned int NumberOfLinenumbers;
	unsigned int LvaToFirstLinenumber;
	unsigned int RvaToFirstByteOfCode;
	unsigned int RvaToLastByteOfCode;
	unsigned int RvaToFirstByteOfData;
	unsigned int RvaToLastByteOfData;
};
#pragma pack(pop)

/* 1477 */
#pragma pack(push, 1)
class _IMAGE_DEBUG_DIRECTORY
{
	unsigned int Characteristics;
	unsigned int TimeDateStamp;
	unsigned __int16 MajorVersion;
	unsigned __int16 MinorVersion;
	unsigned int Type;
	unsigned int SizeOfData;
	unsigned int AddressOfRawData;
	unsigned int PointerToRawData;
};
#pragma pack(pop)

/* 1478 */
#pragma pack(push, 1)
class _IMAGE_DEBUG_INFORMATION
{
	_LIST_ENTRY List;
	unsigned int ReservedSize;
	void* ReservedMappedBase;
	unsigned __int16 ReservedMachine;
	unsigned __int16 ReservedCharacteristics;
	unsigned int ReservedCheckSum;
	unsigned int ImageBase;
	unsigned int SizeOfImage;
	unsigned int ReservedNumberOfSections;
	_IMAGE_SECTION_HEADER* ReservedSections;
	unsigned int ReservedExportedNamesSize;
	char* ReservedExportedNames;
	unsigned int ReservedNumberOfFunctionTableEntries;
	_IMAGE_FUNCTION_ENTRY* ReservedFunctionTableEntries;
	unsigned int ReservedLowestFunctionStartingAddress;
	unsigned int ReservedHighestFunctionEndingAddress;
	unsigned int ReservedNumberOfFpoTableEntries;
	_FPO_DATA* ReservedFpoTableEntries;
	unsigned int SizeOfCoffSymbols;
	_IMAGE_COFF_SYMBOLS_HEADER* CoffSymbols;
	unsigned int ReservedSizeOfCodeViewSymbols;
	void* ReservedCodeViewSymbols;
	char* ImageFilePath;
	char* ImageFileName;
	char* ReservedDebugFilePath;
	unsigned int ReservedTimeDateStamp;
	int ReservedRomImage;
	_IMAGE_DEBUG_DIRECTORY* ReservedDebugDirectory;
	unsigned int ReservedNumberOfDebugDirectories;
	unsigned int ReservedOriginalFunctionTableBaseAddress;
	unsigned int Reserved[2];
};
#pragma pack(pop)

/* 1479 */
#pragma pack(push, 1)
class _currencyfmtW
{
	unsigned int NumDigits;
	unsigned int LeadingZero;
	unsigned int Grouping;
	unsigned __int16* lpDecimalSep;
	unsigned __int16* lpThousandSep;
	unsigned int NegativeOrder;
	unsigned int PositiveOrder;
	unsigned __int16* lpCurrencySymbol;
};
#pragma pack(pop)

/* 1480 */
#pragma pack(push, 1)
class _CERT_BASIC_CONSTRAINTS2_INFO
{
	int fCA;
	int fPathLenConstraint;
	unsigned int dwPathLenConstraint;
};
#pragma pack(pop)

/* 1481 */
#pragma pack(push, 1)
class _ACL
{
	unsigned __int8 AclRevision;
	unsigned __int8 Sbz1;
	unsigned __int16 AclSize;
	unsigned __int16 AceCount;
	unsigned __int16 Sbz2;
};
#pragma pack(pop)

/* 1482 */
#pragma pack(push, 1)
class _TOKEN_DEFAULT_DACL
{
	_ACL* DefaultDacl;
};
#pragma pack(pop)

/* 1483 */
#pragma pack(push, 1)
class $B8E2662BAB43A69365F9E734CDDDBD93
{
	__int16 dmOrientation;
	__int16 dmPaperSize;
	__int16 dmPaperLength;
	__int16 dmPaperWidth;
};
#pragma pack(pop)

/* 1484 */
#pragma pack(push, 1)
union $B214638B2B9F4E804A25A19C0B009811
{
	$B8E2662BAB43A69365F9E734CDDDBD93 __s0;
	_POINTL dmPosition;
};
#pragma pack(pop)

/* 1485 */
#pragma pack(push, 1)
class $D1199E00CB9318452C99AE2CCF47AE6F
{
	__int16 dmScale;
	__int16 dmCopies;
};
#pragma pack(pop)

/* 1486 */
#pragma pack(push, 1)
union $4AE569E07E0C6BDAC050E3B1D58D39AB
{
	$D1199E00CB9318452C99AE2CCF47AE6F __s0;
	unsigned int dmDisplayOrientation;
};
#pragma pack(pop)

/* 1487 */
#pragma pack(push, 1)
class $43C84CF5DE546375E345C5C327562B81
{
	__int16 dmDefaultSource;
	__int16 dmPrintQuality;
};
#pragma pack(pop)

/* 1488 */
#pragma pack(push, 1)
union $C3D1C278DD39211D4F47C1A8502F0DDF
{
	$43C84CF5DE546375E345C5C327562B81 __s0;
	unsigned int dmDisplayFixedOutput;
};
#pragma pack(pop)

/* 1489 */
#pragma pack(push, 1)
union $A5EB585472B52579A766EE2CB9D45D8B
{
	unsigned int dmDisplayFlags;
	unsigned int dmNup;
};
#pragma pack(pop)

/* 1490 */
#pragma pack(push, 1)
class _devicemodeA
{
	unsigned __int8 dmDeviceName[32];
	unsigned __int16 dmSpecVersion;
	unsigned __int16 dmDriverVersion;
	unsigned __int16 dmSize;
	unsigned __int16 dmDriverExtra;
	unsigned int dmFields;
	$B214638B2B9F4E804A25A19C0B009811 ___u6;
	$4AE569E07E0C6BDAC050E3B1D58D39AB ___u7;
	$C3D1C278DD39211D4F47C1A8502F0DDF ___u8;
	__int16 dmColor;
	__int16 dmDuplex;
	__int16 dmYResolution;
	__int16 dmTTOption;
	__int16 dmCollate;
	unsigned __int8 dmFormName[32];
	unsigned __int16 dmLogPixels;
	unsigned int dmBitsPerPel;
	unsigned int dmPelsWidth;
	unsigned int dmPelsHeight;
	$A5EB585472B52579A766EE2CB9D45D8B ___u19;
	unsigned int dmDisplayFrequency;
	unsigned int dmICMMethod;
	unsigned int dmICMIntent;
	unsigned int dmMediaType;
	unsigned int dmDitherType;
	unsigned int dmReserved1;
	unsigned int dmReserved2;
	unsigned int dmPanningWidth;
	unsigned int dmPanningHeight;
};
#pragma pack(pop)

/* 1491 */
#pragma pack(push, 1)
class tagEMRLINETO
{
	tagEMR emr;
	_POINTL ptl;
};
#pragma pack(pop)

/* 1492 */
#pragma pack(push, 1)
class QOS_OBJECT_HDR
{
	unsigned int ObjectType;
	unsigned int ObjectLength;
};
#pragma pack(pop)

/* 1493 */
#pragma pack(push, 1)
class $D785E45F7D0074ABC7562B7E2E519166
{
	unsigned __int32 NameOffset : 31;
	unsigned __int32 NameIsString : 1;
};
#pragma pack(pop)

/* 1494 */
#pragma pack(push, 1)
union $DF270114295C452395D48E9B69FB6B0E
{
	$D785E45F7D0074ABC7562B7E2E519166 __s0;
	unsigned int Name;
	unsigned __int16 Id;
};
#pragma pack(pop)

/* 1495 */
#pragma pack(push, 1)
class $DE34049CEDA3CF2E7E962F10AE83A663
{
	unsigned __int32 OffsetToDirectory : 31;
	unsigned __int32 DataIsDirectory : 1;
};
#pragma pack(pop)

/* 1496 */
#pragma pack(push, 1)
union $56CF4445E446840F2D6B73933AA76A51
{
	unsigned int OffsetToData;
	$DE34049CEDA3CF2E7E962F10AE83A663 __s1;
};
#pragma pack(pop)

/* 1497 */
#pragma pack(push, 1)
class _IMAGE_RESOURCE_DIRECTORY_ENTRY
{
	$DF270114295C452395D48E9B69FB6B0E ___u0;
	$56CF4445E446840F2D6B73933AA76A51 ___u1;
};
#pragma pack(pop)

/* 1498 */
#pragma pack(push, 1)
class _GRADIENT_TRIANGLE
{
	unsigned int Vertex1;
	unsigned int Vertex2;
	unsigned int Vertex3;
};
#pragma pack(pop)

/* 1499 */
#pragma pack(push, 1)
class tagEMRROUNDRECT
{
	tagEMR emr;
	_RECTL rclBox;
	tagSIZE szlCorner;
};
#pragma pack(pop)

/* 1500 */
#pragma pack(push, 1)
class _ADMINISTRATOR_POWER_POLICY
{
	_SYSTEM_POWER_STATE MinSleep;
	_SYSTEM_POWER_STATE MaxSleep;
	unsigned int MinVideoTimeout;
	unsigned int MaxVideoTimeout;
	unsigned int MinSpindownTimeout;
	unsigned int MaxSpindownTimeout;
};
#pragma pack(pop)

/* 1501 */
#pragma pack(push, 1)
class _ASSEMBLY_FILE_DETAILED_INFORMATION
{
	unsigned int ulFlags;
	unsigned int ulFilenameLength;
	unsigned int ulPathLength;
	const unsigned __int16* lpFileName;
	const unsigned __int16* lpFilePath;
};
#pragma pack(pop)

/* 1502 */
#pragma pack(push, 1)
class _UNLOAD_DLL_DEBUG_INFO
{
	void* lpBaseOfDll;
};
#pragma pack(pop)

/* 1503 */
#pragma pack(push, 1)
class tagLOGPEN
{
	unsigned int lopnStyle;
	tagPOINT lopnWidth;
	unsigned int lopnColor;
};
#pragma pack(pop)

/* 1504 */
#pragma pack(push, 1)
class _REMOTE_NAME_INFOW
{
	unsigned __int16* lpUniversalName;
	unsigned __int16* lpConnectionName;
	unsigned __int16* lpRemainingPath;
};
#pragma pack(pop)

/* 1505 */
#pragma pack(push, 1)
class _CRL_FIND_ISSUED_FOR_PARA
{
	const _CERT_CONTEXT* pSubjectCert;
	const _CERT_CONTEXT* pIssuerCert;
};
#pragma pack(pop)

/* 1506 */
#pragma pack(push, 1)
class _IMAGEHLP_SYMBOL_SRC
{
	unsigned int sizeofclass;
	unsigned int type;
	char file[260];
};
#pragma pack(pop)

/* 1507 */
#pragma pack(push, 1)
class _RIP_INFO
{
	unsigned int dwError;
	unsigned int dwType;
};
#pragma pack(pop)

/* 1508 */
#pragma pack(push, 1)
class tagLOGBRUSH32
{
	unsigned int lbStyle;
	unsigned int lbColor;
	unsigned int lbHatch;
};
#pragma pack(pop)

/* 1509 */
#pragma pack(push, 1)
class tagKBDLLHOOKclass
{
	unsigned int vkCode;
	unsigned int scanCode;
	unsigned int flags;
	unsigned int time;
	unsigned int dwExtraInfo;
};
#pragma pack(pop)

/* 1510 */
#pragma pack(push, 1)
class tagLOGBRUSH
{
	unsigned int lbStyle;
	unsigned int lbColor;
	unsigned int lbHatch;
};
#pragma pack(pop)

/* 1511 */
#pragma pack(push, 1)
class _CAT_MEMBERINFO
{
	unsigned __int16* pwszSubjGuid;
	unsigned int dwCertVersion;
};
#pragma pack(pop)

/* 1512 */
#pragma pack(push, 1)
class __declspec(align(4)) tagCOLORMATCHTOTARGET
{
	tagEMR emr;
	unsigned int dwAction;
	unsigned int dwFlags;
	unsigned int cbName;
	unsigned int cbData;
	unsigned __int8 Data[1];
};
#pragma pack(pop)

/* 1513 */
#pragma pack(push, 1)
class _CERT_POLICY_ID
{
	unsigned int cCertPolicyElementId;
	char** rgpszCertPolicyElementId;
};
#pragma pack(pop)

/* 1514 */
#pragma pack(push, 1)
class _CERT_KEY_USAGE_RESTRICTION_INFO
{
	unsigned int cCertPolicyId;
	_CERT_POLICY_ID* rgCertPolicyId;
	_CRYPT_BIT_BLOB RestrictedKeyUsage;
};
#pragma pack(pop)

/* 1515 */
#pragma pack(push, 1)
class _SPC_INDIRECT_DATA_CONTENT
{
	_CRYPT_ATTRIBUTE_TYPE_VALUE Data;
	_CRYPT_ALGORITHM_IDENTIFIER DigestAlgorithm;
	_CRYPTOAPI_BLOB Digest;
};
#pragma pack(pop)

/* 1516 */
#pragma pack(push, 1)
class _ABC
{
	int abcA;
	unsigned int abcB;
	int abcC;
};
#pragma pack(pop)

/* 1517 */
#pragma pack(push, 1)
class _NETINFOclass
{
	unsigned int cbclassure;
	unsigned int dwProviderVersion;
	unsigned int dwStatus;
	unsigned int dwCharacteristics;
	unsigned int dwHandle;
	unsigned __int16 wNetType;
	__declspec(align(4)) unsigned int dwPrinters;
	unsigned int dwDrives;
};
#pragma pack(pop)

/* 1518 */
#pragma pack(push, 1)
class _SCHANNEL_ALG
{
	unsigned int dwUse;
	unsigned int Algid;
	unsigned int cBits;
	unsigned int dwFlags;
	unsigned int dwReserved;
};
#pragma pack(pop)

/* 1519 */
#pragma pack(push, 1)
class _CERT_CREATE_CONTEXT_PARA
{
	unsigned int cbSize;
	void(__stdcall* pfnFree)(void*);
	void* pvFree;
};
#pragma pack(pop)

/* 1520 */
#pragma pack(push, 1)
class _MINIDUMP_MEMORY_DESCRIPTOR64
{
	unsigned __int64 StartOfMemoryRange;
	unsigned __int64 DataSize;
};
#pragma pack(pop)

/* 1521 */
#pragma pack(push, 1)
class _MINIDUMP_MEMORY64_LIST
{
	unsigned __int64 NumberOfMemoryRanges;
	unsigned __int64 BaseRva;
	_MINIDUMP_MEMORY_DESCRIPTOR64 MemoryRanges[];
};
#pragma pack(pop)

/* 1522 */
#pragma pack(push, 1)
class _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE
{
	_ACE_HEADER Header;
	unsigned int Mask;
	unsigned int Flags;
	_GUID ObjectType;
	_GUID InheritedObjectType;
	unsigned int SidStart;
};
#pragma pack(pop)

/* 1523 */
#pragma pack(push, 1)
class HKEY__
{
	int unused;
};
#pragma pack(pop)

/* 1524 */
#pragma pack(push, 1)
class tagEMRSELECTPALETTE
{
	tagEMR emr;
	unsigned int ihPal;
};
#pragma pack(pop)

/* 1525 */
#pragma pack(push, 1)
class _DSSSEED
{
	unsigned int counter;
	unsigned __int8 seed[20];
};
#pragma pack(pop)

/* 1526 */
#pragma pack(push, 1)
class _PUBKEYVER3
{
	unsigned int magic;
	unsigned int bitlenP;
	unsigned int bitlenQ;
	unsigned int bitlenJ;
	_DSSSEED DSSSeed;
};
#pragma pack(pop)

/* 1527 */
#pragma pack(push, 1)
class _CERT_REGISTRY_STORE_ROAMING_PARA
{
	HKEY__* hKey;
	unsigned __int16* pwszStoreDirectory;
};
#pragma pack(pop)

/* 1528 */
#pragma pack(push, 1)
class _CRYPT_PROVIDER_REGDEFUSAGE
{
	unsigned int cbclass;
	_GUID* pgActionID;
	unsigned __int16* pwszDllName;
	char* pwszLoadCallbackDataFunctionName;
	char* pwszFreeCallbackDataFunctionName;
};
#pragma pack(pop)

/* 1529 */
#pragma pack(push, 1)
class hostent
{
	char* h_name;
	char** h_aliases;
	__int16 h_addrtype;
	__int16 h_length;
	char** h_addr_list;
};
#pragma pack(pop)

/* 1530 */
#pragma pack(push, 1)
class tagENUMLOGFONTEXA
{
	tagLOGFONTA elfLogFont;
	unsigned __int8 elfFullName[64];
	unsigned __int8 elfStyle[32];
	unsigned __int8 elfScript[32];
};
#pragma pack(pop)

/* 1531 */
#pragma pack(push, 1)
class tagDESIGNVECTOR
{
	unsigned int dvReserved;
	unsigned int dvNumAxes;
	int dvValues[16];
};
#pragma pack(pop)

/* 1532 */
#pragma pack(push, 1)
class tagENUMLOGFONTEXDVA
{
	tagENUMLOGFONTEXA elfEnumLogfontEx;
	tagDESIGNVECTOR elfDesignVector;
};
#pragma pack(pop)

/* 1533 */
#pragma pack(push, 1)
class tagDRAWTEXTPARAMS
{
	unsigned int cbSize;
	int iTabLength;
	int iLeftMargin;
	int iRightMargin;
	unsigned int uiLengthDrawn;
};
#pragma pack(pop)

/* 1534 */
#pragma pack(push, 1)
class _WSAQuerySetW
{
	unsigned int dwSize;
	unsigned __int16* lpszServiceInstanceName;
	_GUID* lpServiceClassId;
	_WSAVersion* lpVersion;
	unsigned __int16* lpszComment;
	unsigned int dwNameSpace;
	_GUID* lpNSProviderId;
	unsigned __int16* lpszContext;
	unsigned int dwNumberOfProtocols;
	_AFPROTOCOLS* lpafpProtocols;
	unsigned __int16* lpszQueryString;
	unsigned int dwNumberOfCsAddrs;
	_CSADDR_INFO* lpcsaBuffer;
	unsigned int dwOutputFlags;
	_BLOB* lpBlob;
};
#pragma pack(pop)

/* 1535 */
#pragma pack(push, 1)
class _SECURITY_ATTRIBUTES
{
	unsigned int nLength;
	void* lpSecurityDescriptor;
	int bInheritHandle;
};
#pragma pack(pop)

/* 1536 */
#pragma pack(push, 1)
class __declspec(align(4)) tagPELARRAY
{
	int paXCount;
	int paYCount;
	int paXExt;
	int paYExt;
	unsigned __int8 paRGBs;
};
#pragma pack(pop)

/* 1537 */
#pragma pack(push, 1)
class tagMDICREATEclassA
{
	const char* szClass;
	const char* szTitle;
	void* hOwner;
	int x;
	int y;
	int cx;
	int cy;
	unsigned int style;
	int lParam;
};
#pragma pack(pop)

/* 1538 */
#pragma pack(push, 1)
class tagSTYLEBUFW
{
	unsigned int dwStyle;
	unsigned __int16 szDescription[32];
};
#pragma pack(pop)

/* 1539 */
#pragma pack(push, 1)
class _WSANSClassInfoA
{
	char* lpszName;
	unsigned int dwNameSpace;
	unsigned int dwValueType;
	unsigned int dwValueSize;
	void* lpValue;
};
#pragma pack(pop)

/* 1540 */
#pragma pack(push, 1)
class _POINTFLOAT
{
	float x;
	float y;
};
#pragma pack(pop)

/* 1541 */
#pragma pack(push, 1)
class _GLYPHMETRICSFLOAT
{
	float gmfBlackBoxX;
	float gmfBlackBoxY;
	_POINTFLOAT gmfptGlyphOrigin;
	float gmfCellIncX;
	float gmfCellIncY;
};
#pragma pack(pop)

/* 1542 */
#pragma pack(push, 1)
union $CB44CE6DFF5FB9FBD06C47B9962AFF0C
{
	unsigned int dwValue;
	unsigned int Algid;
	unsigned int dwLength;
};
#pragma pack(pop)

/* 1543 */
#pragma pack(push, 1)
class _CRYPT_OID_INFO
{
	unsigned int cbSize;
	const char* pszOID;
	const unsigned __int16* pwszName;
	unsigned int dwGroupId;
	$CB44CE6DFF5FB9FBD06C47B9962AFF0C ___u4;
	_CRYPTOAPI_BLOB ExtraInfo;
};
#pragma pack(pop)

/* 1544 */
#pragma pack(push, 1)
class _CRYPT_ASYNC_RETRIEVAL_COMPLETION
{
	void(__stdcall* pfnCompletion)(void*, unsigned int, const char*, char*, void*);
	void* pvCompletion;
};
#pragma pack(pop)

/* 1545 */
#pragma pack(push, 1)
class _KDHELP
{
	unsigned int Thread;
	unsigned int ThCallbackStack;
	unsigned int NextCallback;
	unsigned int FramePointer;
	unsigned int KiCallUserMode;
	unsigned int KeUserCallbackDispatcher;
	unsigned int SystemRangeStart;
	unsigned int ThCallbackBStore;
	unsigned int Reserved[8];
};
#pragma pack(pop)

/* 1546 */
#pragma pack(push, 1)
class _SYSTEM_ALARM_CALLBACK_ACE
{
	_ACE_HEADER Header;
	unsigned int Mask;
	unsigned int SidStart;
};
#pragma pack(pop)

/* 1547 */
#pragma pack(push, 1)
class tagFONTSIGNATURE
{
	unsigned int fsUsb[4];
	unsigned int fsCsb[2];
};
#pragma pack(pop)

/* 1548 */
#pragma pack(push, 1)
class POWER_ACTION_POLICY
{
	POWER_ACTION Action;
	unsigned int Flags;
	unsigned int EventCode;
};
#pragma pack(pop)

/* 1549 */
#pragma pack(push, 1)
class SYSTEM_POWER_LEVEL
{
	unsigned __int8 Enable;
	unsigned __int8 Spare[3];
	unsigned int BatteryLevel;
	POWER_ACTION_POLICY PowerPolicy;
	_SYSTEM_POWER_STATE MinSystemState;
};
#pragma pack(pop)

/* 1550 */
#pragma pack(push, 1)
class _IMAGE_OS2_HEADER
{
	unsigned __int16 ne_magic;
	char ne_ver;
	char ne_rev;
	unsigned __int16 ne_enttab;
	unsigned __int16 ne_cbenttab;
	int ne_crc;
	unsigned __int16 ne_flags;
	unsigned __int16 ne_autodata;
	unsigned __int16 ne_heap;
	unsigned __int16 ne_stack;
	int ne_csip;
	int ne_sssp;
	unsigned __int16 ne_cseg;
	unsigned __int16 ne_cmod;
	unsigned __int16 ne_cbnrestab;
	unsigned __int16 ne_segtab;
	unsigned __int16 ne_rsrctab;
	unsigned __int16 ne_restab;
	unsigned __int16 ne_modtab;
	unsigned __int16 ne_imptab;
	int ne_nrestab;
	unsigned __int16 ne_cmovent;
	unsigned __int16 ne_align;
	unsigned __int16 ne_cres;
	unsigned __int8 ne_exetyp;
	unsigned __int8 ne_flagsothers;
	unsigned __int16 ne_pretthunks;
	unsigned __int16 ne_psegrefbytes;
	unsigned __int16 ne_swaparea;
	unsigned __int16 ne_expver;
};
#pragma pack(pop)

/* 1551 */
#pragma pack(push, 1)
class _MESSAGE_RESOURCE_BLOCK
{
	unsigned int LowId;
	unsigned int HighId;
	unsigned int OffsetToEntries;
};
#pragma pack(pop)

/* 1552 */
#pragma pack(push, 1)
class tagACTCTXA
{
	unsigned int cbSize;
	unsigned int dwFlags;
	const char* lpSource;
	unsigned __int16 wProcessorArchitecture;
	unsigned __int16 wLangId;
	const char* lpAssemblyDirectory;
	const char* lpResourceName;
	const char* lpApplicationName;
	HINSTANCE__* hModule;
};
#pragma pack(pop)

/* 1553 */
#pragma pack(push, 1)
class _WSANAMESPACE_INFOA
{
	_GUID NSProviderId;
	unsigned int dwNameSpace;
	int fActive;
	unsigned int dwVersion;
	char* lpszIdentifier;
};
#pragma pack(pop)

/* 1554 */
#pragma pack(push, 1)
class tagEMRSETDIBITSTODEVICE
{
	tagEMR emr;
	_RECTL rclBounds;
	int xDest;
	int yDest;
	int xSrc;
	int ySrc;
	int cxSrc;
	int cySrc;
	unsigned int offBmiSrc;
	unsigned int cbBmiSrc;
	unsigned int offBitsSrc;
	unsigned int cbBitsSrc;
	unsigned int iUsageSrc;
	unsigned int iStartScan;
	unsigned int cScans;
};
#pragma pack(pop)

/* 1555 */
#pragma pack(push, 1)
class $DCFD3B771BF196B8E9E3DFFBF13C48A2
{
	unsigned __int16 wProcessorArchitecture;
	unsigned __int16 wReserved;
};
#pragma pack(pop)

/* 1556 */
#pragma pack(push, 1)
union $3B82EB9E17C89FC006E3B5DB6BDBBAC9
{
	unsigned int dwOemId;
	$DCFD3B771BF196B8E9E3DFFBF13C48A2 __s1;
};
#pragma pack(pop)

/* 1557 */
#pragma pack(push, 1)
class _SYSTEM_INFO
{
	$3B82EB9E17C89FC006E3B5DB6BDBBAC9 ___u0;
	unsigned int dwPageSize;
	void* lpMinimumApplicationAddress;
	void* lpMaximumApplicationAddress;
	unsigned int dwActiveProcessorMask;
	unsigned int dwNumberOfProcessors;
	unsigned int dwProcessorType;
	unsigned int dwAllocationGranularity;
	unsigned __int16 wProcessorLevel;
	unsigned __int16 wProcessorRevision;
};
#pragma pack(pop)

/* 1558 */
#pragma pack(push, 1)
class tagACTCTXW
{
	unsigned int cbSize;
	unsigned int dwFlags;
	const unsigned __int16* lpSource;
	unsigned __int16 wProcessorArchitecture;
	unsigned __int16 wLangId;
	const unsigned __int16* lpAssemblyDirectory;
	const unsigned __int16* lpResourceName;
	const unsigned __int16* lpApplicationName;
	HINSTANCE__* hModule;
};
#pragma pack(pop)

/* 1560 */
#pragma pack(push, 1)
class /*VFT*/ std::logic_error_vtbl
{
	void(__thiscall * ~exception)(exception* this);
	const char* (__thiscall* what)(exception* this);
};
#pragma pack(pop)

/* 1561 */
#pragma pack(push, 1)
class /*VFT*/ std::length_error_vtbl
{
	void(__thiscall * ~exception)(exception* this);
	const char* (__thiscall* what)(exception* this);
};
#pragma pack(pop)

/* 1562 */
#pragma pack(push, 1)
class std::runtime_error : exception
{
	std::string _Str;
};
#pragma pack(pop)

/* 1563 */
#pragma pack(push, 1)
class /*VFT*/ std::runtime_error_vtbl
{
	void(__thiscall * ~exception)(exception* this);
	const char* (__thiscall* what)(exception* this);
};
#pragma pack(pop)

/* 1565 */
#pragma pack(push, 1)
class std::ctype_base : std::locale::facet
{
};
#pragma pack(pop)

/* 1566 */
#pragma pack(push, 1)
class /*VFT*/ std::ctype_base_vtbl
{
	void(__thiscall * ~facet)(std::locale::facet* this);
};
#pragma pack(pop)

/* 1568 */
#pragma pack(push, 1)
class _Ctypevec
{
	unsigned int _Hand;
	unsigned int _Page;
	const __int16* _Table;
	int _Delfl;
};
#pragma pack(pop)

/* 1567 */
#pragma pack(push, 1)
class std::ctype<char> : std::ctype_base
{
	_Ctypevec _Ctype;
};
#pragma pack(pop)

/* 1569 */
#pragma pack(push, 1)
class /*VFT*/ std::ctype<char>_vtbl
{
	void(__thiscall * ~facet)(std::locale::facet* this);
	_BYTE gap4[4];
	char(__thiscall* do_tolower)(std::ctype<char>* this, char);
	_BYTE gapC[4];
	char(__thiscall* do_toupper)(std::ctype<char>* this, char);
	_BYTE gap14[4];
	char(__thiscall* do_widen)(std::ctype<char>* this, char);
	_BYTE gap1C[4];
	char(__thiscall* do_narrow)(std::ctype<char>* this, char, char);
};
#pragma pack(pop)

/* 1570 */
#pragma pack(push, 1)
class std::locale::id
{
	unsigned int _Id;
};
#pragma pack(pop)

/* 1571 */
#pragma pack(push, 1)
class std::_Lockit
{
	int _Locktype;
};
#pragma pack(pop)

/* 1572 */
#pragma pack(push, 1)
class std::_Locinfo
{
	std::_Lockit _Lock;
	std::string _Days;
	std::string _Months;
	std::string _Oldlocname;
	std::string _Newlocname;
};
#pragma pack(pop)

/* 1573 */
#pragma pack(push, 1)
class std::allocator<void>
{
};
#pragma pack(pop)

/* 1580 */
#pragma pack(push, 1)
class /*VFT*/ std::locale::_Locimp_vtbl
{
	void(__thiscall * ~facet)(std::locale::facet* this);
};
#pragma pack(pop)

/* 1585 */
#pragma pack(push, 1)
class std::_Mutex
{
	void* _Mtx;
};
#pragma pack(pop)

/* 1582 */
#pragma pack(push, 1)
class std::basic_streambuf<unsigned short>
{
	std::basic_streambuf<unsigned short>_vtbl* __vftable /*VFT*/;
	std::_Mutex _Mylock;
	unsigned __int16* _Gfirst;
	unsigned __int16* _Pfirst;
	unsigned __int16** _IGfirst;
	unsigned __int16** _IPfirst;
	unsigned __int16* _Gnext;
	unsigned __int16* _Pnext;
	unsigned __int16** _IGnext;
	unsigned __int16** _IPnext;
	int _Gcount;
	int _Pcount;
	int* _IGcount;
	int* _IPcount;
	std::locale* _Plocale;
};
#pragma pack(pop)

/* 1583 */
#pragma pack(push, 1)
class __declspec(align(8)) std::fpos<int>
{
	int _Myoff;
	__declspec(align(8)) __int64 _Fpos;
	int _Mystate;
};
#pragma pack(pop)

/* 1584 */
#pragma pack(push, 1)
class /*VFT*/ std::basic_streambuf<unsigned short>_vtbl
{
	void(__thiscall * ~basic_streambuf<unsigned short, std::char_traits<unsigned short> >)(std::basic_streambuf<unsigned short>* this);
	unsigned __int16(__thiscall* overflow)(std::basic_streambuf<unsigned short>* this, unsigned __int16);
	unsigned __int16(__thiscall* pbackfail)(std::basic_streambuf<unsigned short>* this, unsigned __int16);
	int(__thiscall* showmanyc)(std::basic_streambuf<unsigned short>* this);
	unsigned __int16(__thiscall* underflow)(std::basic_streambuf<unsigned short>* this);
	unsigned __int16(__thiscall* uflow)(std::basic_streambuf<unsigned short>* this);
	int(__thiscall* xsgetn)(std::basic_streambuf<unsigned short>* this, unsigned __int16*, int);
	int(__thiscall* xsputn)(std::basic_streambuf<unsigned short>* this, const unsigned __int16*, int);
	std::fpos<int>* (__thiscall* seekoff)(std::basic_streambuf<unsigned short>* this, std::fpos<int>* result, int, int, int);
	std::fpos<int>* (__thiscall* seekpos)(std::basic_streambuf<unsigned short>* this, std::fpos<int>* result, std::fpos<int>, int);
	std::basic_streambuf<unsigned short>* (__thiscall* setbuf)(std::basic_streambuf<unsigned short>* this, unsigned __int16*, int);
	int(__thiscall* sync)(std::basic_streambuf<unsigned short>* this);
	void(__thiscall* imbue)(std::basic_streambuf<unsigned short>* this, const std::locale*);
};
#pragma pack(pop)

/* 1586 */
#pragma pack(push, 1)
class std::basic_ostream<unsigned short>
{
	_BYTE gap0[56];
};
#pragma pack(pop)

/* 1587 */
#pragma pack(push, 1)
class /*VFT*/ std::basic_ostream<unsigned short>_vtbl
{
	void* (__thiscall* __vecDelDtor)(std::basic_ostream<unsigned short>* this, unsigned int);
};
#pragma pack(pop)

/* 1588 */
#pragma pack(push, 1)
class __declspec(align(4)) std::basic_ios<unsigned short> : std::ios_base
{
	std::basic_streambuf<unsigned short>* _Mystrbuf;
	std::basic_ostream<unsigned short>* _Tiestr;
	unsigned __int16 _Fillch;
};
#pragma pack(pop)

/* 1589 */
#pragma pack(push, 1)
class /*VFT*/ std::basic_ios<unsigned short>_vtbl
{
	void(__thiscall * ~ios_base)(std::ios_base* this);
};
#pragma pack(pop)

/* 1590 */
#pragma pack(push, 1)
class __declspec(align(4)) std::basic_istream<unsigned short>
{
	_BYTE gap0[4];
	int _Chcount;
	_BYTE gap8[52];
};
#pragma pack(pop)

/* 1591 */
#pragma pack(push, 1)
class /*VFT*/ std::basic_istream<unsigned short>_vtbl
{
	void* (__thiscall* __vecDelDtor)(std::basic_istream<unsigned short>* this, unsigned int);
};
#pragma pack(pop)

/* 1593 */
#pragma pack(push, 1)
class _Cvtvec
{
	unsigned int _Hand;
	unsigned int _Page;
};
#pragma pack(pop)

/* 1592 */
#pragma pack(push, 1)
class std::ctype<unsigned short> : std::ctype_base
{
	_Ctypevec _Ctype;
	_Cvtvec _Cvt;
};
#pragma pack(pop)

/* 1594 */
#pragma pack(push, 1)
class /*VFT*/ std::ctype<unsigned short>_vtbl
{
	void(__thiscall * ~facet)(std::locale::facet* this);
	_BYTE gap4[4];
	bool(__thiscall* do_is)(std::ctype<unsigned short>* this, __int16, unsigned __int16);
	const unsigned __int16* (__thiscall* do_scan_is)(std::ctype<unsigned short>* this, __int16, const unsigned __int16*, const unsigned __int16*);
	const unsigned __int16* (__thiscall* do_scan_not)(std::ctype<unsigned short>* this, __int16, const unsigned __int16*, const unsigned __int16*);
	_BYTE gap14[4];
	unsigned __int16(__thiscall* do_tolower)(std::ctype<unsigned short>* this, unsigned __int16);
	_BYTE gap1C[4];
	unsigned __int16(__thiscall* do_toupper)(std::ctype<unsigned short>* this, unsigned __int16);
	_BYTE gap24[4];
	unsigned __int16(__thiscall* do_widen)(std::ctype<unsigned short>* this, char);
	_BYTE gap2C[4];
	char(__thiscall* do_narrow)(std::ctype<unsigned short>* this, unsigned __int16, char);
};
#pragma pack(pop)

/* 1595 */
#pragma pack(push, 1)
class std::basic_istream<unsigned short>::_Sentry_base
{
	std::basic_istream<unsigned short>* _Myistr;
};
#pragma pack(pop)

/* 1596 */
#pragma pack(push, 1)
class __declspec(align(4)) std::basic_istream<unsigned short>::sentry : std::basic_istream<unsigned short>::_Sentry_base
{
	bool _Ok;
};
#pragma pack(pop)

/* 1597 */
#pragma pack(push, 1)
class std::streambuf
{
	std::streambuf_vtbl* __vftable /*VFT*/;
	std::_Mutex _Mylock;
	char* _Gfirst;
	char* _Pfirst;
	char** _IGfirst;
	char** _IPfirst;
	char* _Gnext;
	char* _Pnext;
	char** _IGnext;
	char** _IPnext;
	int _Gcount;
	int _Pcount;
	int* _IGcount;
	int* _IPcount;
	std::locale* _Plocale;
};
#pragma pack(pop)

/* 1598 */
#pragma pack(push, 1)
class /*VFT*/ std::streambuf_vtbl
{
	void(__thiscall * ~basic_streambuf<char, std::char_traits<char> >)(std::streambuf* this);
	int(__thiscall* overflow)(std::streambuf* this, int);
	int(__thiscall* pbackfail)(std::streambuf* this, int);
	int(__thiscall* showmanyc)(std::streambuf* this);
	int(__thiscall* underflow)(std::streambuf* this);
	int(__thiscall* uflow)(std::streambuf* this);
	int(__thiscall* xsgetn)(std::streambuf* this, char*, int);
	int(__thiscall* xsputn)(std::streambuf* this, const char*, int);
	std::fpos<int>* (__thiscall* seekoff)(std::streambuf* this, std::fpos<int>* result, int, int, int);
	std::fpos<int>* (__thiscall* seekpos)(std::streambuf* this, std::fpos<int>* result, std::fpos<int>, int);
	std::streambuf* (__thiscall* setbuf)(std::streambuf* this, char*, int);
	int(__thiscall* sync)(std::streambuf* this);
	void(__thiscall* imbue)(std::streambuf* this, const std::locale*);
};
#pragma pack(pop)

/* 1599 */
#pragma pack(push, 1)
class std::ostream
{
	_BYTE gap0[56];
};
#pragma pack(pop)

/* 1600 */
#pragma pack(push, 1)
class /*VFT*/ std::ostream_vtbl
{
	void* (__thiscall* __vecDelDtor)(std::ostream* this, unsigned int);
};
#pragma pack(pop)

/* 1601 */
#pragma pack(push, 1)
class __declspec(align(4)) std::ios : std::ios_base
{
	std::streambuf* _Mystrbuf;
	std::ostream* _Tiestr;
	char _Fillch;
};
#pragma pack(pop)

/* 1602 */
#pragma pack(push, 1)
class /*VFT*/ std::ios_vtbl
{
	void(__thiscall * ~ios_base)(std::ios_base* this);
};
#pragma pack(pop)

/* 1603 */
#pragma pack(push, 1)
class std::_Int_iterator_tag
{
};
#pragma pack(pop)

/* 1604 */
#pragma pack(push, 1)
class std::iterator_traits<unsigned short>
{
};
#pragma pack(pop)

/* 1605 */
#pragma pack(push, 1)
class std::ostream::_Sentry_base
{
	std::ostream* _Myostr;
};
#pragma pack(pop)

/* 1606 */
#pragma pack(push, 1)
class __declspec(align(4)) std::ostream::sentry : std::ostream::_Sentry_base
{
	bool _Ok;
};
#pragma pack(pop)

/* 1607 */
#pragma pack(push, 1)
class std::bad_cast : std::exception
{
};
#pragma pack(pop)

/* 1608 */
#pragma pack(push, 1)
class /*VFT*/ std::bad_cast_vtbl
{
	void(__thiscall * ~exception)(std::exception* this);
	const char* (__thiscall* what)(std::exception* this);
	void(__thiscall* _Doraise)(std::exception* this);
};
#pragma pack(pop)

/* 1609 */
#pragma pack(push, 1)
class std::output_iterator_tag
{
};
#pragma pack(pop)

/* 1610 */
#pragma pack(push, 1)
class std::invalid_argument : std::logic_error
{
};
#pragma pack(pop)

/* 1611 */
#pragma pack(push, 1)
class /*VFT*/ std::invalid_argument_vtbl
{
	void(__thiscall * ~exception)(exception* this);
	const char* (__thiscall* what)(exception* this);
};
#pragma pack(pop)

/* 1612 */
#pragma pack(push, 1)
class std::iterator<std::output_iterator_tag, void, void, void, void>
{
};
#pragma pack(pop)

/* 1613 */
#pragma pack(push, 1)
class std::_Outit : std::iterator<std::output_iterator_tag, void, void, void, void>
{
};
#pragma pack(pop)

/* 1614 */
#pragma pack(push, 1)
class /*VFT*/ std::codecvt_base_vtbl
{
	void(__thiscall * ~facet)(std::locale::facet* this);
	bool(__thiscall* do_always_noconv)(std::codecvt_base* this);
	int(__thiscall* do_max_length)(std::codecvt_base* this);
	int(__thiscall* do_encoding)(std::codecvt_base* this);
};
#pragma pack(pop)

/* 1615 */
#pragma pack(push, 1)
class std::iterator_traits<unsigned long>
{
};
#pragma pack(pop)

/* 1616 */
#pragma pack(push, 1)
class std::underflow_error : std::runtime_error
{
};
#pragma pack(pop)

/* 1617 */
#pragma pack(push, 1)
class /*VFT*/ std::underflow_error_vtbl
{
	void(__thiscall * ~exception)(exception* this);
	const char* (__thiscall* what)(exception* this);
};
#pragma pack(pop)

/* 1618 */
#pragma pack(push, 1)
class std::bad_exception : exception
{
};
#pragma pack(pop)

/* 1619 */
#pragma pack(push, 1)
class /*VFT*/ std::bad_exception_vtbl
{
	void(__thiscall * ~exception)(exception* this);
	const char* (__thiscall* what)(exception* this);
};
#pragma pack(pop)

/* 1620 */
#pragma pack(push, 1)
class __declspec(align(4)) std::istream
{
	_BYTE gap0[4];
	int _Chcount;
	_BYTE gap8[52];
};
#pragma pack(pop)

/* 1621 */
#pragma pack(push, 1)
class /*VFT*/ std::istream_vtbl
{
	void* (__thiscall* __vecDelDtor)(std::istream* this, unsigned int);
};
#pragma pack(pop)

/* 1622 */
#pragma pack(push, 1)
class std::istream::_Sentry_base
{
	std::istream* _Myistr;
};
#pragma pack(pop)

/* 1623 */
#pragma pack(push, 1)
class __declspec(align(4)) std::istream::sentry : std::istream::_Sentry_base
{
	bool _Ok;
};
#pragma pack(pop)

/* 1624 */
#pragma pack(push, 1)
class std::random_access_iterator_tag : std::bidirectional_iterator_tag
{
};
#pragma pack(pop)

/* 1625 */
#pragma pack(push, 1)
class std::iterator_traits<short>
{
};
#pragma pack(pop)

/* 1626 */
#pragma pack(push, 1)
class std::bad_typeid : std::exception
{
};
#pragma pack(pop)

/* 1627 */
#pragma pack(push, 1)
class /*VFT*/ std::bad_typeid_vtbl
{
	void(__thiscall * ~exception)(std::exception* this);
	const char* (__thiscall* what)(std::exception* this);
	void(__thiscall* _Doraise)(std::exception* this);
};
#pragma pack(pop)

/* 1628 */
#pragma pack(push, 1)
class std::codecvt<unsigned short, char, int> : std::codecvt_base
{
	_Cvtvec _Cvt;
};
#pragma pack(pop)

/* 1629 */
#pragma pack(push, 1)
class /*VFT*/ std::codecvt<unsigned short, char, int>_vtbl
{
	void(__thiscall * ~facet)(std::locale::facet* this);
	bool(__thiscall* do_always_noconv)(std::codecvt_base* this);
	int(__thiscall* do_max_length)(std::codecvt_base* this);
	int(__thiscall* do_encoding)(std::codecvt_base* this);
	int(__thiscall* do_in)(std::codecvt<unsigned short, char, int>* this, int*, const char*, const char*, const char**, unsigned __int16*, unsigned __int16*, unsigned __int16**);
	int(__thiscall* do_out)(std::codecvt<unsigned short, char, int>* this, int*, const unsigned __int16*, const unsigned __int16*, const unsigned __int16**, char*, char*, char**);
	int(__thiscall* do_unshift)(std::codecvt<unsigned short, char, int>* this, int*, char*, char*, char**);
	int(__thiscall* do_length)(std::codecvt<unsigned short, char, int>* this, const int*, const char*, const char*, unsigned int);
};
#pragma pack(pop)

/* 1630 */
#pragma pack(push, 1)
class std::iterator_traits<unsigned __int64>
{
};
#pragma pack(pop)

/* 1631 */
#pragma pack(push, 1)
class std::iterator_traits<signed char>
{
};
#pragma pack(pop)

/* 1632 */
#pragma pack(push, 1)
class std::_Facetptr<std::ctype<char> >
{
};
#pragma pack(pop)

/* 1633 */
#pragma pack(push, 1)
class std::char_traits<unsigned short>
{
};
#pragma pack(pop)

/* 1634 */
#pragma pack(push, 1)
class std::iterator_traits<__int64>
{
};
#pragma pack(pop)

/* 1635 */
#pragma pack(push, 1)
class std::domain_error : std::logic_error
{
};
#pragma pack(pop)

/* 1636 */
#pragma pack(push, 1)
class /*VFT*/ std::domain_error_vtbl
{
	void(__thiscall * ~exception)(exception* this);
	const char* (__thiscall* what)(exception* this);
};
#pragma pack(pop)

/* 1637 */
#pragma pack(push, 1)
class std::__non_rtti_object : std::bad_typeid
{
};
#pragma pack(pop)

/* 1638 */
#pragma pack(push, 1)
class /*VFT*/ std::__non_rtti_object_vtbl
{
	void(__thiscall * ~exception)(std::exception* this);
	const char* (__thiscall* what)(std::exception* this);
	void(__thiscall* _Doraise)(std::exception* this);
};
#pragma pack(pop)

/* 1639 */
#pragma pack(push, 1)
class std::overflow_error : std::runtime_error
{
};
#pragma pack(pop)

/* 1640 */
#pragma pack(push, 1)
class /*VFT*/ std::overflow_error_vtbl
{
	void(__thiscall * ~exception)(exception* this);
	const char* (__thiscall* what)(exception* this);
};
#pragma pack(pop)

/* 1641 */
#pragma pack(push, 1)
class std::iterator_traits<unsigned int>
{
};
#pragma pack(pop)

/* 1642 */
#pragma pack(push, 1)
class std::range_error : std::runtime_error
{
};
#pragma pack(pop)

/* 1643 */
#pragma pack(push, 1)
class /*VFT*/ std::range_error_vtbl
{
	void(__thiscall * ~exception)(exception* this);
	const char* (__thiscall* what)(exception* this);
};
#pragma pack(pop)

/* 1644 */
#pragma pack(push, 1)
class std::iterator_traits<char>
{
};
#pragma pack(pop)

/* 1645 */
#pragma pack(push, 1)
class _Collvec
{
	unsigned int _Hand;
	unsigned int _Page;
};
#pragma pack(pop)

/* 1646 */
#pragma pack(push, 1)
class std::_Timevec
{
	void* _Timeptr;
};
#pragma pack(pop)

/* 1647 */
#pragma pack(push, 1)
class lconv
{
	char* decimal_point;
	char* thousands_sep;
	char* grouping;
	char* int_curr_symbol;
	char* currency_symbol;
	char* mon_decimal_point;
	char* mon_thousands_sep;
	char* mon_grouping;
	char* positive_sign;
	char* negative_sign;
	char int_frac_digits;
	char frac_digits;
	char p_cs_precedes;
	char p_sep_by_space;
	char n_cs_precedes;
	char n_sep_by_space;
	char p_sign_posn;
	char n_sign_posn;
};
#pragma pack(pop)

/* 1648 */
#pragma pack(push, 1)
class std::out_of_range : std::logic_error
{
};
#pragma pack(pop)

/* 1649 */
#pragma pack(push, 1)
class /*VFT*/ std::out_of_range_vtbl
{
	void(__thiscall * ~exception)(exception* this);
	const char* (__thiscall* what)(exception* this);
};
#pragma pack(pop)

/* 1650 */
#pragma pack(push, 1)
class std::basic_ostream<unsigned short>::_Sentry_base
{
	std::basic_ostream<unsigned short>* _Myostr;
};
#pragma pack(pop)

/* 1651 */
#pragma pack(push, 1)
class __declspec(align(4)) std::basic_ostream<unsigned short>::sentry : std::basic_ostream<unsigned short>::_Sentry_base
{
	bool _Ok;
};
#pragma pack(pop)

/* 1652 */
#pragma pack(push, 1)
class std::nothrow_t
{
};
#pragma pack(pop)

/* 1653 */
#pragma pack(push, 1)
class std::iterator_traits<unsigned char>
{
};
#pragma pack(pop)

/* 1654 */
#pragma pack(push, 1)
class std::iterator_traits<int>
{
};
#pragma pack(pop)

/* 1655 */
#pragma pack(push, 1)
class std::iterator_traits<bool>
{
};
#pragma pack(pop)

/* 1656 */
#pragma pack(push, 1)
class std::iterator_traits<long>
{
};
#pragma pack(pop)

/* 1657 */
#pragma pack(push, 1)
class std::bad_alloc : exception
{
};
#pragma pack(pop)

/* 1658 */
#pragma pack(push, 1)
class /*VFT*/ std::bad_alloc_vtbl
{
	void(__thiscall * ~exception)(exception* this);
	const char* (__thiscall* what)(exception* this);
};
#pragma pack(pop)

/* 1659 */
#pragma pack(push, 1)
class std::_Nonscalar_ptr_iterator_tag
{
};
#pragma pack(pop)

/* 1660 */
#pragma pack(push, 1)
class std::ios_base::failure : std::runtime_error
{
};
#pragma pack(pop)

/* 1661 */
#pragma pack(push, 1)
class /*VFT*/ std::ios_base::failure_vtbl
{
	void(__thiscall * ~exception)(exception* this);
	const char* (__thiscall* what)(exception* this);
};
#pragma pack(pop)

/* 1662 */
#pragma pack(push, 1)
class std::ios_base::Init
{
};
#pragma pack(pop)

/* 1663 */
#pragma pack(push, 1)
class std::_Facetptr<std::ctype<unsigned short> >
{
};
#pragma pack(pop)

/* 1664 */
#pragma pack(push, 1)
class std::_Scalar_ptr_iterator_tag
{
};
#pragma pack(pop)

/* 1665 */
#pragma pack(push, 1)
class _ACCESS_ALLOWED_OBJECT_ACE
{
	_ACE_HEADER Header;
	unsigned int Mask;
	unsigned int Flags;
	_GUID ObjectType;
	_GUID InheritedObjectType;
	unsigned int SidStart;
};
#pragma pack(pop)

/* 1666 */
#pragma pack(push, 1)
class sockaddr_storage
{
	__int16 ss_family;
	char __ss_pad1[6];
	__int64 __ss_align;
	char __ss_pad2[112];
};
#pragma pack(pop)

/* 1667 */
#pragma pack(push, 1)
class _CERT_RDN_ATTR
{
	char* pszObjId;
	unsigned int dwValueType;
	_CRYPTOAPI_BLOB Value;
};
#pragma pack(pop)

/* 1668 */
#pragma pack(push, 1)
class _CERT_RDN
{
	unsigned int cRDNAttr;
	_CERT_RDN_ATTR* rgRDNAttr;
};
#pragma pack(pop)

/* 1669 */
#pragma pack(push, 1)
class _CERT_STORE_PROV_INFO
{
	unsigned int cbSize;
	unsigned int cStoreProvFunc;
	void** rgpvStoreProvFunc;
	void* hStoreProv;
	unsigned int dwStoreProvFlags;
	void* hStoreProvFuncAddr2;
};
#pragma pack(pop)

/* 1670 */
#pragma pack(push, 1)
class LIST_ENTRY32
{
	unsigned int Flink;
	unsigned int Blink;
};
#pragma pack(pop)

/* 1671 */
#pragma pack(push, 1)
union $1FBD16D530BA398F5B55D5D355CAAB16
{
	unsigned __int64 EndOfPrologue;
	unsigned __int64 UnwindInfoAddress;
};
#pragma pack(pop)

/* 1672 */
#pragma pack(push, 1)
class _IMAGE_FUNCTION_ENTRY64
{
	unsigned __int64 StartingAddress;
	unsigned __int64 EndingAddress;
	$1FBD16D530BA398F5B55D5D355CAAB16 ___u2;
};
#pragma pack(pop)

/* 1673 */
#pragma pack(push, 1)
class _EXIT_THREAD_DEBUG_INFO
{
	unsigned int dwExitCode;
};
#pragma pack(pop)

/* 1674 */
#pragma pack(push, 1)
class _SERVICE_STATUS_PROCESS
{
	unsigned int dwServiceType;
	unsigned int dwCurrentState;
	unsigned int dwControlsAccepted;
	unsigned int dwWin32ExitCode;
	unsigned int dwServiceSpecificExitCode;
	unsigned int dwCheckPoint;
	unsigned int dwWaitHint;
	unsigned int dwProcessId;
	unsigned int dwServiceFlags;
};
#pragma pack(pop)

/* 1675 */
#pragma pack(push, 1)
class _ENUM_SERVICE_STATUS_PROCESSA
{
	char* lpServiceName;
	char* lpDisplayName;
	_SERVICE_STATUS_PROCESS ServiceStatusProcess;
};
#pragma pack(pop)

/* 1676 */
#pragma pack(push, 1)
class servent
{
	char* s_name;
	char** s_aliases;
	__int16 s_port;
	__declspec(align(4)) char* s_proto;
};
#pragma pack(pop)

/* 1677 */
#pragma pack(push, 1)
class tagACCEL
{
	unsigned __int8 fVirt;
	__declspec(align(2)) unsigned __int16 key;
	unsigned __int16 cmd;
};
#pragma pack(pop)

/* 1678 */
#pragma pack(push, 1)
class _CMC_PEND_INFO
{
	_CRYPTOAPI_BLOB PendToken;
	_FILETIME PendTime;
};
#pragma pack(pop)

/* 1679 */
#pragma pack(push, 1)
union $0B13977948F0CD9D4692C42BB304EED6
{
	unsigned int dwFailInfo;
	_CMC_PEND_INFO* pPendInfo;
};
#pragma pack(pop)

/* 1680 */
#pragma pack(push, 1)
class _CMC_STATUS_INFO
{
	unsigned int dwStatus;
	unsigned int cBodyList;
	unsigned int* rgdwBodyList;
	unsigned __int16* pwszStatusString;
	unsigned int dwOtherInfoChoice;
	$0B13977948F0CD9D4692C42BB304EED6 ___u5;
};
#pragma pack(pop)

/* 1681 */
#pragma pack(push, 1)
class _QUOTA_LIMITS
{
	unsigned int PagedPoolLimit;
	unsigned int NonPagedPoolLimit;
	unsigned int MinimumWorkingSetSize;
	unsigned int MaximumWorkingSetSize;
	unsigned int PagefileLimit;
	__declspec(align(8)) _LARGE_INTEGER TimeLimit;
};
#pragma pack(pop)

/* 1682 */
#pragma pack(push, 1)
class tagSERIALKEYSW
{
	unsigned int cbSize;
	unsigned int dwFlags;
	unsigned __int16* lpszActivePort;
	unsigned __int16* lpszPort;
	unsigned int iBaudRate;
	unsigned int iPortState;
	unsigned int iActive;
};
#pragma pack(pop)

/* 1683 */
#pragma pack(push, 1)
class _NETCONNECTINFOclass
{
	unsigned int cbclassure;
	unsigned int dwFlags;
	unsigned int dwSpeed;
	unsigned int dwDelay;
	unsigned int dwOptDataSize;
};
#pragma pack(pop)

/* 1684 */
#pragma pack(push, 1)
class _CMS_DH_KEY_INFO
{
	unsigned int dwVersion;
	unsigned int Algid;
	char* pszContentEncObjId;
	_CRYPTOAPI_BLOB PubInfo;
	void* pReserved;
};
#pragma pack(pop)

/* 1685 */
#pragma pack(push, 1)
class $A5C9E7FBEA3DE51AEBC1B21641DB8AC3
{
	unsigned int Short;
	unsigned int Long;
};
#pragma pack(pop)

/* 1686 */
#pragma pack(push, 1)
union $32825B9134F76CBA7ACCF6CE5181AB5F
{
	unsigned __int8 ShortName[8];
	$A5C9E7FBEA3DE51AEBC1B21641DB8AC3 Name;
	unsigned int LongName[2];
};
#pragma pack(pop)

/* 1687 */
#pragma pack(push, 1)
class __unaligned __declspec(align(2)) _IMAGE_SYMBOL
{
	$32825B9134F76CBA7ACCF6CE5181AB5F N;
	unsigned int Value;
	__int16 SectionNumber;
	unsigned __int16 Type;
	unsigned __int8 StorageClass;
	unsigned __int8 NumberOfAuxSymbols;
};
#pragma pack(pop)

/* 1688 */
#pragma pack(push, 1)
class __declspec(align(8)) _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION
{
	unsigned int ulFlags;
	unsigned int ulEncodedAssemblyIdentityLength;
	unsigned int ulManifestPathType;
	unsigned int ulManifestPathLength;
	_LARGE_INTEGER liManifestLastWriteTime;
	unsigned int ulPolicyPathType;
	unsigned int ulPolicyPathLength;
	_LARGE_INTEGER liPolicyLastWriteTime;
	unsigned int ulMetadataSatelliteRosterIndex;
	unsigned int ulManifestVersionMajor;
	unsigned int ulManifestVersionMinor;
	unsigned int ulPolicyVersionMajor;
	unsigned int ulPolicyVersionMinor;
	unsigned int ulAssemblyDirectoryNameLength;
	const unsigned __int16* lpAssemblyEncodedAssemblyIdentity;
	const unsigned __int16* lpAssemblyManifestPath;
	const unsigned __int16* lpAssemblyPolicyPath;
	const unsigned __int16* lpAssemblyDirectoryName;
	unsigned int ulFileCount;
};
#pragma pack(pop)

/* 1689 */
#pragma pack(push, 1)
class tagDROPclass
{
	HWND__* hwndSource;
	HWND__* hwndSink;
	unsigned int wFmt;
	unsigned int dwData;
	tagPOINT ptDrop;
	unsigned int dwControlData;
};
#pragma pack(pop)

/* 1690 */
#pragma pack(push, 1)
class _TOKEN_GROUPS_AND_PRIVILEGES
{
	unsigned int SidCount;
	unsigned int SidLength;
	_SID_AND_ATTRIBUTES* Sids;
	unsigned int RestrictedSidCount;
	unsigned int RestrictedSidLength;
	_SID_AND_ATTRIBUTES* RestrictedSids;
	unsigned int PrivilegeCount;
	unsigned int PrivilegeLength;
	_LUID_AND_ATTRIBUTES* Privileges;
	_LUID AuthenticationId;
};
#pragma pack(pop)

/* 1691 */
#pragma pack(push, 1)
class tagMSLLHOOKclass
{
	tagPOINT pt;
	unsigned int mouseData;
	unsigned int flags;
	unsigned int time;
	unsigned int dwExtraInfo;
};
#pragma pack(pop)

/* 1692 */
#pragma pack(push, 1)
class tagIMEMENUITEMINFOA
{
	unsigned int cbSize;
	unsigned int fType;
	unsigned int fState;
	unsigned int wID;
	HBITMAP__* hbmpChecked;
	HBITMAP__* hbmpUnchecked;
	unsigned int dwItemData;
	char szString[80];
	HBITMAP__* hbmpItem;
};
#pragma pack(pop)

/* 1693 */
#pragma pack(push, 1)
class tagEXTLOGPEN
{
	unsigned int elpPenStyle;
	unsigned int elpWidth;
	unsigned int elpBrushStyle;
	unsigned int elpColor;
	unsigned int elpHatch;
	unsigned int elpNumEntries;
	unsigned int elpStyleEntry[1];
};
#pragma pack(pop)

/* 1694 */
#pragma pack(push, 1)
class _OUTLINETEXTMETRICA
{
	unsigned int otmSize;
	tagTEXTMETRICA otmTextMetrics;
	unsigned __int8 otmFiller;
	tagPANOSE otmPanoseNumber;
	__declspec(align(2)) unsigned int otmfsSelection;
	unsigned int otmfsType;
	int otmsCharSlopeRise;
	int otmsCharSlopeRun;
	int otmItalicAngle;
	unsigned int otmEMSquare;
	int otmAscent;
	int otmDescent;
	unsigned int otmLineGap;
	unsigned int otmsCapEmHeight;
	unsigned int otmsXHeight;
	tagRECT otmrcFontBox;
	int otmMacAscent;
	int otmMacDescent;
	unsigned int otmMacLineGap;
	unsigned int otmusMinimumPPEM;
	tagPOINT otmptSubscriptSize;
	tagPOINT otmptSubscriptOffset;
	tagPOINT otmptSuperscriptSize;
	tagPOINT otmptSuperscriptOffset;
	unsigned int otmsStrikeoutSize;
	int otmsStrikeoutPosition;
	int otmsUnderscoreSize;
	int otmsUnderscorePosition;
	char* otmpFamilyName;
	char* otmpFaceName;
	char* otmpStyleName;
	char* otmpFullName;
};
#pragma pack(pop)

/* 1695 */
#pragma pack(push, 1)
class _CRYPT_RC2_CBC_PARAMETERS
{
	unsigned int dwVersion;
	int fIV;
	unsigned __int8 rgbIV[8];
};
#pragma pack(pop)

/* 1696 */
#pragma pack(push, 1)
class _RASTERIZER_STATUS
{
	__int16 nSize;
	__int16 wFlags;
	__int16 nLanguageID;
};
#pragma pack(pop)

/* 1697 */
#pragma pack(push, 1)
class _WIN32_FIND_DATAW
{
	unsigned int dwFileAttributes;
	_FILETIME ftCreationTime;
	_FILETIME ftLastAccessTime;
	_FILETIME ftLastWriteTime;
	unsigned int nFileSizeHigh;
	unsigned int nFileSizeLow;
	unsigned int dwReserved0;
	unsigned int dwReserved1;
	unsigned __int16 cFileName[260];
	unsigned __int16 cAlternateFileName[14];
};
#pragma pack(pop)

/* 1698 */
#pragma pack(push, 1)
class _CERT_FORTEZZA_DATA_PROP
{
	unsigned __int8 SerialNumber[8];
	int CertIndex;
	unsigned __int8 CertLabel[36];
};
#pragma pack(pop)

/* 1699 */
#pragma pack(push, 1)
class _CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA
{
	unsigned int cbSize;
	unsigned int dwSignerIndex;
	unsigned int dwUnauthAttrIndex;
};
#pragma pack(pop)

/* 1700 */
#pragma pack(push, 1)
class _TOKEN_AUDIT_POLICY_ELEMENT
{
	unsigned int Category;
	unsigned int PolicyMask;
};
#pragma pack(pop)

/* 1701 */
#pragma pack(push, 1)
class tagEMRTEXT
{
	_POINTL ptlReference;
	unsigned int nChars;
	unsigned int offString;
	unsigned int fOptions;
	_RECTL rcl;
	unsigned int offDx;
};
#pragma pack(pop)

/* 1702 */
#pragma pack(push, 1)
class tagEMRPOLYTEXTOUTA
{
	tagEMR emr;
	_RECTL rclBounds;
	unsigned int iGraphicsMode;
	float exScale;
	float eyScale;
	int cStrings;
	tagEMRTEXT aemrtext[1];
};
#pragma pack(pop)

/* 1703 */
#pragma pack(push, 1)
class __declspec(align(4)) _WIN32_FIND_DATAA
{
	unsigned int dwFileAttributes;
	_FILETIME ftCreationTime;
	_FILETIME ftLastAccessTime;
	_FILETIME ftLastWriteTime;
	unsigned int nFileSizeHigh;
	unsigned int nFileSizeLow;
	unsigned int dwReserved0;
	unsigned int dwReserved1;
	char cFileName[260];
	char cAlternateFileName[14];
};
#pragma pack(pop)

/* 1704 */
#pragma pack(push, 1)
class tagBITMAPINFOHEADER
{
	unsigned int biSize;
	int biWidth;
	int biHeight;
	unsigned __int16 biPlanes;
	unsigned __int16 biBitCount;
	unsigned int biCompression;
	unsigned int biSizeImage;
	int biXPelsPerMeter;
	int biYPelsPerMeter;
	unsigned int biClrUsed;
	unsigned int biClrImportant;
};
#pragma pack(pop)

/* 1705 */
#pragma pack(push, 1)
class tagNEWTEXTMETRICA
{
	int tmHeight;
	int tmAscent;
	int tmDescent;
	int tmInternalLeading;
	int tmExternalLeading;
	int tmAveCharWidth;
	int tmMaxCharWidth;
	int tmWeight;
	int tmOverhang;
	int tmDigitizedAspectX;
	int tmDigitizedAspectY;
	unsigned __int8 tmFirstChar;
	unsigned __int8 tmLastChar;
	unsigned __int8 tmDefaultChar;
	unsigned __int8 tmBreakChar;
	unsigned __int8 tmItalic;
	unsigned __int8 tmUnderlined;
	unsigned __int8 tmStruckOut;
	unsigned __int8 tmPitchAndFamily;
	unsigned __int8 tmCharSet;
	__declspec(align(4)) unsigned int ntmFlags;
	unsigned int ntmSizeEM;
	unsigned int ntmCellHeight;
	unsigned int ntmAvgWidth;
};
#pragma pack(pop)

/* 1706 */
#pragma pack(push, 1)
class tagNEWTEXTMETRICEXA
{
	tagNEWTEXTMETRICA ntmTm;
	tagFONTSIGNATURE ntmFontSig;
};
#pragma pack(pop)

/* 1707 */
#pragma pack(push, 1)
class tagAXISINFOA
{
	int axMinValue;
	int axMaxValue;
	unsigned __int8 axAxisName[16];
};
#pragma pack(pop)

/* 1708 */
#pragma pack(push, 1)
class tagAXESLISTA
{
	unsigned int axlReserved;
	unsigned int axlNumAxes;
	tagAXISINFOA axlAxisInfo[16];
};
#pragma pack(pop)

/* 1709 */
#pragma pack(push, 1)
class tagENUMTEXTMETRICA
{
	tagNEWTEXTMETRICEXA etmNewTextMetricEx;
	tagAXESLISTA etmAxesList;
};
#pragma pack(pop)

/* 1710 */
#pragma pack(push, 1)
class _tagADDRESS
{
	unsigned int Offset;
	unsigned __int16 Segment;
	__declspec(align(4)) ADDRESS_MODE Mode;
};
#pragma pack(pop)

/* 1711 */
#pragma pack(push, 1)
class _tagSTACKFRAME
{
	_tagADDRESS AddrPC;
	_tagADDRESS AddrReturn;
	_tagADDRESS AddrFrame;
	_tagADDRESS AddrStack;
	void* FuncTableEntry;
	unsigned int Params[4];
	int Far;
	int Virtual;
	unsigned int Reserved[3];
	_KDHELP KdHelp;
	_tagADDRESS AddrBStore;
};
#pragma pack(pop)

/* 1712 */
#pragma pack(push, 1)
class tagEMRSTRETCHDIBITS
{
	tagEMR emr;
	_RECTL rclBounds;
	int xDest;
	int yDest;
	int xSrc;
	int ySrc;
	int cxSrc;
	int cySrc;
	unsigned int offBmiSrc;
	unsigned int cbBmiSrc;
	unsigned int offBitsSrc;
	unsigned int cbBitsSrc;
	unsigned int iUsageSrc;
	unsigned int dwRop;
	int cxDest;
	int cyDest;
};
#pragma pack(pop)

/* 1713 */
#pragma pack(push, 1)
class IMAGE_LOAD_CONFIG_DIRECTORY32
{
	unsigned int Size;
	unsigned int TimeDateStamp;
	unsigned __int16 MajorVersion;
	unsigned __int16 MinorVersion;
	unsigned int GlobalFlagsClear;
	unsigned int GlobalFlagsSet;
	unsigned int CriticalSectionDefaultTimeout;
	unsigned int DeCommitFreeBlockThreshold;
	unsigned int DeCommitTotalFreeThreshold;
	unsigned int LockPrefixTable;
	unsigned int MaximumAllocationSize;
	unsigned int VirtualMemoryThreshold;
	unsigned int ProcessHeapFlags;
	unsigned int ProcessAffinityMask;
	unsigned __int16 CSDVersion;
	unsigned __int16 Reserved1;
	unsigned int EditList;
	unsigned int SecurityCookie;
	unsigned int SEHandlerTable;
	unsigned int SEHandlerCount;
};
#pragma pack(pop)

/* 1714 */
#pragma pack(push, 1)
class _TRIVERTEX
{
	int x;
	int y;
	unsigned __int16 Red;
	unsigned __int16 Green;
	unsigned __int16 Blue;
	unsigned __int16 Alpha;
};
#pragma pack(pop)

/* 1715 */
#pragma pack(push, 1)
class __declspec(align(4)) _WIN_CERTIFICATE
{
	unsigned int dwLength;
	unsigned __int16 wRevision;
	unsigned __int16 wCertificateType;
	unsigned __int8 bCertificate[1];
};
#pragma pack(pop)

/* 1716 */
#pragma pack(push, 1)
class _WIN_SPUB_TRUSTED_PUBLISHER_DATA
{
	void* hClientToken;
	_WIN_CERTIFICATE* lpCertificate;
};
#pragma pack(pop)

/* 1717 */
#pragma pack(push, 1)
class _ACCESS_DENIED_ACE
{
	_ACE_HEADER Header;
	unsigned int Mask;
	unsigned int SidStart;
};
#pragma pack(pop)

/* 1718 */
#pragma pack(push, 1)
class __declspec(align(4)) tagTEXTMETRICW
{
	int tmHeight;
	int tmAscent;
	int tmDescent;
	int tmInternalLeading;
	int tmExternalLeading;
	int tmAveCharWidth;
	int tmMaxCharWidth;
	int tmWeight;
	int tmOverhang;
	int tmDigitizedAspectX;
	int tmDigitizedAspectY;
	unsigned __int16 tmFirstChar;
	unsigned __int16 tmLastChar;
	unsigned __int16 tmDefaultChar;
	unsigned __int16 tmBreakChar;
	unsigned __int8 tmItalic;
	unsigned __int8 tmUnderlined;
	unsigned __int8 tmStruckOut;
	unsigned __int8 tmPitchAndFamily;
	unsigned __int8 tmCharSet;
};
#pragma pack(pop)

/* 1719 */
#pragma pack(push, 1)
class _OUTLINETEXTMETRICW
{
	unsigned int otmSize;
	tagTEXTMETRICW otmTextMetrics;
	unsigned __int8 otmFiller;
	tagPANOSE otmPanoseNumber;
	__declspec(align(2)) unsigned int otmfsSelection;
	unsigned int otmfsType;
	int otmsCharSlopeRise;
	int otmsCharSlopeRun;
	int otmItalicAngle;
	unsigned int otmEMSquare;
	int otmAscent;
	int otmDescent;
	unsigned int otmLineGap;
	unsigned int otmsCapEmHeight;
	unsigned int otmsXHeight;
	tagRECT otmrcFontBox;
	int otmMacAscent;
	int otmMacDescent;
	unsigned int otmMacLineGap;
	unsigned int otmusMinimumPPEM;
	tagPOINT otmptSubscriptSize;
	tagPOINT otmptSubscriptOffset;
	tagPOINT otmptSuperscriptSize;
	tagPOINT otmptSuperscriptOffset;
	unsigned int otmsStrikeoutSize;
	int otmsStrikeoutPosition;
	int otmsUnderscoreSize;
	int otmsUnderscorePosition;
	char* otmpFamilyName;
	char* otmpFaceName;
	char* otmpStyleName;
	char* otmpFullName;
};
#pragma pack(pop)

/* 1720 */
#pragma pack(push, 1)
class _CERT_CRL_CONTEXT_PAIR
{
	const _CERT_CONTEXT* pCertContext;
	const _CRL_CONTEXT* pCrlContext;
};
#pragma pack(pop)

/* 1721 */
#pragma pack(push, 1)
class _DOCINFOA
{
	int cbSize;
	const char* lpszDocName;
	const char* lpszOutput;
	const char* lpszDatatype;
	unsigned int fwType;
};
#pragma pack(pop)

/* 1722 */
#pragma pack(push, 1)
class MENUITEMTEMPLATEHEADER
{
	unsigned __int16 versionNumber;
	unsigned __int16 offset;
};
#pragma pack(pop)

/* 1723 */
#pragma pack(push, 1)
class _SYSTEM_AUDIT_CALLBACK_ACE
{
	_ACE_HEADER Header;
	unsigned int Mask;
	unsigned int SidStart;
};
#pragma pack(pop)

/* 1724 */
#pragma pack(push, 1)
class _ACTIVATION_CONTEXT_BASIC_INFORMATION
{
	void* hActCtx;
	unsigned int dwFlags;
};
#pragma pack(pop)

/* 1725 */
#pragma pack(push, 1)
class tagWNDCLASSA
{
	unsigned int style;
	int(__stdcall* lpfnWndProc)(HWND__*, unsigned int, unsigned int, int);
	int cbClsExtra;
	int cbWndExtra;
	HINSTANCE__* hInstance;
	HICON__* hIcon;
	HICON__* hCursor;
	HBRUSH__* hbrBackground;
	const char* lpszMenuName;
	const char* lpszClassName;
};
#pragma pack(pop)

/* 1726 */
#pragma pack(push, 1)
class SPC_SIGINFO_
{
	unsigned int dwSipVersion;
	_GUID gSIPGuid;
	unsigned int dwReserved1;
	unsigned int dwReserved2;
	unsigned int dwReserved3;
	unsigned int dwReserved4;
	unsigned int dwReserved5;
};
#pragma pack(pop)

/* 1727 */
#pragma pack(push, 1)
class BITMAPV4HEADER
{
	unsigned int bV4Size;
	int bV4Width;
	int bV4Height;
	unsigned __int16 bV4Planes;
	unsigned __int16 bV4BitCount;
	unsigned int bV4V4Compression;
	unsigned int bV4SizeImage;
	int bV4XPelsPerMeter;
	int bV4YPelsPerMeter;
	unsigned int bV4ClrUsed;
	unsigned int bV4ClrImportant;
	unsigned int bV4RedMask;
	unsigned int bV4GreenMask;
	unsigned int bV4BlueMask;
	unsigned int bV4AlphaMask;
	unsigned int bV4CSType;
	tagICEXYZTRIPLE bV4Endpoints;
	unsigned int bV4GammaRed;
	unsigned int bV4GammaGreen;
	unsigned int bV4GammaBlue;
};
#pragma pack(pop)

/* 1728 */
#pragma pack(push, 1)
class _BLENDFUNCTION
{
	unsigned __int8 BlendOp;
	unsigned __int8 BlendFlags;
	unsigned __int8 SourceConstantAlpha;
	unsigned __int8 AlphaFormat;
};
#pragma pack(pop)

/* 1729 */
#pragma pack(push, 1)
class _PUBKEY
{
	unsigned int magic;
	unsigned int bitlen;
};
#pragma pack(pop)

/* 1730 */
#pragma pack(push, 1)
class _CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO
{
	unsigned int cbSize;
	_CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
	void* pvKeyEncryptionAuxInfo;
	unsigned int hCryptProv;
	_CRYPT_BIT_BLOB RecipientPublicKey;
	_CERT_ID RecipientId;
};
#pragma pack(pop)

/* 1731 */
#pragma pack(push, 1)
union $F8AD352E2713F2BBBE8E82FD04C949DB
{
	_CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO* pKeyTrans;
	_CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO* pKeyAgree;
	_CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO* pMailList;
};
#pragma pack(pop)

/* 1732 */
#pragma pack(push, 1)
class _CMSG_RECIPIENT_ENCODE_INFO
{
	unsigned int dwRecipientChoice;
	$F8AD352E2713F2BBBE8E82FD04C949DB ___u1;
};
#pragma pack(pop)

/* 1733 */
#pragma pack(push, 1)
class _CMSG_CONTENT_ENCRYPT_INFO
{
	unsigned int cbSize;
	unsigned int hCryptProv;
	_CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
	void* pvEncryptionAuxInfo;
	unsigned int cRecipients;
	_CMSG_RECIPIENT_ENCODE_INFO* rgCmsRecipients;
	void* (__stdcall* pfnAlloc)(unsigned int);
	void(__stdcall* pfnFree)(void*);
	unsigned int dwEncryptFlags;
	unsigned int hContentEncryptKey;
	unsigned int dwFlags;
};
#pragma pack(pop)

/* 1734 */
#pragma pack(push, 1)
class HUMPD__
{
	int unused;
};
#pragma pack(pop)

/* 1735 */
#pragma pack(push, 1)
class _CERT_PRIVATE_KEY_VALIDITY
{
	_FILETIME NotBefore;
	_FILETIME NotAfter;
};
#pragma pack(pop)

/* 1736 */
#pragma pack(push, 1)
class _CMSG_KEY_AGREE_KEY_ENCRYPT_INFO
{
	unsigned int cbSize;
	_CRYPTOAPI_BLOB EncryptedKey;
};
#pragma pack(pop)

/* 1737 */
#pragma pack(push, 1)
class _CMSG_KEY_AGREE_ENCRYPT_INFO
{
	unsigned int cbSize;
	unsigned int dwRecipientIndex;
	_CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
	_CRYPTOAPI_BLOB UserKeyingMaterial;
	unsigned int dwOriginatorChoice;
	$BD3DB4AA86CAA71A375F508BBF1007E2 ___u5;
	unsigned int cKeyAgreeKeyEncryptInfo;
	_CMSG_KEY_AGREE_KEY_ENCRYPT_INFO** rgpKeyAgreeKeyEncryptInfo;
	unsigned int dwFlags;
};
#pragma pack(pop)

/* 1738 */
#pragma pack(push, 1)
class _NETRESOURCEA
{
	unsigned int dwScope;
	unsigned int dwType;
	unsigned int dwDisplayType;
	unsigned int dwUsage;
	char* lpLocalName;
	char* lpRemoteName;
	char* lpComment;
	char* lpProvider;
};
#pragma pack(pop)

/* 1739 */
#pragma pack(push, 1)
class _KEY_TYPE_SUBTYPE
{
	unsigned int dwKeySpec;
	_GUID Type;
	_GUID Subtype;
};
#pragma pack(pop)

/* 1741 */
#pragma pack(push, 1)
class tagEMRCREATEDIBPATTERNBRUSHPT
{
	tagEMR emr;
	unsigned int ihBrush;
	unsigned int iUsage;
	unsigned int offBmi;
	unsigned int cbBmi;
	unsigned int offBits;
	unsigned int cbBits;
};
#pragma pack(pop)

/* 1742 */
#pragma pack(push, 1)
class SC_HANDLE__
{
	int unused;
};
#pragma pack(pop)

/* 1743 */
#pragma pack(push, 1)
class tagPOINTS
{
	__int16 x;
	__int16 y;
};
#pragma pack(pop)

/* 1744 */
#pragma pack(push, 1)
class tagMOUSEINPUT
{
	int dx;
	int dy;
	unsigned int mouseData;
	unsigned int dwFlags;
	unsigned int time;
	unsigned int dwExtraInfo;
};
#pragma pack(pop)

/* 1745 */
#pragma pack(push, 1)
class tagKEYBDINPUT
{
	unsigned __int16 wVk;
	unsigned __int16 wScan;
	unsigned int dwFlags;
	unsigned int time;
	unsigned int dwExtraInfo;
};
#pragma pack(pop)

/* 1746 */
#pragma pack(push, 1)
class tagHARDWAREINPUT
{
	unsigned int uMsg;
	unsigned __int16 wParamL;
	unsigned __int16 wParamH;
};
#pragma pack(pop)

/* 1747 */
#pragma pack(push, 1)
union $6D20CB587542601FD97386C02E1E14AE
{
	tagMOUSEINPUT mi;
	tagKEYBDINPUT ki;
	tagHARDWAREINPUT hi;
};
#pragma pack(pop)

/* 1748 */
#pragma pack(push, 1)
class tagINPUT
{
	unsigned int type;
	$6D20CB587542601FD97386C02E1E14AE ___u1;
};
#pragma pack(pop)

/* 1749 */
#pragma pack(push, 1)
class tagPOINTFX
{
	_FIXED x;
	_FIXED y;
};
#pragma pack(pop)

/* 1750 */
#pragma pack(push, 1)
class _PROV_ENUMALGS_EX
{
	unsigned int aiAlgid;
	unsigned int dwDefaultLen;
	unsigned int dwMinLen;
	unsigned int dwMaxLen;
	unsigned int dwProtocols;
	unsigned int dwNameLen;
	char szName[20];
	unsigned int dwLongNameLen;
	char szLongName[40];
};
#pragma pack(pop)

/* 1751 */
#pragma pack(push, 1)
class _CERT_X942_DH_VALIDATION_PARAMS
{
	_CRYPT_BIT_BLOB seed;
	unsigned int pgenCounter;
};
#pragma pack(pop)

/* 1752 */
#pragma pack(push, 1)
class _CERT_X942_DH_PARAMETERS
{
	_CRYPTOAPI_BLOB p;
	_CRYPTOAPI_BLOB g;
	_CRYPTOAPI_BLOB q;
	_CRYPTOAPI_BLOB j;
	_CERT_X942_DH_VALIDATION_PARAMS* pValidationParams;
};
#pragma pack(pop)

/* 1753 */
#pragma pack(push, 1)
class __declspec(align(4)) _COMMPROP
{
	unsigned __int16 wPacketLength;
	unsigned __int16 wPacketVersion;
	unsigned int dwServiceMask;
	unsigned int dwReserved1;
	unsigned int dwMaxTxQueue;
	unsigned int dwMaxRxQueue;
	unsigned int dwMaxBaud;
	unsigned int dwProvSubType;
	unsigned int dwProvCapabilities;
	unsigned int dwSettableParams;
	unsigned int dwSettableBaud;
	unsigned __int16 wSettableData;
	unsigned __int16 wSettableStopParity;
	unsigned int dwCurrentTxQueue;
	unsigned int dwCurrentRxQueue;
	unsigned int dwProvSpec1;
	unsigned int dwProvSpec2;
	unsigned __int16 wcProvChar[1];
};
#pragma pack(pop)

/* 1754 */
#pragma pack(push, 1)
class tagGUITHREADINFO
{
	unsigned int cbSize;
	unsigned int flags;
	HWND__* hwndActive;
	HWND__* hwndFocus;
	HWND__* hwndCapture;
	HWND__* hwndMenuOwner;
	HWND__* hwndMoveSize;
	HWND__* hwndCaret;
	tagRECT rcCaret;
};
#pragma pack(pop)

/* 1755 */
#pragma pack(push, 1)
class HDC__
{
	int unused;
};
#pragma pack(pop)

/* 1756 */
#pragma pack(push, 1)
class tagPAINTclass
{
	HDC__* hdc;
	int fErase;
	tagRECT rcPaint;
	int fRestore;
	int fIncUpdate;
	unsigned __int8 rgbReserved[32];
};
#pragma pack(pop)

/* 1757 */
#pragma pack(push, 1)
class _DISCDLGclassA
{
	unsigned int cbclassure;
	HWND__* hwndOwner;
	char* lpLocalName;
	char* lpRemoteName;
	unsigned int dwFlags;
};
#pragma pack(pop)

/* 1758 */
#pragma pack(push, 1)
class _QUERY_SERVICE_CONFIGW
{
	unsigned int dwServiceType;
	unsigned int dwStartType;
	unsigned int dwErrorControl;
	unsigned __int16* lpBinaryPathName;
	unsigned __int16* lpLoadOrderGroup;
	unsigned int dwTagId;
	unsigned __int16* lpDependencies;
	unsigned __int16* lpServiceStartName;
	unsigned __int16* lpDisplayName;
};
#pragma pack(pop)

/* 1759 */
#pragma pack(push, 1)
class _MINIDUMP_THREAD
{
	unsigned int ThreadId;
	unsigned int SuspendCount;
	unsigned int PriorityClass;
	unsigned int Priority;
	unsigned __int64 Teb;
	_MINIDUMP_MEMORY_DESCRIPTOR Stack;
	_MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
};
#pragma pack(pop)

/* 1760 */
#pragma pack(push, 1)
class HPALETTE__
{
	int unused;
};
#pragma pack(pop)

/* 1761 */
#pragma pack(push, 1)
class _IMAGEHLP_MODULE
{
	unsigned int SizeOfclass;
	unsigned int BaseOfImage;
	unsigned int ImageSize;
	unsigned int TimeDateStamp;
	unsigned int CheckSum;
	unsigned int NumSyms;
	SYM_TYPE SymType;
	char ModuleName[32];
	char ImageName[256];
	char LoadedImageName[256];
};
#pragma pack(pop)

/* 1762 */
#pragma pack(push, 1)
class _SINGLE_LIST_ENTRY
{
	_SINGLE_LIST_ENTRY* Next;
};
#pragma pack(pop)

/* 1763 */
#pragma pack(push, 1)
class _SYSTEM_ALARM_OBJECT_ACE
{
	_ACE_HEADER Header;
	unsigned int Mask;
	unsigned int Flags;
	_GUID ObjectType;
	_GUID InheritedObjectType;
	unsigned int SidStart;
};
#pragma pack(pop)

/* 1764 */
#pragma pack(push, 1)
class _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE
{
	_ACE_HEADER Header;
	unsigned int Mask;
	unsigned int Flags;
	_GUID ObjectType;
	_GUID InheritedObjectType;
	unsigned int SidStart;
};
#pragma pack(pop)

/* 1765 */
#pragma pack(push, 1)
class tagWNDCLASSEXW
{
	unsigned int cbSize;
	unsigned int style;
	int(__stdcall* lpfnWndProc)(HWND__*, unsigned int, unsigned int, int);
	int cbClsExtra;
	int cbWndExtra;
	HINSTANCE__* hInstance;
	HICON__* hIcon;
	HICON__* hCursor;
	HBRUSH__* hbrBackground;
	const unsigned __int16* lpszMenuName;
	const unsigned __int16* lpszClassName;
	HICON__* hIconSm;
};
#pragma pack(pop)

/* 1766 */
#pragma pack(push, 1)
class tagMONITORINFO
{
	unsigned int cbSize;
	tagRECT rcMonitor;
	tagRECT rcWork;
	unsigned int dwFlags;
};
#pragma pack(pop)

/* 1767 */
#pragma pack(push, 1)
class tagMONITORINFOEXA : tagMONITORINFO
{
	char szDevice[32];
};
#pragma pack(pop)

/* 1768 */
#pragma pack(push, 1)
class _CMSG_ENCRYPTED_ENCODE_INFO
{
	unsigned int cbSize;
	_CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
	void* pvEncryptionAuxInfo;
};
#pragma pack(pop)

/* 1769 */
#pragma pack(push, 1)
class __declspec(align(4)) tagEMRINVERTRGN
{
	tagEMR emr;
	_RECTL rclBounds;
	unsigned int cbRgnData;
	unsigned __int8 RgnData[1];
};
#pragma pack(pop)

/* 1770 */
#pragma pack(push, 1)
class __declspec(align(8)) _IMAGEHLP_CBA_READ_MEMORY
{
	unsigned __int64 addr;
	void* buf;
	unsigned int bytes;
	unsigned int* bytesread;
};
#pragma pack(pop)

/* 1771 */
#pragma pack(push, 1)
class _RTL_VERIFIER_THUNK_DESCRIPTOR
{
	char* ThunkName;
	void* ThunkOldAddress;
	void* ThunkNewAddress;
};
#pragma pack(pop)

/* 1772 */
#pragma pack(push, 1)
class _RTL_VERIFIER_DLL_DESCRIPTOR
{
	unsigned __int16* DllName;
	unsigned int DllFlags;
	void* DllAddress;
	_RTL_VERIFIER_THUNK_DESCRIPTOR* DllThunks;
};
#pragma pack(pop)

/* 1773 */
#pragma pack(push, 1)
class __declspec(align(4)) _MODEMSETTINGS
{
	unsigned int dwActualSize;
	unsigned int dwRequiredSize;
	unsigned int dwDevSpecificOffset;
	unsigned int dwDevSpecificSize;
	unsigned int dwCallSetupFailTimer;
	unsigned int dwInactivityTimeout;
	unsigned int dwSpeakerVolume;
	unsigned int dwSpeakerMode;
	unsigned int dwPreferredModemOptions;
	unsigned int dwNegotiatedModemOptions;
	unsigned int dwNegotiatedDCERate;
	unsigned __int8 abVariablePortion[1];
};
#pragma pack(pop)

/* 1774 */
#pragma pack(push, 1)
class tagRGBQUAD
{
	unsigned __int8 rgbBlue;
	unsigned __int8 rgbGreen;
	unsigned __int8 rgbRed;
	unsigned __int8 rgbReserved;
};
#pragma pack(pop)

/* 1775 */
#pragma pack(push, 1)
class tagBITMAPINFO
{
	tagBITMAPINFOHEADER bmiHeader;
	tagRGBQUAD bmiColors[1];
};
#pragma pack(pop)

/* 1776 */
#pragma pack(push, 1)
class _CERT_REVOCATION_PARA
{
	unsigned int cbSize;
	const _CERT_CONTEXT* pIssuerCert;
	unsigned int cCertStore;
	void** rgCertStore;
	void* hCrlStore;
	_FILETIME* pftTimeToUse;
};
#pragma pack(pop)

/* 1777 */
#pragma pack(push, 1)
class _CMSG_CTRL_DECRYPT_PARA
{
	unsigned int cbSize;
	unsigned int hCryptProv;
	unsigned int dwKeySpec;
	unsigned int dwRecipientIndex;
};
#pragma pack(pop)

/* 1778 */
#pragma pack(push, 1)
class _IMAGE_ROM_OPTIONAL_HEADER
{
	unsigned __int16 Magic;
	unsigned __int8 MajorLinkerVersion;
	unsigned __int8 MinorLinkerVersion;
	unsigned int SizeOfCode;
	unsigned int SizeOfInitializedData;
	unsigned int SizeOfUninitializedData;
	unsigned int AddressOfEntryPoint;
	unsigned int BaseOfCode;
	unsigned int BaseOfData;
	unsigned int BaseOfBss;
	unsigned int GprMask;
	unsigned int CprMask[4];
	unsigned int GpValue;
};
#pragma pack(pop)

/* 1779 */
#pragma pack(push, 1)
class _IMAGE_ROM_HEADERS
{
	_IMAGE_FILE_HEADER FileHeader;
	_IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
};
#pragma pack(pop)

/* 1780 */
#pragma pack(push, 1)
class tagSCROLLBARINFO
{
	unsigned int cbSize;
	tagRECT rcScrollBar;
	int dxyLineButton;
	int xyThumbTop;
	int xyThumbBottom;
	int reserved;
	unsigned int rgstate[6];
};
#pragma pack(pop)

/* 1781 */
#pragma pack(push, 1)
class __declspec(align(4)) _IMAGEHLP_SYMBOL
{
	unsigned int SizeOfclass;
	unsigned int Address;
	unsigned int Size;
	unsigned int Flags;
	unsigned int MaxNameLength;
	char Name[1];
};
#pragma pack(pop)

/* 1782 */
#pragma pack(push, 1)
class __declspec(align(4)) _IMAGEHLP_SYMBOL_PACKAGE
{
	_IMAGEHLP_SYMBOL sym;
	char name[2001];
};
#pragma pack(pop)

/* 1783 */
#pragma pack(push, 1)
class pvalueA
{
	char* pv_valuename;
	int pv_valuelen;
	void* pv_value_context;
	unsigned int pv_type;
};
#pragma pack(pop)

/* 1784 */
#pragma pack(push, 1)
class _TOKEN_USER
{
	_SID_AND_ATTRIBUTES User;
};
#pragma pack(pop)

/* 1785 */
#pragma pack(push, 1)
class tagEMREXTTEXTOUTA
{
	tagEMR emr;
	_RECTL rclBounds;
	unsigned int iGraphicsMode;
	float exScale;
	float eyScale;
	tagEMRTEXT emrtext;
};
#pragma pack(pop)

/* 1786 */
#pragma pack(push, 1)
class _CMSG_CMS_SIGNER_INFO
{
	unsigned int dwVersion;
	_CERT_ID SignerId;
	_CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
	_CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;
	_CRYPTOAPI_BLOB EncryptedHash;
	_CRYPT_ATTRIBUTES AuthAttrs;
	_CRYPT_ATTRIBUTES UnauthAttrs;
};
#pragma pack(pop)

/* 1787 */
#pragma pack(push, 1)
class _SPC_SERIALIZED_OBJECT
{
	unsigned __int8 ClassId[16];
	_CRYPTOAPI_BLOB SerializedData;
};
#pragma pack(pop)

/* 1788 */
#pragma pack(push, 1)
union $911073189106BD36AA086BC440C3277D
{
	unsigned __int16* pwszUrl;
	_SPC_SERIALIZED_OBJECT Moniker;
	unsigned __int16* pwszFile;
};
#pragma pack(pop)

/* 1789 */
#pragma pack(push, 1)
class SPC_LINK_
{
	unsigned int dwLinkChoice;
	$911073189106BD36AA086BC440C3277D ___u1;
};
#pragma pack(pop)

/* 1790 */
#pragma pack(push, 1)
class _SPC_IMAGE
{
	SPC_LINK_* pImageLink;
	_CRYPTOAPI_BLOB Bitmap;
	_CRYPTOAPI_BLOB Metafile;
	_CRYPTOAPI_BLOB EnhancedMetafile;
	_CRYPTOAPI_BLOB GifFile;
};
#pragma pack(pop)

/* 1791 */
#pragma pack(push, 1)
class _SPC_SP_AGENCY_INFO
{
	SPC_LINK_* pPolicyInformation;
	unsigned __int16* pwszPolicyDisplayText;
	_SPC_IMAGE* pLogoImage;
	SPC_LINK_* pLogoLink;
};
#pragma pack(pop)

/* 1792 */
#pragma pack(push, 1)
class tagEMRANGLEARC
{
	tagEMR emr;
	_POINTL ptlCenter;
	unsigned int nRadius;
	float eStartAngle;
	float eSweepAngle;
};
#pragma pack(pop)

/* 1793 */
#pragma pack(push, 1)
class tagCANDIDATEFORM
{
	unsigned int dwIndex;
	unsigned int dwStyle;
	tagPOINT ptCurrentPos;
	tagRECT rcArea;
};
#pragma pack(pop)

/* 1794 */
#pragma pack(push, 1)
class tagEMRSETARCDIRECTION
{
	tagEMR emr;
	unsigned int iArcDirection;
};
#pragma pack(pop)

/* 1795 */
#pragma pack(push, 1)
class __unaligned __declspec(align(2)) IMAGE_AUX_SYMBOL_TOKEN_DEF
{
	unsigned __int8 bAuxType;
	unsigned __int8 bReserved;
	unsigned int SymbolTableIndex;
	unsigned __int8 rgbReserved[12];
};
#pragma pack(pop)

/* 1796 */
#pragma pack(push, 1)
class tagLAYERPLANEDESCRIPTOR
{
	unsigned __int16 nSize;
	unsigned __int16 nVersion;
	unsigned int dwFlags;
	unsigned __int8 iPixelType;
	unsigned __int8 cColorBits;
	unsigned __int8 cRedBits;
	unsigned __int8 cRedShift;
	unsigned __int8 cGreenBits;
	unsigned __int8 cGreenShift;
	unsigned __int8 cBlueBits;
	unsigned __int8 cBlueShift;
	unsigned __int8 cAlphaBits;
	unsigned __int8 cAlphaShift;
	unsigned __int8 cAccumBits;
	unsigned __int8 cAccumRedBits;
	unsigned __int8 cAccumGreenBits;
	unsigned __int8 cAccumBlueBits;
	unsigned __int8 cAccumAlphaBits;
	unsigned __int8 cDepthBits;
	unsigned __int8 cStencilBits;
	unsigned __int8 cAuxBuffers;
	unsigned __int8 iLayerPlane;
	unsigned __int8 bReserved;
	unsigned int crTransparent;
};
#pragma pack(pop)

/* 1797 */
#pragma pack(push, 1)
class __declspec(align(8)) _TAPE_SET_POSITION
{
	unsigned int Method;
	unsigned int Partition;
	_LARGE_INTEGER Offset;
	unsigned __int8 Immediate;
};
#pragma pack(pop)

/* 1798 */
#pragma pack(push, 1)
class _numberfmtW
{
	unsigned int NumDigits;
	unsigned int LeadingZero;
	unsigned int Grouping;
	unsigned __int16* lpDecimalSep;
	unsigned __int16* lpThousandSep;
	unsigned int NegativeOrder;
};
#pragma pack(pop)

/* 1799 */
#pragma pack(push, 1)
class _CONNECTDLGclassA
{
	unsigned int cbclassure;
	HWND__* hwndOwner;
	_NETRESOURCEA* lpConnRes;
	unsigned int dwFlags;
	unsigned int dwDevNum;
};
#pragma pack(pop)

/* 1800 */
#pragma pack(push, 1)
class _CRYPT_PASSWORD_CREDENTIALSA
{
	unsigned int cbSize;
	char* pszUsername;
	char* pszPassword;
};
#pragma pack(pop)

/* 1801 */
#pragma pack(push, 1)
class _CERT_REQUEST_INFO
{
	unsigned int dwVersion;
	_CRYPTOAPI_BLOB Subject;
	_CERT_PUBLIC_KEY_INFO SubjectPublicKeyInfo;
	unsigned int cAttribute;
	_CRYPT_ATTRIBUTE* rgAttribute;
};
#pragma pack(pop)

/* 1802 */
#pragma pack(push, 1)
union $ECC5AAAE90C1068BF3960DB197C81D87
{
	unsigned int SymbolTableIndex;
	unsigned int VirtualAddress;
};
#pragma pack(pop)

/* 1803 */
#pragma pack(push, 1)
class _IMAGE_LINENUMBER
{
	$ECC5AAAE90C1068BF3960DB197C81D87 Type;
	unsigned __int16 Linenumber;
};
#pragma pack(pop)

/* 1804 */
#pragma pack(push, 1)
class _EXCEPTION_DEBUG_INFO
{
	_EXCEPTION_RECORD ExceptionRecord;
	unsigned int dwFirstChance;
};
#pragma pack(pop)

/* 1805 */
#pragma pack(push, 1)
class _CERT_POLICY_QUALIFIER_INFO
{
	char* pszPolicyQualifierId;
	_CRYPTOAPI_BLOB Qualifier;
};
#pragma pack(pop)

/* 1806 */
#pragma pack(push, 1)
class _CERT_POLICY_INFO
{
	char* pszPolicyIdentifier;
	unsigned int cPolicyQualifier;
	_CERT_POLICY_QUALIFIER_INFO* rgPolicyQualifier;
};
#pragma pack(pop)

/* 1807 */
#pragma pack(push, 1)
class _CERT_POLICIES_INFO
{
	unsigned int cPolicyInfo;
	_CERT_POLICY_INFO* rgPolicyInfo;
};
#pragma pack(pop)

/* 1808 */
#pragma pack(push, 1)
class _CMSG_CTRL_KEY_TRANS_DECRYPT_PARA
{
	unsigned int cbSize;
	unsigned int hCryptProv;
	unsigned int dwKeySpec;
	_CMSG_KEY_TRANS_RECIPIENT_INFO* pKeyTrans;
	unsigned int dwRecipientIndex;
};
#pragma pack(pop)

/* 1809 */
#pragma pack(push, 1)
class _DISPLAY_DEVICEA
{
	unsigned int cb;
	char DeviceName[32];
	char DeviceString[128];
	unsigned int StateFlags;
	char DeviceID[128];
	char DeviceKey[128];
};
#pragma pack(pop)

/* 1810 */
#pragma pack(push, 1)
class tagWCRANGE
{
	unsigned __int16 wcLow;
	unsigned __int16 cGlyphs;
};
#pragma pack(pop)

/* 1811 */
#pragma pack(push, 1)
class __declspec(align(4)) _IMAGE_DEBUG_MISC
{
	unsigned int DataType;
	unsigned int Length;
	unsigned __int8 Unicode;
	unsigned __int8 Reserved[3];
	unsigned __int8 Data[1];
};
#pragma pack(pop)

/* 1812 */
#pragma pack(push, 1)
class _CERT_PHYSICAL_STORE_INFO
{
	unsigned int cbSize;
	char* pszOpenStoreProvider;
	unsigned int dwOpenEncodingType;
	unsigned int dwOpenFlags;
	_CRYPTOAPI_BLOB OpenParameters;
	unsigned int dwFlags;
	unsigned int dwPriority;
};
#pragma pack(pop)

/* 1813 */
#pragma pack(push, 1)
class HENHMETAFILE__
{
	int unused;
};
#pragma pack(pop)

/* 1814 */
#pragma pack(push, 1)
class _CERT_KEYGEN_REQUEST_INFO
{
	unsigned int dwVersion;
	_CERT_PUBLIC_KEY_INFO SubjectPublicKeyInfo;
	unsigned __int16* pwszChallengeString;
};
#pragma pack(pop)

/* 1815 */
#pragma pack(push, 1)
class _MINIDUMP_FUNCTION_TABLE_STREAM
{
	unsigned int SizeOfHeader;
	unsigned int SizeOfDescriptor;
	unsigned int SizeOfNativeDescriptor;
	unsigned int SizeOfFunctionEntry;
	unsigned int NumberOfDescriptors;
	unsigned int SizeOfAlignPad;
};
#pragma pack(pop)

/* 1816 */
#pragma pack(push, 1)
class _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY
{
	unsigned int BeginAddress;
	unsigned int EndAddress;
	unsigned int ExceptionHandler;
	unsigned int HandlerData;
	unsigned int PrologEndAddress;
};
#pragma pack(pop)

/* 1817 */
#pragma pack(push, 1)
class _SOCKET_ADDRESS_LIST
{
	int iAddressCount;
	_SOCKET_ADDRESS Address[1];
};
#pragma pack(pop)

/* 1818 */
#pragma pack(push, 1)
class _MINIDUMP_INCLUDE_MODULE_CALLBACK
{
	unsigned __int64 BaseOfImage;
};
#pragma pack(pop)

/* 1819 */
#pragma pack(push, 1)
class _OSVERSIONINFOW
{
	unsigned int dwOSVersionInfoSize;
	unsigned int dwMajorVersion;
	unsigned int dwMinorVersion;
	unsigned int dwBuildNumber;
	unsigned int dwPlatformId;
	unsigned __int16 szCSDVersion[128];
};
#pragma pack(pop)

/* 1820 */
#pragma pack(push, 1)
class tagRECONVERTSTRING
{
	unsigned int dwSize;
	unsigned int dwVersion;
	unsigned int dwStrLen;
	unsigned int dwStrOffset;
	unsigned int dwCompStrLen;
	unsigned int dwCompStrOffset;
	unsigned int dwTargetStrLen;
	unsigned int dwTargetStrOffset;
};
#pragma pack(pop)

/* 1821 */
#pragma pack(push, 1)
class _EXCEPTION_RECORD32
{
	unsigned int ExceptionCode;
	unsigned int ExceptionFlags;
	unsigned int ExceptionRecord;
	unsigned int ExceptionAddress;
	unsigned int NumberParameters;
	unsigned int ExceptionInformation[15];
};
#pragma pack(pop)

/* 1822 */
#pragma pack(push, 1)
class _CRYPT_ENCODE_PARA
{
	unsigned int cbSize;
	void* (__stdcall* pfnAlloc)(unsigned int);
	void(__stdcall* pfnFree)(void*);
};
#pragma pack(pop)

/* 1823 */
#pragma pack(push, 1)
class __declspec(align(4)) tagEMREXTSELECTCLIPRGN
{
	tagEMR emr;
	unsigned int cbRgnData;
	unsigned int iMode;
	unsigned __int8 RgnData[1];
};
#pragma pack(pop)

/* 1824 */
#pragma pack(push, 1)
class _CERT_TEMPLATE_EXT
{
	char* pszObjId;
	unsigned int dwMajorVersion;
	int fMinorVersion;
	unsigned int dwMinorVersion;
};
#pragma pack(pop)

/* 1825 */
#pragma pack(push, 1)
class _STARTUPINFOW
{
	unsigned int cb;
	unsigned __int16* lpReserved;
	unsigned __int16* lpDesktop;
	unsigned __int16* lpTitle;
	unsigned int dwX;
	unsigned int dwY;
	unsigned int dwXSize;
	unsigned int dwYSize;
	unsigned int dwXCountChars;
	unsigned int dwYCountChars;
	unsigned int dwFillAttribute;
	unsigned int dwFlags;
	unsigned __int16 wShowWindow;
	unsigned __int16 cbReserved2;
	unsigned __int8* lpReserved2;
	void* hStdInput;
	void* hStdOutput;
	void* hStdError;
};
#pragma pack(pop)

/* 1826 */
#pragma pack(push, 1)
class tagSTICKYKEYS
{
	unsigned int cbSize;
	unsigned int dwFlags;
};
#pragma pack(pop)

/* 1827 */
#pragma pack(push, 1)
class tagTITLEBARINFO
{
	unsigned int cbSize;
	tagRECT rcTitleBar;
	unsigned int rgstate[6];
};
#pragma pack(pop)

/* 1828 */
#pragma pack(push, 1)
class _CERT_KEY_ATTRIBUTES_INFO
{
	_CRYPTOAPI_BLOB KeyId;
	_CRYPT_BIT_BLOB IntendedKeyUsage;
	_CERT_PRIVATE_KEY_VALIDITY* pPrivateKeyUsagePeriod;
};
#pragma pack(pop)

/* 1829 */
#pragma pack(push, 1)
class tagAXISINFOW
{
	int axMinValue;
	int axMaxValue;
	unsigned __int16 axAxisName[16];
};
#pragma pack(pop)

/* 1830 */
#pragma pack(push, 1)
class tagENUMLOGFONTA
{
	tagLOGFONTA elfLogFont;
	unsigned __int8 elfFullName[64];
	unsigned __int8 elfStyle[32];
};
#pragma pack(pop)

/* 1831 */
#pragma pack(push, 1)
class tagEMRALPHABLEND
{
	tagEMR emr;
	_RECTL rclBounds;
	int xDest;
	int yDest;
	int cxDest;
	int cyDest;
	unsigned int dwRop;
	int xSrc;
	int ySrc;
	tagXFORM xformSrc;
	unsigned int crBkColorSrc;
	unsigned int iUsageSrc;
	unsigned int offBmiSrc;
	unsigned int cbBmiSrc;
	unsigned int offBitsSrc;
	unsigned int cbBitsSrc;
	int cxSrc;
	int cySrc;
};
#pragma pack(pop)

/* 1832 */
#pragma pack(push, 1)
class tagMOUSEHOOKclass
{
	tagPOINT pt;
	HWND__* hwnd;
	unsigned int wHitTestCode;
	unsigned int dwExtraInfo;
};
#pragma pack(pop)

/* 1833 */
#pragma pack(push, 1)
class _CRYPT_CONTENT_INFO
{
	char* pszObjId;
	_CRYPTOAPI_BLOB Content;
};
#pragma pack(pop)

/* 1834 */
#pragma pack(push, 1)
class __declspec(align(4)) tagEMRGLSRECORD
{
	tagEMR emr;
	unsigned int cbData;
	unsigned __int8 Data[1];
};
#pragma pack(pop)

/* 1835 */
#pragma pack(push, 1)
class tagMOUSEKEYS
{
	unsigned int cbSize;
	unsigned int dwFlags;
	unsigned int iMaxSpeed;
	unsigned int iTimeToMaxSpeed;
	unsigned int iCtrlSpeed;
	unsigned int dwReserved1;
	unsigned int dwReserved2;
};
#pragma pack(pop)

/* 1836 */
#pragma pack(push, 1)
class HACCEL__
{
	int unused;
};
#pragma pack(pop)

/* 1837 */
#pragma pack(push, 1)
class _SPC_FINANCIAL_CRITERIA
{
	int fFinancialInfoAvailable;
	int fMeetsCriteria;
};
#pragma pack(pop)

/* 1838 */
#pragma pack(push, 1)
class tagEMRSTRETCHBLT
{
	tagEMR emr;
	_RECTL rclBounds;
	int xDest;
	int yDest;
	int cxDest;
	int cyDest;
	unsigned int dwRop;
	int xSrc;
	int ySrc;
	tagXFORM xformSrc;
	unsigned int crBkColorSrc;
	unsigned int iUsageSrc;
	unsigned int offBmiSrc;
	unsigned int cbBmiSrc;
	unsigned int offBitsSrc;
	unsigned int cbBitsSrc;
	int cxSrc;
	int cySrc;
};
#pragma pack(pop)

/* 1839 */
#pragma pack(push, 1)
class _ACCESS_DENIED_CALLBACK_ACE
{
	_ACE_HEADER Header;
	unsigned int Mask;
	unsigned int SidStart;
};
#pragma pack(pop)

/* 1840 */
#pragma pack(push, 1)
class _TOKEN_GROUPS
{
	unsigned int GroupCount;
	_SID_AND_ATTRIBUTES Groups[1];
};
#pragma pack(pop)

/* 1841 */
#pragma pack(push, 1)
class _TOKEN_PRIVILEGES
{
	unsigned int PrivilegeCount;
	_LUID_AND_ATTRIBUTES Privileges[1];
};
#pragma pack(pop)

/* 1842 */
#pragma pack(push, 1)
class _JOBOBJECT_SECURITY_LIMIT_INFORMATION
{
	unsigned int SecurityLimitFlags;
	void* JobToken;
	_TOKEN_GROUPS* SidsToDisable;
	_TOKEN_PRIVILEGES* PrivilegesToDelete;
	_TOKEN_GROUPS* RestrictedSids;
};
#pragma pack(pop)

/* 1843 */
#pragma pack(push, 1)
union $133E06CA0C5F994BAF18224C6D32BA1A
{
	unsigned int ForwarderString;
	unsigned int Function;
	unsigned int Ordinal;
	unsigned int AddressOfData;
};
#pragma pack(pop)

/* 1844 */
#pragma pack(push, 1)
class _IMAGE_THUNK_DATA32
{
	$133E06CA0C5F994BAF18224C6D32BA1A u1;
};
#pragma pack(pop)

/* 1845 */
#pragma pack(push, 1)
class _IMAGE_CE_RUNTIME_FUNCTION_ENTRY
{
	unsigned int FuncStart;
	unsigned __int32 PrologLen : 8;
	unsigned __int32 FuncLen : 22;
	unsigned __int32 ThirtyTwoBit : 1;
	unsigned __int32 ExceptionFlag : 1;
};
#pragma pack(pop)

/* 1846 */
#pragma pack(push, 1)
class tagSERIALKEYSA
{
	unsigned int cbSize;
	unsigned int dwFlags;
	char* lpszActivePort;
	char* lpszPort;
	unsigned int iBaudRate;
	unsigned int iPortState;
	unsigned int iActive;
};
#pragma pack(pop)

/* 1847 */
#pragma pack(push, 1)
class ANON_OBJECT_HEADER
{
	unsigned __int16 Sig1;
	unsigned __int16 Sig2;
	unsigned __int16 Version;
	unsigned __int16 Machine;
	unsigned int TimeDateStamp;
	_GUID ClassID;
	unsigned int SizeOfData;
};
#pragma pack(pop)

/* 1848 */
#pragma pack(push, 1)
class __declspec(align(4)) tagEMREXTESCAPE
{
	tagEMR emr;
	int iEscape;
	int cbEscData;
	unsigned __int8 EscData[1];
};
#pragma pack(pop)

/* 1849 */
#pragma pack(push, 1)
class tagLOGCOLORSPACEA
{
	unsigned int lcsSignature;
	unsigned int lcsVersion;
	unsigned int lcsSize;
	int lcsCSType;
	int lcsIntent;
	tagICEXYZTRIPLE lcsEndpoints;
	unsigned int lcsGammaRed;
	unsigned int lcsGammaGreen;
	unsigned int lcsGammaBlue;
	char lcsFilename[260];
};
#pragma pack(pop)

/* 1850 */
#pragma pack(push, 1)
class tagEMRCREATECOLORSPACE
{
	tagEMR emr;
	unsigned int ihCS;
	tagLOGCOLORSPACEA lcs;
};
#pragma pack(pop)

/* 1851 */
#pragma pack(push, 1)
class _MINIDUMP_USER_STREAM
{
	unsigned int Type;
	unsigned int BufferSize;
	void* Buffer;
};
#pragma pack(pop)

/* 1852 */
#pragma pack(push, 1)
class _WSAPROTOCOL_INFOW
{
	unsigned int dwServiceFlags1;
	unsigned int dwServiceFlags2;
	unsigned int dwServiceFlags3;
	unsigned int dwServiceFlags4;
	unsigned int dwProviderFlags;
	_GUID ProviderId;
	unsigned int dwCatalogEntryId;
	_WSAPROTOCOLCHAIN ProtocolChain;
	int iVersion;
	int iAddressFamily;
	int iMaxSockAddr;
	int iMinSockAddr;
	int iSocketType;
	int iProtocol;
	int iProtocolMaxOffset;
	int iNetworkByteOrder;
	int iSecurityScheme;
	unsigned int dwMessageSize;
	unsigned int dwProviderReserved;
	unsigned __int16 szProtocol[256];
};
#pragma pack(pop)

/* 1853 */
#pragma pack(push, 1)
class _IMAGE_VXD_HEADER
{
	unsigned __int16 e32_magic;
	unsigned __int8 e32_border;
	unsigned __int8 e32_worder;
	unsigned int e32_level;
	unsigned __int16 e32_cpu;
	unsigned __int16 e32_os;
	unsigned int e32_ver;
	unsigned int e32_mflags;
	unsigned int e32_mpages;
	unsigned int e32_startobj;
	unsigned int e32_eip;
	unsigned int e32_stackobj;
	unsigned int e32_esp;
	unsigned int e32_pagesize;
	unsigned int e32_lastpagesize;
	unsigned int e32_fixupsize;
	unsigned int e32_fixupsum;
	unsigned int e32_ldrsize;
	unsigned int e32_ldrsum;
	unsigned int e32_objtab;
	unsigned int e32_objcnt;
	unsigned int e32_objmap;
	unsigned int e32_itermap;
	unsigned int e32_rsrctab;
	unsigned int e32_rsrccnt;
	unsigned int e32_restab;
	unsigned int e32_enttab;
	unsigned int e32_dirtab;
	unsigned int e32_dircnt;
	unsigned int e32_fpagetab;
	unsigned int e32_frectab;
	unsigned int e32_impmod;
	unsigned int e32_impmodcnt;
	unsigned int e32_impproc;
	unsigned int e32_pagesum;
	unsigned int e32_datapage;
	unsigned int e32_preload;
	unsigned int e32_nrestab;
	unsigned int e32_cbnrestab;
	unsigned int e32_nressum;
	unsigned int e32_autodata;
	unsigned int e32_debuginfo;
	unsigned int e32_debuglen;
	unsigned int e32_instpreload;
	unsigned int e32_instdemand;
	unsigned int e32_heapsize;
	unsigned __int8 e32_res3[12];
	unsigned int e32_winresoff;
	unsigned int e32_winreslen;
	unsigned __int16 e32_devid;
	unsigned __int16 e32_ddkver;
};
#pragma pack(pop)

/* 1854 */
#pragma pack(push, 1)
class _MINIDUMP_EXCEPTION_INFORMATION
{
	unsigned int ThreadId;
	_EXCEPTION_POINTERS* ExceptionPointers;
	int ClientPointers;
};
#pragma pack(pop)

/* 1855 */
#pragma pack(push, 1)
class tagEMRSETWORLDTRANSFORM
{
	tagEMR emr;
	tagXFORM xform;
};
#pragma pack(pop)

/* 1856 */
#pragma pack(push, 1)
class _CERT_POLICY_MAPPING
{
	char* pszIssuerDomainPolicy;
	char* pszSubjectDomainPolicy;
};
#pragma pack(pop)

/* 1857 */
#pragma pack(push, 1)
class _CERT_POLICY_MAPPINGS_INFO
{
	unsigned int cPolicyMapping;
	_CERT_POLICY_MAPPING* rgPolicyMapping;
};
#pragma pack(pop)

/* 1858 */
#pragma pack(push, 1)
class __declspec(align(4)) tagMULTIKEYHELPA
{
	unsigned int mkSize;
	char mkKeylist;
	char szKeyphrase[1];
};
#pragma pack(pop)

/* 1859 */
#pragma pack(push, 1)
class _CMSG_MAIL_LIST_ENCRYPT_INFO
{
	unsigned int cbSize;
	unsigned int dwRecipientIndex;
	_CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
	_CRYPTOAPI_BLOB EncryptedKey;
	unsigned int dwFlags;
};
#pragma pack(pop)

/* 1860 */
#pragma pack(push, 1)
class _CERT_CHAIN_POLICY_PARA
{
	unsigned int cbSize;
	unsigned int dwFlags;
	void* pvExtraPolicyPara;
};
#pragma pack(pop)

/* 1861 */
#pragma pack(push, 1)
class _MINIDUMP_THREAD_EX
{
	unsigned int ThreadId;
	unsigned int SuspendCount;
	unsigned int PriorityClass;
	unsigned int Priority;
	unsigned __int64 Teb;
	_MINIDUMP_MEMORY_DESCRIPTOR Stack;
	_MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
	_MINIDUMP_MEMORY_DESCRIPTOR BackingStore;
};
#pragma pack(pop)

/* 1862 */
#pragma pack(push, 1)
class _MINIDUMP_THREAD_EX_LIST
{
	unsigned int NumberOfThreads;
	_MINIDUMP_THREAD_EX Threads[];
};
#pragma pack(pop)

/* 1863 */
#pragma pack(push, 1)
class _CERT_POLICY_CONSTRAINTS_INFO
{
	int fRequireExplicitPolicy;
	unsigned int dwRequireExplicitPolicySkipCerts;
	int fInhibitPolicyMapping;
	unsigned int dwInhibitPolicyMappingSkipCerts;
};
#pragma pack(pop)

/* 1864 */
#pragma pack(push, 1)
class _WIN32_FILE_ATTRIBUTE_DATA
{
	unsigned int dwFileAttributes;
	_FILETIME ftCreationTime;
	_FILETIME ftLastAccessTime;
	_FILETIME ftLastWriteTime;
	unsigned int nFileSizeHigh;
	unsigned int nFileSizeLow;
};
#pragma pack(pop)

/* 1865 */
#pragma pack(push, 1)
class _CRL_DIST_POINT_NAME
{
	unsigned int dwDistPointNameChoice;
	_CERT_ALT_NAME_INFO FullName;
};
#pragma pack(pop)

/* 1866 */
#pragma pack(push, 1)
class _CRYPT_PASSWORD_CREDENTIALSW
{
	unsigned int cbSize;
	unsigned __int16* pszUsername;
	unsigned __int16* pszPassword;
};
#pragma pack(pop)

/* 1867 */
#pragma pack(push, 1)
class _OSVERSIONINFOEXA
{
	unsigned int dwOSVersionInfoSize;
	unsigned int dwMajorVersion;
	unsigned int dwMinorVersion;
	unsigned int dwBuildNumber;
	unsigned int dwPlatformId;
	char szCSDVersion[128];
	unsigned __int16 wServicePackMajor;
	unsigned __int16 wServicePackMinor;
	unsigned __int16 wSuiteMask;
	unsigned __int8 wProductType;
	unsigned __int8 wReserved;
};
#pragma pack(pop)

/* 1868 */
#pragma pack(push, 1)
class _ImageArchitectureHeader
{
	unsigned __int32 AmaskValue : 1;
	unsigned __int32 : 7;
	unsigned __int32 AmaskShift : 8;
	unsigned int FirstEntryRVA;
};
#pragma pack(pop)

/* 1869 */
#pragma pack(push, 1)
class _SYSTEM_POWER_STATUS
{
	unsigned __int8 ACLineStatus;
	unsigned __int8 BatteryFlag;
	unsigned __int8 BatteryLifePercent;
	unsigned __int8 Reserved1;
	unsigned int BatteryLifeTime;
	unsigned int BatteryFullLifeTime;
};
#pragma pack(pop)

/* 1870 */
#pragma pack(push, 1)
class tagEMRPOLYLINE16
{
	tagEMR emr;
	_RECTL rclBounds;
	unsigned int cpts;
	tagPOINTS apts[1];
};
#pragma pack(pop)

/* 1871 */
#pragma pack(push, 1)
class __declspec(align(4)) tagMENUBARINFO
{
	unsigned int cbSize;
	tagRECT rcBar;
	HMENU__* hMenu;
	HWND__* hwndMenu;
	__int32 fBarFocused : 1;
	__int32 fFocused : 1;
};
#pragma pack(pop)

/* 1872 */
#pragma pack(push, 1)
class _WSABUF
{
	unsigned int len;
	char* buf;
};
#pragma pack(pop)

/* 1873 */
#pragma pack(push, 1)
class _IMAGEHLP_STACK_FRAME
{
	unsigned __int64 InclassionOffset;
	unsigned __int64 ReturnOffset;
	unsigned __int64 FrameOffset;
	unsigned __int64 StackOffset;
	unsigned __int64 BackingStoreOffset;
	unsigned __int64 FuncTableEntry;
	unsigned __int64 Params[4];
	unsigned __int64 Reserved[5];
	int Virtual;
	unsigned int Reserved2;
};
#pragma pack(pop)

/* 1874 */
#pragma pack(push, 1)
class _ACCESS_DENIED_CALLBACK_OBJECT_ACE
{
	_ACE_HEADER Header;
	unsigned int Mask;
	unsigned int Flags;
	_GUID ObjectType;
	_GUID InheritedObjectType;
	unsigned int SidStart;
};
#pragma pack(pop)

/* 1875 */
#pragma pack(push, 1)
class _CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY
{
	char* pszObjId;
	unsigned int cValue;
	_CRYPTOAPI_BLOB* rgValue;
};
#pragma pack(pop)

/* 1876 */
#pragma pack(push, 1)
class tagEMRSCALEVIEWPORTEXTEX
{
	tagEMR emr;
	int xNum;
	int xDenom;
	int yNum;
	int yDenom;
};
#pragma pack(pop)

/* 1877 */
#pragma pack(push, 1)
class __unaligned __declspec(align(2)) DLGTEMPLATE
{
	unsigned int style;
	unsigned int dwExtendedStyle;
	unsigned __int16 cdit;
	__int16 x;
	__int16 y;
	__int16 cx;
	__int16 cy;
};
#pragma pack(pop)

/* 1878 */
#pragma pack(push, 1)
class tagEMRELLIPSE
{
	tagEMR emr;
	_RECTL rclBox;
};
#pragma pack(pop)

/* 1879 */
#pragma pack(push, 1)
class _ACCESS_ALLOWED_ACE
{
	_ACE_HEADER Header;
	unsigned int Mask;
	unsigned int SidStart;
};
#pragma pack(pop)

/* 1880 */
#pragma pack(push, 1)
class $42AE40277E1C1D3B635A717FF8D62F0A
{
	unsigned __int8 Flags;
};
#pragma pack(pop)

/* 1881 */
#pragma pack(push, 1)
class $CBEC3B9BF01EE36D3DBBDBEC826F957A
{
	unsigned int NodeNumber;
};
#pragma pack(pop)

/* 1882 */
#pragma pack(push, 1)
union $288066C35EF69572DDCF65A320F973A1
{
	$42AE40277E1C1D3B635A717FF8D62F0A ProcessorCore;
	$CBEC3B9BF01EE36D3DBBDBEC826F957A NumaNode;
	unsigned __int64 Reserved[2];
};
#pragma pack(pop)

/* 1883 */
#pragma pack(push, 1)
class _SYSTEM_LOGICAL_PROCESSOR_INFORMATION
{
	unsigned int ProcessorMask;
	_LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
	$288066C35EF69572DDCF65A320F973A1 ___u2;
};
#pragma pack(pop)

/* 1884 */
#pragma pack(push, 1)
class tagENHMETAHEADER
{
	unsigned int iType;
	unsigned int nSize;
	_RECTL rclBounds;
	_RECTL rclFrame;
	unsigned int dSignature;
	unsigned int nVersion;
	unsigned int nBytes;
	unsigned int nRecords;
	unsigned __int16 nHandles;
	unsigned __int16 sReserved;
	unsigned int nDescription;
	unsigned int offDescription;
	unsigned int nPalEntries;
	tagSIZE szlDevice;
	tagSIZE szlMillimeters;
	unsigned int cbPixelFormat;
	unsigned int offPixelFormat;
	unsigned int bOpenGL;
	tagSIZE szlMicrometers;
};
#pragma pack(pop)

/* 1885 */
#pragma pack(push, 1)
class _CMSG_CTRL_KEY_AGREE_DECRYPT_PARA
{
	unsigned int cbSize;
	unsigned int hCryptProv;
	unsigned int dwKeySpec;
	_CMSG_KEY_AGREE_RECIPIENT_INFO* pKeyAgree;
	unsigned int dwRecipientIndex;
	unsigned int dwRecipientEncryptedKeyIndex;
	_CRYPT_BIT_BLOB OriginatorPublicKey;
};
#pragma pack(pop)

/* 1886 */
#pragma pack(push, 1)
class _TAPE_WMI_OPERATIONS
{
	unsigned int Method;
	unsigned int DataBufferSize;
	void* DataBuffer;
};
#pragma pack(pop)

/* 1887 */
#pragma pack(push, 1)
class _devicemodeW
{
	unsigned __int16 dmDeviceName[32];
	unsigned __int16 dmSpecVersion;
	unsigned __int16 dmDriverVersion;
	unsigned __int16 dmSize;
	unsigned __int16 dmDriverExtra;
	unsigned int dmFields;
	$B214638B2B9F4E804A25A19C0B009811 ___u6;
	$4AE569E07E0C6BDAC050E3B1D58D39AB ___u7;
	$C3D1C278DD39211D4F47C1A8502F0DDF ___u8;
	__int16 dmColor;
	__int16 dmDuplex;
	__int16 dmYResolution;
	__int16 dmTTOption;
	__int16 dmCollate;
	unsigned __int16 dmFormName[32];
	unsigned __int16 dmLogPixels;
	unsigned int dmBitsPerPel;
	unsigned int dmPelsWidth;
	unsigned int dmPelsHeight;
	$A5EB585472B52579A766EE2CB9D45D8B ___u19;
	unsigned int dmDisplayFrequency;
	unsigned int dmICMMethod;
	unsigned int dmICMIntent;
	unsigned int dmMediaType;
	unsigned int dmDitherType;
	unsigned int dmReserved1;
	unsigned int dmReserved2;
	unsigned int dmPanningWidth;
	unsigned int dmPanningHeight;
};
#pragma pack(pop)

/* 1888 */
#pragma pack(push, 1)
class _CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA
{
	unsigned int cOID;
	char** rgpszOID;
};
#pragma pack(pop)

/* 1889 */
#pragma pack(push, 1)
class _WSANAMESPACE_INFOW
{
	_GUID NSProviderId;
	unsigned int dwNameSpace;
	int fActive;
	unsigned int dwVersion;
	unsigned __int16* lpszIdentifier;
};
#pragma pack(pop)

/* 1890 */
#pragma pack(push, 1)
class HFONT__
{
	int unused;
};
#pragma pack(pop)

/* 1891 */
#pragma pack(push, 1)
class tagMOUSEMOVEPOINT
{
	int x;
	int y;
	unsigned int time;
	unsigned int dwExtraInfo;
};
#pragma pack(pop)

/* 1892 */
#pragma pack(push, 1)
class tagHIGHCONTRASTA
{
	unsigned int cbSize;
	unsigned int dwFlags;
	char* lpszDefaultScheme;
};
#pragma pack(pop)

/* 1893 */
#pragma pack(push, 1)
class _CERT_AUTHORITY_INFO_ACCESS
{
	unsigned int cAccDescr;
	_CERT_ACCESS_DESCRIPTION* rgAccDescr;
};
#pragma pack(pop)

/* 1894 */
#pragma pack(push, 1)
class _MINIDUMP_THREAD_CALLBACK
{
	unsigned int ThreadId;
	void* ThreadHandle;
	_CONTEXT Context;
	unsigned int SizeOfContext;
	unsigned __int64 StackBase;
	unsigned __int64 StackEnd;
};
#pragma pack(pop)

/* 1895 */
#pragma pack(push, 1)
class _MINIDUMP_THREAD_EX_CALLBACK
{
	unsigned int ThreadId;
	void* ThreadHandle;
	_CONTEXT Context;
	unsigned int SizeOfContext;
	unsigned __int64 StackBase;
	unsigned __int64 StackEnd;
	unsigned __int64 BackingStoreBase;
	unsigned __int64 BackingStoreEnd;
};
#pragma pack(pop)

/* 1896 */
#pragma pack(push, 1)
class tagVS_FIXEDFILEINFO
{
	unsigned int dwSignature;
	unsigned int dwStrucVersion;
	unsigned int dwFileVersionMS;
	unsigned int dwFileVersionLS;
	unsigned int dwProductVersionMS;
	unsigned int dwProductVersionLS;
	unsigned int dwFileFlagsMask;
	unsigned int dwFileFlags;
	unsigned int dwFileOS;
	unsigned int dwFileType;
	unsigned int dwFileSubtype;
	unsigned int dwFileDateMS;
	unsigned int dwFileDateLS;
};
#pragma pack(pop)

/* 1897 */
#pragma pack(push, 1)
class __unaligned __declspec(align(4)) _MINIDUMP_MODULE_CALLBACK
{
	unsigned __int16* FullPath;
	unsigned __int64 BaseOfImage;
	unsigned int SizeOfImage;
	unsigned int CheckSum;
	unsigned int TimeDateStamp;
	tagVS_FIXEDFILEINFO VersionInfo;
	void* CvRecord;
	unsigned int SizeOfCvRecord;
	void* MiscRecord;
	unsigned int SizeOfMiscRecord;
};
#pragma pack(pop)

/* 1898 */
#pragma pack(push, 1)
class _MINIDUMP_INCLUDE_THREAD_CALLBACK
{
	unsigned int ThreadId;
};
#pragma pack(pop)

/* 1899 */
#pragma pack(push, 1)
union $5EF251E131C4A805EC54891AF44B832C
{
	_MINIDUMP_THREAD_CALLBACK Thread;
	_MINIDUMP_THREAD_EX_CALLBACK ThreadEx;
	_MINIDUMP_MODULE_CALLBACK Module;
	_MINIDUMP_INCLUDE_THREAD_CALLBACK IncludeThread;
	_MINIDUMP_INCLUDE_MODULE_CALLBACK IncludeModule;
};
#pragma pack(pop)

/* 1900 */
#pragma pack(push, 1)
class _MINIDUMP_CALLBACK_INPUT
{
	unsigned int ProcessId;
	void* ProcessHandle;
	unsigned int CallbackType;
	$5EF251E131C4A805EC54891AF44B832C ___u3;
};
#pragma pack(pop)

/* 1901 */
#pragma pack(push, 1)
union $4134912AD5D27FD0048D3BC34FC8BADF
{
	unsigned int ModuleWriteFlags;
	unsigned int ThreadWriteFlags;
};
#pragma pack(pop)

/* 1902 */
#pragma pack(push, 1)
class _MINIDUMP_CALLBACK_OUTPUT
{
	$4134912AD5D27FD0048D3BC34FC8BADF ___u0;
};
#pragma pack(pop)

/* 1903 */
#pragma pack(push, 1)
class _MINIDUMP_CALLBACK_INFORMATION
{
	int(__stdcall* CallbackRoutine)(void*, _MINIDUMP_CALLBACK_INPUT* const, _MINIDUMP_CALLBACK_OUTPUT*);
	void* CallbackParam;
};
#pragma pack(pop)

/* 1904 */
#pragma pack(push, 1)
class _WSANSClassInfoW
{
	unsigned __int16* lpszName;
	unsigned int dwNameSpace;
	unsigned int dwValueType;
	unsigned int dwValueSize;
	void* lpValue;
};
#pragma pack(pop)

/* 1905 */
#pragma pack(push, 1)
class _OSVERSIONINFOA
{
	unsigned int dwOSVersionInfoSize;
	unsigned int dwMajorVersion;
	unsigned int dwMinorVersion;
	unsigned int dwBuildNumber;
	unsigned int dwPlatformId;
	char szCSDVersion[128];
};
#pragma pack(pop)

/* 1906 */
#pragma pack(push, 1)
class __declspec(align(4)) tagEMRSETICMPROFILE
{
	tagEMR emr;
	unsigned int dwFlags;
	unsigned int cbName;
	unsigned int cbData;
	unsigned __int8 Data[1];
};
#pragma pack(pop)

/* 1907 */
#pragma pack(push, 1)
class _CERT_GENERAL_SUBTREE
{
	_CERT_ALT_NAME_ENTRY Base;
	unsigned int dwMinimum;
	int fMaximum;
	unsigned int dwMaximum;
};
#pragma pack(pop)

/* 1908 */
#pragma pack(push, 1)
class _CERT_KEY_CONTEXT
{
	unsigned int cbSize;
	unsigned int hCryptProv;
	unsigned int dwKeySpec;
};
#pragma pack(pop)

/* 1909 */
#pragma pack(push, 1)
class _IMAGE_BASE_RELOCATION
{
	unsigned int VirtualAddress;
	unsigned int SizeOfBlock;
};
#pragma pack(pop)

/* 1910 */
#pragma pack(push, 1)
union $D11C86C2E7A169F93BA82ECD3DB18350
{
	unsigned int cbclass;
	unsigned int cbSize;
};
#pragma pack(pop)

/* 1911 */
#pragma pack(push, 1)
class _HTTPSPolicyCallbackData
{
	$D11C86C2E7A169F93BA82ECD3DB18350 ___u0;
	unsigned int dwAuthType;
	unsigned int fdwChecks;
	unsigned __int16* pwszServerName;
};
#pragma pack(pop)

/* 1912 */
#pragma pack(push, 1)
class tagCANDIDATELIST
{
	unsigned int dwSize;
	unsigned int dwStyle;
	unsigned int dwCount;
	unsigned int dwSelection;
	unsigned int dwPageStart;
	unsigned int dwPageSize;
	unsigned int dwOffset[1];
};
#pragma pack(pop)

/* 1913 */
#pragma pack(push, 1)
class tagACCESSTIMEOUT
{
	unsigned int cbSize;
	unsigned int dwFlags;
	unsigned int iTimeOutMSec;
};
#pragma pack(pop)

/* 1914 */
#pragma pack(push, 1)
class _CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA
{
	unsigned int cbSize;
	unsigned int dwSignerIndex;
	_CRYPTOAPI_BLOB blob;
};
#pragma pack(pop)

/* 1915 */
#pragma pack(push, 1)
class _JOBOBJECT_ASSOCIATE_COMPLETION_PORT
{
	void* CompletionKey;
	void* CompletionPort;
};
#pragma pack(pop)

/* 1916 */
#pragma pack(push, 1)
class HWINEVENTHOOK__
{
	int unused;
};
#pragma pack(pop)

/* 1917 */
#pragma pack(push, 1)
class _CMC_TAGGED_CERT_REQUEST
{
	unsigned int dwBodyPartID;
	_CRYPTOAPI_BLOB SignedCertRequest;
};
#pragma pack(pop)

/* 1918 */
#pragma pack(push, 1)
class _CMC_TAGGED_REQUEST
{
	unsigned int dwTaggedRequestChoice;
	_CMC_TAGGED_CERT_REQUEST* pTaggedCertRequest;
};
#pragma pack(pop)

/* 1919 */
#pragma pack(push, 1)
class tagMENUGETOBJECTINFO
{
	unsigned int dwFlags;
	unsigned int uPos;
	HMENU__* hmenu;
	void* riid;
	void* pvObj;
};
#pragma pack(pop)

/* 1920 */
#pragma pack(push, 1)
class _CMS_KEY_INFO
{
	unsigned int dwVersion;
	unsigned int Algid;
	unsigned __int8* pbOID;
	unsigned int cbOID;
};
#pragma pack(pop)

/* 1921 */
#pragma pack(push, 1)
class _CTL_VERIFY_USAGE_PARA
{
	unsigned int cbSize;
	_CRYPTOAPI_BLOB ListIdentifier;
	unsigned int cCtlStore;
	void** rghCtlStore;
	unsigned int cSignerStore;
	void** rghSignerStore;
};
#pragma pack(pop)

/* 1922 */
#pragma pack(push, 1)
class _MINIDUMP_UNLOADED_MODULE_LIST
{
	unsigned int SizeOfHeader;
	unsigned int SizeOfEntry;
	unsigned int NumberOfEntries;
};
#pragma pack(pop)

/* 1923 */
#pragma pack(push, 1)
class _CMSG_KEY_TRANS_ENCRYPT_INFO
{
	unsigned int cbSize;
	unsigned int dwRecipientIndex;
	_CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
	_CRYPTOAPI_BLOB EncryptedKey;
	unsigned int dwFlags;
};
#pragma pack(pop)

/* 1924 */
#pragma pack(push, 1)
class __declspec(align(2)) _MESSAGE_RESOURCE_ENTRY
{
	unsigned __int16 Length;
	unsigned __int16 Flags;
	unsigned __int8 Text[1];
};
#pragma pack(pop)

/* 1925 */
#pragma pack(push, 1)
class tagHIGHCONTRASTW
{
	unsigned int cbSize;
	unsigned int dwFlags;
	unsigned __int16* lpszDefaultScheme;
};
#pragma pack(pop)

/* 1926 */
#pragma pack(push, 1)
class _CRYPT_RETRIEVE_AUX_INFO
{
	unsigned int cbSize;
	_FILETIME* pLastSyncTime;
	unsigned int dwMaxUrlRetrievalByteCount;
};
#pragma pack(pop)

/* 1927 */
#pragma pack(push, 1)
class __unaligned __declspec(align(4)) _MINIDUMP_MODULE
{
	unsigned __int64 BaseOfImage;
	unsigned int SizeOfImage;
	unsigned int CheckSum;
	unsigned int TimeDateStamp;
	unsigned int ModuleNameRva;
	tagVS_FIXEDFILEINFO VersionInfo;
	_MINIDUMP_LOCATION_DESCRIPTOR CvRecord;
	_MINIDUMP_LOCATION_DESCRIPTOR MiscRecord;
	unsigned __int64 Reserved0;
	unsigned __int64 Reserved1;
};
#pragma pack(pop)

/* 1928 */
#pragma pack(push, 1)
class tagPOLYTEXTW
{
	int x;
	int y;
	unsigned int n;
	const unsigned __int16* lpstr;
	unsigned int uiFlags;
	tagRECT rcl;
	int* pdx;
};
#pragma pack(pop)

/* 1929 */
#pragma pack(push, 1)
class _CRL_REVOCATION_INFO
{
	_CRL_ENTRY* pCrlEntry;
	const _CRL_CONTEXT* pCrlContext;
	const _CERT_CHAIN_CONTEXT* pCrlIssuerChain;
};
#pragma pack(pop)

/* 1930 */
#pragma pack(push, 1)
class _flowspec
{
	unsigned int TokenRate;
	unsigned int TokenBucketSize;
	unsigned int PeakBandwidth;
	unsigned int Latency;
	unsigned int DelayVariation;
	unsigned int ServiceType;
	unsigned int MaxSduSize;
	unsigned int MinimumPolicedSize;
};
#pragma pack(pop)

/* 1931 */
#pragma pack(push, 1)
class _QualityOfService
{
	_flowspec SendingFlowspec;
	_flowspec ReceivingFlowspec;
	_WSABUF ProviderSpecific;
};
#pragma pack(pop)

/* 1932 */
#pragma pack(push, 1)
class SYSTEM_BATTERY_STATE
{
	unsigned __int8 AcOnLine;
	unsigned __int8 BatteryPresent;
	unsigned __int8 Charging;
	unsigned __int8 Discharging;
	unsigned __int8 Spare1[4];
	unsigned int MaxCapacity;
	unsigned int RemainingCapacity;
	unsigned int Rate;
	unsigned int EstimatedTime;
	unsigned int DefaultAlert1;
	unsigned int DefaultAlert2;
};
#pragma pack(pop)

/* 1933 */
#pragma pack(push, 1)
class tagICONMETRICSA
{
	unsigned int cbSize;
	int iHorzSpacing;
	int iVertSpacing;
	int iTitleWrap;
	tagLOGFONTA lfFont;
};
#pragma pack(pop)

/* 1934 */
#pragma pack(push, 1)
class _nlsversioninfo
{
	unsigned int dwNLSVersionInfoSize;
	unsigned int dwNLSVersion;
	unsigned int dwDefinedVersion;
};
#pragma pack(pop)

/* 1935 */
#pragma pack(push, 1)
class HMETAFILE__
{
	int unused;
};
#pragma pack(pop)

/* 1936 */
#pragma pack(push, 1)
class tagMETAFILEPICT
{
	int mm;
	int xExt;
	int yExt;
	HMETAFILE__* hMF;
};
#pragma pack(pop)

/* 1937 */
#pragma pack(push, 1)
class tagAXESLISTW
{
	unsigned int axlReserved;
	unsigned int axlNumAxes;
	tagAXISINFOW axlAxisInfo[16];
};
#pragma pack(pop)

/* 1938 */
#pragma pack(push, 1)
class _FOCUS_EVENT_RECORD
{
	int bSetFocus;
};
#pragma pack(pop)

/* 1939 */
#pragma pack(push, 1)
class _CRYPT_HASH_MESSAGE_PARA
{
	unsigned int cbSize;
	unsigned int dwMsgEncodingType;
	unsigned int hCryptProv;
	_CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
	void* pvHashAuxInfo;
};
#pragma pack(pop)

/* 1940 */
#pragma pack(push, 1)
class _KDHELP64
{
	unsigned __int64 Thread;
	unsigned int ThCallbackStack;
	unsigned int ThCallbackBStore;
	unsigned int NextCallback;
	unsigned int FramePointer;
	unsigned __int64 KiCallUserMode;
	unsigned __int64 KeUserCallbackDispatcher;
	unsigned __int64 SystemRangeStart;
	unsigned __int64 Reserved[8];
};
#pragma pack(pop)

/* 1941 */
#pragma pack(push, 1)
class _tagSTACKFRAME64
{
	_tagADDRESS64 AddrPC;
	_tagADDRESS64 AddrReturn;
	_tagADDRESS64 AddrFrame;
	_tagADDRESS64 AddrStack;
	_tagADDRESS64 AddrBStore;
	void* FuncTableEntry;
	__declspec(align(8)) unsigned __int64 Params[4];
	int Far;
	int Virtual;
	unsigned __int64 Reserved[3];
	_KDHELP64 KdHelp;
};
#pragma pack(pop)

/* 1942 */
#pragma pack(push, 1)
class _CERT_BASIC_CONSTRAINTS_INFO
{
	_CRYPT_BIT_BLOB SubjectType;
	int fPathLenConstraint;
	unsigned int dwPathLenConstraint;
	unsigned int cSubtreesConstraint;
	_CRYPTOAPI_BLOB* rgSubtreesConstraint;
};
#pragma pack(pop)

/* 1943 */
#pragma pack(push, 1)
class tagHELPWININFOW
{
	int wclassSize;
	int x;
	int y;
	int dx;
	int dy;
	int wMax;
	unsigned __int16 rgchMember[2];
};
#pragma pack(pop)

/* 1944 */
#pragma pack(push, 1)
class _numberfmtA
{
	unsigned int NumDigits;
	unsigned int LeadingZero;
	unsigned int Grouping;
	char* lpDecimalSep;
	char* lpThousandSep;
	unsigned int NegativeOrder;
};
#pragma pack(pop)

/* 1945 */
#pragma pack(push, 1)
class _CERT_STORE_PROV_FIND_INFO
{
	unsigned int cbSize;
	unsigned int dwMsgAndCertEncodingType;
	unsigned int dwFindFlags;
	unsigned int dwFindType;
	const void* pvFindPara;
};
#pragma pack(pop)

/* 1946 */
#pragma pack(push, 1)
class _WSAServiceClassInfoW
{
	_GUID* lpServiceClassId;
	unsigned __int16* lpszServiceClassName;
	unsigned int dwCount;
	_WSANSClassInfoW* lpClassInfos;
};
#pragma pack(pop)

/* 1947 */
#pragma pack(push, 1)
class tagHANDLETABLE
{
	void* objectHandle[1];
};
#pragma pack(pop)

/* 1948 */
#pragma pack(push, 1)
class tagSOUNDSENTRYA
{
	unsigned int cbSize;
	unsigned int dwFlags;
	unsigned int iFSTextEffect;
	unsigned int iFSTextEffectMSec;
	unsigned int iFSTextEffectColorBits;
	unsigned int iFSGrafEffect;
	unsigned int iFSGrafEffectMSec;
	unsigned int iFSGrafEffectColor;
	unsigned int iWindowsEffect;
	unsigned int iWindowsEffectMSec;
	char* lpszWindowsEffectDLL;
	unsigned int iWindowsEffectOrdinal;
};
#pragma pack(pop)

/* 1949 */
#pragma pack(push, 1)
class _IMAGE_RESOURCE_DATA_ENTRY
{
	unsigned int OffsetToData;
	unsigned int Size;
	unsigned int CodePage;
	unsigned int Reserved;
};
#pragma pack(pop)

/* 1950 */
#pragma pack(push, 1)
class _COMMTIMEOUTS
{
	unsigned int ReadIntervalTimeout;
	unsigned int ReadTotalTimeoutMultiplier;
	unsigned int ReadTotalTimeoutConstant;
	unsigned int WriteTotalTimeoutMultiplier;
	unsigned int WriteTotalTimeoutConstant;
};
#pragma pack(pop)

/* 1951 */
#pragma pack(push, 1)
class _SYSTEM_ALARM_CALLBACK_OBJECT_ACE
{
	_ACE_HEADER Header;
	unsigned int Mask;
	unsigned int Flags;
	_GUID ObjectType;
	_GUID InheritedObjectType;
	unsigned int SidStart;
};
#pragma pack(pop)

/* 1952 */
#pragma pack(push, 1)
class _EXIT_PROCESS_DEBUG_INFO
{
	unsigned int dwExitCode;
};
#pragma pack(pop)

/* 1953 */
#pragma pack(push, 1)
class _CMC_ADD_ATTRIBUTES_INFO
{
	unsigned int dwCmcDataReference;
	unsigned int cCertReference;
	unsigned int* rgdwCertReference;
	unsigned int cAttribute;
	_CRYPT_ATTRIBUTE* rgAttribute;
};
#pragma pack(pop)

/* 1954 */
#pragma pack(push, 1)
class __declspec(align(8)) _SOURCEFILE
{
	unsigned __int64 ModBase;
	char* FileName;
};
#pragma pack(pop)

/* 1955 */
#pragma pack(push, 1)
class _ImageArchitectureEntry
{
	unsigned int FixupInstRVA;
	unsigned int NewInst;
};
#pragma pack(pop)

/* 1956 */
#pragma pack(push, 1)
union $B06B32FD8C111283CFE7E6676DA1486C
{
	unsigned __int16 Ordinal;
	unsigned __int16 Hint;
};
#pragma pack(pop)

/* 1957 */
#pragma pack(push, 1)
class IMPORT_OBJECT_HEADER
{
	unsigned __int16 Sig1;
	unsigned __int16 Sig2;
	unsigned __int16 Version;
	unsigned __int16 Machine;
	unsigned int TimeDateStamp;
	unsigned int SizeOfData;
	$B06B32FD8C111283CFE7E6676DA1486C ___u6;
	unsigned __int16 Type : 2;
	unsigned __int16 NameType : 3;
	unsigned __int16 Reserved : 11;
};
#pragma pack(pop)

/* 1958 */
#pragma pack(push, 1)
class tagMSGBOXPARAMSW
{
	unsigned int cbSize;
	HWND__* hwndOwner;
	HINSTANCE__* hInstance;
	const unsigned __int16* lpszText;
	const unsigned __int16* lpszCaption;
	unsigned int dwStyle;
	const unsigned __int16* lpszIcon;
	unsigned int dwContextHelpId;
	void(__stdcall* lpfnMsgBoxCallback)(tagHELPINFO*);
	unsigned int dwLanguageId;
};
#pragma pack(pop)

/* 1959 */
#pragma pack(push, 1)
class _IMAGEHLP_DEFERRED_SYMBOL_LOAD64
{
	unsigned int SizeOfclass;
	__declspec(align(8)) unsigned __int64 BaseOfImage;
	unsigned int CheckSum;
	unsigned int TimeDateStamp;
	char FileName[260];
	unsigned __int8 Reparse;
	__declspec(align(4)) void* hFile;
	unsigned int Flags;
};
#pragma pack(pop)

/* 1960 */
#pragma pack(push, 1)
class _CRYPT_TIME_STAMP_REQUEST_INFO
{
	char* pszTimeStampAlgorithm;
	char* pszContentType;
	_CRYPTOAPI_BLOB Content;
	unsigned int cAttribute;
	_CRYPT_ATTRIBUTE* rgAttribute;
};
#pragma pack(pop)

/* 1961 */
#pragma pack(push, 1)
class tagMSG
{
	HWND__* hwnd;
	unsigned int message;
	unsigned int wParam;
	int lParam;
	unsigned int time;
	tagPOINT pt;
};
#pragma pack(pop)

/* 1962 */
#pragma pack(push, 1)
class _WSAServiceClassInfoA
{
	_GUID* lpServiceClassId;
	char* lpszServiceClassName;
	unsigned int dwCount;
	_WSANSClassInfoA* lpClassInfos;
};
#pragma pack(pop)

/* 1963 */
#pragma pack(push, 1)
class _CERT_AUTHORITY_KEY_ID2_INFO
{
	_CRYPTOAPI_BLOB KeyId;
	_CERT_ALT_NAME_INFO AuthorityCertIssuer;
	_CRYPTOAPI_BLOB AuthorityCertSerialNumber;
};
#pragma pack(pop)

/* 1964 */
#pragma pack(push, 1)
class tagLOGPALETTE
{
	unsigned __int16 palVersion;
	unsigned __int16 palNumEntries;
	tagPALETTEENTRY palPalEntry[1];
};
#pragma pack(pop)

/* 1965 */
#pragma pack(push, 1)
class tagNONCLIENTMETRICSA
{
	unsigned int cbSize;
	int iBorderWidth;
	int iScrollWidth;
	int iScrollHeight;
	int iCaptionWidth;
	int iCaptionHeight;
	tagLOGFONTA lfCaptionFont;
	int iSmCaptionWidth;
	int iSmCaptionHeight;
	tagLOGFONTA lfSmCaptionFont;
	int iMenuWidth;
	int iMenuHeight;
	tagLOGFONTA lfMenuFont;
	tagLOGFONTA lfStatusFont;
	tagLOGFONTA lfMessageFont;
};
#pragma pack(pop)

/* 1966 */
#pragma pack(push, 1)
class tagCREATEclassW
{
	void* lpCreateParams;
	HINSTANCE__* hInstance;
	HMENU__* hMenu;
	HWND__* hwndParent;
	int cy;
	int cx;
	int y;
	int x;
	int style;
	const unsigned __int16* lpszName;
	const unsigned __int16* lpszClass;
	unsigned int dwExStyle;
};
#pragma pack(pop)

/* 1967 */
#pragma pack(push, 1)
class tagCBT_CREATEWNDW
{
	tagCREATEclassW* lpcs;
	HWND__* hwndInsertAfter;
};
#pragma pack(pop)

/* 1968 */
#pragma pack(push, 1)
class tagACTCTX_SECTION_KEYED_DATA_2600
{
	unsigned int cbSize;
	unsigned int ulDataFormatVersion;
	void* lpData;
	unsigned int ulLength;
	void* lpSectionGlobalData;
	unsigned int ulSectionGlobalDataLength;
	void* lpSectionBase;
	unsigned int ulSectionTotalLength;
	void* hActCtx;
	unsigned int ulAssemblyRosterIndex;
};
#pragma pack(pop)

/* 1969 */
#pragma pack(push, 1)
class _stat
{
	unsigned int st_dev;
	unsigned __int16 st_ino;
	unsigned __int16 st_mode;
	__int16 st_nlink;
	__int16 st_uid;
	__int16 st_gid;
	__declspec(align(4)) unsigned int st_rdev;
	int st_size;
	int st_atime;
	int st_mtime;
	int st_ctime;
};
#pragma pack(pop)

/* 1970 */
#pragma pack(push, 1)
class FLASHWINFO
{
	unsigned int cbSize;
	HWND__* hwnd;
	unsigned int dwFlags;
	unsigned int uCount;
	unsigned int dwTimeout;
};
#pragma pack(pop)

/* 1971 */
#pragma pack(push, 1)
class _CRYPT_OBJID_TABLE
{
	unsigned int dwAlgId;
	const char* pszObjId;
};
#pragma pack(pop)

/* 1972 */
#pragma pack(push, 1)
class __declspec(align(4)) _MODEMDEVCAPS
{
	unsigned int dwActualSize;
	unsigned int dwRequiredSize;
	unsigned int dwDevSpecificOffset;
	unsigned int dwDevSpecificSize;
	unsigned int dwModemProviderVersion;
	unsigned int dwModemManufacturerOffset;
	unsigned int dwModemManufacturerSize;
	unsigned int dwModemModelOffset;
	unsigned int dwModemModelSize;
	unsigned int dwModemVersionOffset;
	unsigned int dwModemVersionSize;
	unsigned int dwDialOptions;
	unsigned int dwCallSetupFailTimer;
	unsigned int dwInactivityTimeout;
	unsigned int dwSpeakerVolume;
	unsigned int dwSpeakerMode;
	unsigned int dwModemOptions;
	unsigned int dwMaxDTERate;
	unsigned int dwMaxDCERate;
	unsigned __int8 abVariablePortion[1];
};
#pragma pack(pop)

/* 1973 */
#pragma pack(push, 1)
class _WIN_TRUST_SUBJECT_FILE
{
	void* hFile;
	const unsigned __int16* lpPath;
};
#pragma pack(pop)

/* 1974 */
#pragma pack(push, 1)
class _CERT_AUTHORITY_KEY_ID_INFO
{
	_CRYPTOAPI_BLOB KeyId;
	_CRYPTOAPI_BLOB CertIssuer;
	_CRYPTOAPI_BLOB CertSerialNumber;
};
#pragma pack(pop)

/* 1975 */
#pragma pack(push, 1)
class _CERT_PAIR
{
	_CRYPTOAPI_BLOB Forward;
	_CRYPTOAPI_BLOB Reverse;
};
#pragma pack(pop)

/* 1976 */
#pragma pack(push, 1)
class _MINIDUMP_USER_STREAM_INFORMATION
{
	unsigned int UserStreamCount;
	_MINIDUMP_USER_STREAM* UserStreamArray;
};
#pragma pack(pop)

/* 1978 */
#pragma pack(push, 1)
union $2F833E06815C617B0CEDBD4E14D8303A
{
	void* FiberData;
	unsigned int Version;
};
#pragma pack(pop)

/* 1977 */
#pragma pack(push, 1)
class _NT_TIB
{
	class _EXCEPTION_REGISTRATION_RECORD* ExceptionList;
	void* StackBase;
	void* StackLimit;
	void* SubSystemTib;
	$2F833E06815C617B0CEDBD4E14D8303A ___u4;
	void* ArbitraryUserPointer;
	_NT_TIB* Self;
};
#pragma pack(pop)

/* 1979 */
#pragma pack(push, 1)
class tagWINDOWPLACEMENT
{
	unsigned int length;
	unsigned int flags;
	unsigned int showCmd;
	tagPOINT ptMinPosition;
	tagPOINT ptMaxPosition;
	tagRECT rcNormalPosition;
};
#pragma pack(pop)

/* 1980 */
#pragma pack(push, 1)
class _SERVICE_STATUS
{
	unsigned int dwServiceType;
	unsigned int dwCurrentState;
	unsigned int dwControlsAccepted;
	unsigned int dwWin32ExitCode;
	unsigned int dwServiceSpecificExitCode;
	unsigned int dwCheckPoint;
	unsigned int dwWaitHint;
};
#pragma pack(pop)

/* 1981 */
#pragma pack(push, 1)
class _ENUM_SERVICE_STATUSW
{
	unsigned __int16* lpServiceName;
	unsigned __int16* lpDisplayName;
	_SERVICE_STATUS ServiceStatus;
};
#pragma pack(pop)

/* 1982 */
#pragma pack(push, 1)
class value_entW
{
	unsigned __int16* ve_valuename;
	unsigned int ve_valuelen;
	unsigned int ve_valueptr;
	unsigned int ve_type;
};
#pragma pack(pop)

/* 1983 */
#pragma pack(push, 1)
class _CROSS_CERT_DIST_POINTS_INFO
{
	unsigned int dwSyncDeltaTime;
	unsigned int cDistPoint;
	_CERT_ALT_NAME_INFO* rgDistPoint;
};
#pragma pack(pop)

/* 1984 */
#pragma pack(push, 1)
class _PACKEDEVENTINFO
{
	unsigned int ulSize;
	unsigned int ulNumEventsForLogFile;
	unsigned int ulOffsets[];
};
#pragma pack(pop)

/* 1985 */
#pragma pack(push, 1)
class _MEMORYSTATUSEX
{
	unsigned int dwLength;
	unsigned int dwMemoryLoad;
	unsigned __int64 ullTotalPhys;
	unsigned __int64 ullAvailPhys;
	unsigned __int64 ullTotalPageFile;
	unsigned __int64 ullAvailPageFile;
	unsigned __int64 ullTotalVirtual;
	unsigned __int64 ullAvailVirtual;
	unsigned __int64 ullAvailExtendedVirtual;
};
#pragma pack(pop)

/* 1986 */
#pragma pack(push, 1)
class sockproto
{
	unsigned __int16 sp_family;
	unsigned __int16 sp_protocol;
};
#pragma pack(pop)

/* 1987 */
#pragma pack(push, 1)
class _PSINJECTDATA
{
	unsigned int DataBytes;
	unsigned __int16 InjectionPoint;
	unsigned __int16 PageNumber;
};
#pragma pack(pop)

/* 1988 */
#pragma pack(push, 1)
class tagMENUITEMINFOW
{
	unsigned int cbSize;
	unsigned int fMask;
	unsigned int fType;
	unsigned int fState;
	unsigned int wID;
	HMENU__* hSubMenu;
	HBITMAP__* hbmpChecked;
	HBITMAP__* hbmpUnchecked;
	unsigned int dwItemData;
	unsigned __int16* dwTypeData;
	unsigned int cch;
	HBITMAP__* hbmpItem;
};
#pragma pack(pop)

/* 1989 */
#pragma pack(push, 1)
class tagGCP_RESULTSA
{
	unsigned int lclassSize;
	char* lpOutString;
	unsigned int* lpOrder;
	int* lpDx;
	int* lpCaretPos;
	char* lpClass;
	unsigned __int16* lpGlyphs;
	unsigned int nGlyphs;
	int nMaxFit;
};
#pragma pack(pop)

/* 1990 */
#pragma pack(push, 1)
class API_VERSION
{
	unsigned __int16 MajorVersion;
	unsigned __int16 MinorVersion;
	unsigned __int16 Revision;
	unsigned __int16 Reserved;
};
#pragma pack(pop)

/* 1991 */
#pragma pack(push, 1)
class HTASK__
{
	int unused;
};
#pragma pack(pop)

/* 1992 */
#pragma pack(push, 1)
class tagEMRFORMAT
{
	unsigned int dSignature;
	unsigned int nVersion;
	unsigned int cbData;
	unsigned int offData;
};
#pragma pack(pop)

/* 1993 */
#pragma pack(push, 1)
class _CRL_DIST_POINT
{
	_CRL_DIST_POINT_NAME DistPointName;
	_CRYPT_BIT_BLOB ReasonFlags;
	_CERT_ALT_NAME_INFO CRLIssuer;
};
#pragma pack(pop)

/* 1994 */
#pragma pack(push, 1)
class _CRL_DIST_POINTS_INFO
{
	unsigned int cDistPoint;
	_CRL_DIST_POINT* rgDistPoint;
};
#pragma pack(pop)

/* 1995 */
#pragma pack(push, 1)
class tagMETARECORD
{
	unsigned int rdSize;
	unsigned __int16 rdFunction;
	unsigned __int16 rdParm[1];
};
#pragma pack(pop)

/* 1996 */
#pragma pack(push, 1)
class __declspec(align(2)) _MODULE_TYPE_INFO
{
	unsigned __int16 dataLength;
	unsigned __int16 leaf;
	unsigned __int8 data[1];
};
#pragma pack(pop)

/* 1997 */
#pragma pack(push, 1)
class _GENERIC_MAPPING
{
	unsigned int GenericRead;
	unsigned int GenericWrite;
	unsigned int GenericExecute;
	unsigned int GenericAll;
};
#pragma pack(pop)

/* 1998 */
#pragma pack(push, 1)
class _heapinfo
{
	int* _pentry;
	unsigned int _size;
	int _useflag;
};
#pragma pack(pop)

/* 1999 */
#pragma pack(push, 1)
class _SC_ACTION
{
	_SC_ACTION_TYPE Type;
	unsigned int Delay;
};
#pragma pack(pop)

/* 2000 */
#pragma pack(push, 1)
class _SERVICE_FAILURE_ACTIONSA
{
	unsigned int dwResetPeriod;
	char* lpRebootMsg;
	char* lpCommand;
	unsigned int cActions;
	_SC_ACTION* lpsaActions;
};
#pragma pack(pop)

/* 2001 */
#pragma pack(push, 1)
class HIMC__
{
	int unused;
};
#pragma pack(pop)

/* 2002 */
#pragma pack(push, 1)
class _CRYPT_VERIFY_MESSAGE_PARA
{
	unsigned int cbSize;
	unsigned int dwMsgAndCertEncodingType;
	unsigned int hCryptProv;
	const _CERT_CONTEXT* (__stdcall* pfnGetSignerCertificate)(void*, unsigned int, _CERT_INFO*, void*);
	void* pvGetArg;
};
#pragma pack(pop)

/* 2003 */
#pragma pack(push, 1)
class _CMSG_SIGNER_ENCODE_INFO
{
	unsigned int cbSize;
	_CERT_INFO* pCertInfo;
	unsigned int hCryptProv;
	unsigned int dwKeySpec;
	_CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
	void* pvHashAuxInfo;
	unsigned int cAuthAttr;
	_CRYPT_ATTRIBUTE* rgAuthAttr;
	unsigned int cUnauthAttr;
	_CRYPT_ATTRIBUTE* rgUnauthAttr;
};
#pragma pack(pop)

/* 2004 */
#pragma pack(push, 1)
class _CMSG_SIGNED_ENCODE_INFO
{
	unsigned int cbSize;
	unsigned int cSigners;
	_CMSG_SIGNER_ENCODE_INFO* rgSigners;
	unsigned int cCertEncoded;
	_CRYPTOAPI_BLOB* rgCertEncoded;
	unsigned int cCrlEncoded;
	_CRYPTOAPI_BLOB* rgCrlEncoded;
};
#pragma pack(pop)

/* 2005 */
#pragma pack(push, 1)
class tagEMREXTCREATEPEN
{
	tagEMR emr;
	unsigned int ihPen;
	unsigned int offBmi;
	unsigned int cbBmi;
	unsigned int offBits;
	unsigned int cbBits;
	tagEXTLOGPEN elp;
};
#pragma pack(pop)

/* 2006 */
#pragma pack(push, 1)
class _IMAGEHLP_LINE
{
	unsigned int SizeOfclass;
	void* Key;
	unsigned int LineNumber;
	char* FileName;
	unsigned int Address;
};
#pragma pack(pop)

/* 2007 */
#pragma pack(push, 1)
union $65112713C526CA571323B330E79DC728
{
	unsigned int VirtualAddress;
	unsigned int RelocCount;
};
#pragma pack(pop)

/* 2008 */
#pragma pack(push, 1)
class __unaligned __declspec(align(2)) _IMAGE_RELOCATION
{
	$65112713C526CA571323B330E79DC728 ___u0;
	unsigned int SymbolTableIndex;
	unsigned __int16 Type;
};
#pragma pack(pop)

/* 2009 */
#pragma pack(push, 1)
class _WIN_TRUST_ACTDATA_SUBJECT_ONLY
{
	_GUID* SubjectType;
	void* Subject;
};
#pragma pack(pop)

/* 2010 */
#pragma pack(push, 1)
class tagWNDCLASSW
{
	unsigned int style;
	int(__stdcall* lpfnWndProc)(HWND__*, unsigned int, unsigned int, int);
	int cbClsExtra;
	int cbWndExtra;
	HINSTANCE__* hInstance;
	HICON__* hIcon;
	HICON__* hCursor;
	HBRUSH__* hbrBackground;
	const unsigned __int16* lpszMenuName;
	const unsigned __int16* lpszClassName;
};
#pragma pack(pop)

/* 2011 */
#pragma pack(push, 1)
class _QUERY_SERVICE_LOCK_STATUSW
{
	unsigned int fIsLocked;
	unsigned __int16* lpLockOwner;
	unsigned int dwLockDuration;
};
#pragma pack(pop)

/* 2012 */
#pragma pack(push, 1)
class _MINIDUMP_USER_RECORD
{
	unsigned int Type;
	_MINIDUMP_LOCATION_DESCRIPTOR Memory;
};
#pragma pack(pop)

/* 2013 */
#pragma pack(push, 1)
class _MOUSE_EVENT_RECORD
{
	_COORD dwMousePosition;
	unsigned int dwButtonState;
	unsigned int dwControlKeyState;
	unsigned int dwEventFlags;
};
#pragma pack(pop)

/* 2014 */
#pragma pack(push, 1)
class tagLOCALESIGNATURE
{
	unsigned int lsUsb[4];
	unsigned int lsCsbDefault[2];
	unsigned int lsCsbSupported[2];
};
#pragma pack(pop)

/* 2015 */
#pragma pack(push, 1)
class _CONNECTDLGclassW
{
	unsigned int cbclassure;
	HWND__* hwndOwner;
	_NETRESOURCEW* lpConnRes;
	unsigned int dwFlags;
	unsigned int dwDevNum;
};
#pragma pack(pop)

/* 2016 */
#pragma pack(push, 1)
class tagWINDOWPOS
{
	HWND__* hwnd;
	HWND__* hwndInsertAfter;
	int x;
	int y;
	int cx;
	int cy;
	unsigned int flags;
};
#pragma pack(pop)

/* 2017 */
#pragma pack(push, 1)
class tagNCCALCSIZE_PARAMS
{
	tagRECT rgrc[3];
	tagWINDOWPOS* lppos;
};
#pragma pack(pop)

/* 2018 */
#pragma pack(push, 1)
class $877FE759BDF04DCDAED0279799D9ACE9
{
	HWND__* hWnd;
	unsigned int uMsg;
	unsigned int context;
};
#pragma pack(pop)

/* 2019 */
#pragma pack(push, 1)
class $8DE439A76A811595062F7ED15A810112
{
	_OVERLAPPED* lpOverlapped;
};
#pragma pack(pop)

/* 2020 */
#pragma pack(push, 1)
class $21B4A9DC22E79B2767B21CC48F11E234
{
	_OVERLAPPED* lpOverlapped;
	void(__stdcall* lpfnCompletionProc)(unsigned int, unsigned int, _OVERLAPPED*, unsigned int);
};
#pragma pack(pop)

/* 2021 */
#pragma pack(push, 1)
class $5349CAC4B8E2BF3362E9BDF668230EC8
{
	_OVERLAPPED* lpOverlapped;
	void* hPort;
	unsigned int Key;
};
#pragma pack(pop)

/* 2022 */
#pragma pack(push, 1)
union $BF507FDDEADE617677D48E54A3C59780
{
	$877FE759BDF04DCDAED0279799D9ACE9 WindowMessage;
	$8DE439A76A811595062F7ED15A810112 Event;
	$21B4A9DC22E79B2767B21CC48F11E234 Apc;
	$5349CAC4B8E2BF3362E9BDF668230EC8 Port;
};
#pragma pack(pop)

/* 2023 */
#pragma pack(push, 1)
class _WSACOMPLETION
{
	_WSACOMPLETIONTYPE Type;
	$BF507FDDEADE617677D48E54A3C59780 Parameters;
};
#pragma pack(pop)

/* 2024 */
#pragma pack(push, 1)
class _IMAGE_SEPARATE_DEBUG_HEADER
{
	unsigned __int16 Signature;
	unsigned __int16 Flags;
	unsigned __int16 Machine;
	unsigned __int16 Characteristics;
	unsigned int TimeDateStamp;
	unsigned int CheckSum;
	unsigned int ImageBase;
	unsigned int SizeOfImage;
	unsigned int NumberOfSections;
	unsigned int ExportedNamesSize;
	unsigned int DebugDirectorySize;
	unsigned int SectionAlignment;
	unsigned int Reserved[2];
};
#pragma pack(pop)

/* 2025 */
#pragma pack(push, 1)
class tagCOMPAREITEMclass
{
	unsigned int CtlType;
	unsigned int CtlID;
	HWND__* hwndItem;
	unsigned int itemID1;
	unsigned int itemData1;
	unsigned int itemID2;
	unsigned int itemData2;
	unsigned int dwLocaleId;
};
#pragma pack(pop)

/* 2026 */
#pragma pack(push, 1)
class _CERT_CHAIN_PARA
{
	unsigned int cbSize;
	_CERT_USAGE_MATCH RequestedUsage;
};
#pragma pack(pop)

/* 2027 */
#pragma pack(push, 1)
class _ENUM_SERVICE_STATUSA
{
	char* lpServiceName;
	char* lpDisplayName;
	_SERVICE_STATUS ServiceStatus;
};
#pragma pack(pop)

/* 2028 */
#pragma pack(push, 1)
class tagEMRRESTOREDC
{
	tagEMR emr;
	int iRelative;
};
#pragma pack(pop)

/* 2029 */
#pragma pack(push, 1)
class _MESSAGE_RESOURCE_DATA
{
	unsigned int NumberOfBlocks;
	_MESSAGE_RESOURCE_BLOCK Blocks[1];
};
#pragma pack(pop)

/* 2030 */
#pragma pack(push, 1)
class _cpinfoexW
{
	unsigned int MaxCharSize;
	unsigned __int8 DefaultChar[2];
	unsigned __int8 LeadByte[12];
	unsigned __int16 UnicodeDefaultChar;
	unsigned int CodePage;
	unsigned __int16 CodePageName[260];
};
#pragma pack(pop)

/* 2031 */
#pragma pack(push, 1)
class tagIMECHARPOSITION
{
	unsigned int dwSize;
	unsigned int dwCharPos;
	tagPOINT pt;
	unsigned int cLineHeight;
	tagRECT rcDocument;
};
#pragma pack(pop)

/* 2032 */
#pragma pack(push, 1)
class __wfinddata64_t
{
	unsigned int attrib;
	__declspec(align(8)) __int64 time_create;
	__int64 time_access;
	__int64 time_write;
	__int64 size;
	wchar_t name[260];
};
#pragma pack(pop)

/* 2033 */
#pragma pack(push, 1)
class $DE6B22FD7D66ADF41D59CB121F68EC4E
{
	_SINGLE_LIST_ENTRY Next;
	unsigned __int16 Depth;
	unsigned __int16 Sequence;
};
#pragma pack(pop)

/* 2034 */
#pragma pack(push, 1)
union _SLIST_HEADER
{
	unsigned __int64 Alignment;
	$DE6B22FD7D66ADF41D59CB121F68EC4E __s1;
};
#pragma pack(pop)

/* 2035 */
#pragma pack(push, 1)
class _SYSTEMTIME
{
	unsigned __int16 wYear;
	unsigned __int16 wMonth;
	unsigned __int16 wDayOfWeek;
	unsigned __int16 wDay;
	unsigned __int16 wHour;
	unsigned __int16 wMinute;
	unsigned __int16 wSecond;
	unsigned __int16 wMilliseconds;
};
#pragma pack(pop)

/* 2036 */
#pragma pack(push, 1)
class _UNIVERSAL_NAME_INFOW
{
	unsigned __int16* lpUniversalName;
};
#pragma pack(pop)

/* 2037 */
#pragma pack(push, 1)
class __declspec(align(4)) _TAPE_WRITE_MARKS
{
	unsigned int Type;
	unsigned int Count;
	unsigned __int8 Immediate;
};
#pragma pack(pop)

/* 2038 */
#pragma pack(push, 1)
class tagSTYLEBUFA
{
	unsigned int dwStyle;
	char szDescription[32];
};
#pragma pack(pop)

/* 2039 */
#pragma pack(push, 1)
class tagCURSORINFO
{
	unsigned int cbSize;
	unsigned int flags;
	HICON__* hCursor;
	tagPOINT ptScreenPos;
};
#pragma pack(pop)

/* 2040 */
#pragma pack(push, 1)
class value_entA
{
	char* ve_valuename;
	unsigned int ve_valuelen;
	unsigned int ve_valueptr;
	unsigned int ve_type;
};
#pragma pack(pop)

/* 2041 */
#pragma pack(push, 1)
class tagENUMLOGFONTEXW
{
	tagLOGFONTW elfLogFont;
	unsigned __int16 elfFullName[64];
	unsigned __int16 elfStyle[32];
	unsigned __int16 elfScript[32];
};
#pragma pack(pop)

/* 2042 */
#pragma pack(push, 1)
class tagENUMLOGFONTEXDVW
{
	tagENUMLOGFONTEXW elfEnumLogfontEx;
	tagDESIGNVECTOR elfDesignVector;
};
#pragma pack(pop)

/* 2043 */
#pragma pack(push, 1)
class _IO_COUNTERS
{
	unsigned __int64 ReadOperationCount;
	unsigned __int64 WriteOperationCount;
	unsigned __int64 OtherOperationCount;
	unsigned __int64 ReadTransferCount;
	unsigned __int64 WriteTransferCount;
	unsigned __int64 OtherTransferCount;
};
#pragma pack(pop)

/* 2044 */
#pragma pack(push, 1)
class _JOBOBJECT_EXTENDED_LIMIT_INFORMATION
{
	_JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
	_IO_COUNTERS IoInfo;
	unsigned int ProcessMemoryLimit;
	unsigned int JobMemoryLimit;
	unsigned int PeakProcessMemoryUsed;
	unsigned int PeakJobMemoryUsed;
};
#pragma pack(pop)

/* 2045 */
#pragma pack(push, 1)
class _MINIDUMP_MODULE_LIST
{
	unsigned int NumberOfModules;
	_MINIDUMP_MODULE Modules[];
};
#pragma pack(pop)

/* 2046 */
#pragma pack(push, 1)
class _MINIDUMP_HANDLE_DESCRIPTOR
{
	unsigned __int64 Handle;
	unsigned int TypeNameRva;
	unsigned int ObjectNameRva;
	unsigned int Attributes;
	unsigned int GrantedAccess;
	unsigned int HandleCount;
	unsigned int PointerCount;
};
#pragma pack(pop)

/* 2047 */
#pragma pack(push, 1)
class _WGLSWAP
{
	HDC__* hdc;
	unsigned int uiFlags;
};
#pragma pack(pop)

/* 2048 */
#pragma pack(push, 1)
class _CERT_NAME_CONSTRAINTS_INFO
{
	unsigned int cPermittedSubtree;
	_CERT_GENERAL_SUBTREE* rgPermittedSubtree;
	unsigned int cExcludedSubtree;
	_CERT_GENERAL_SUBTREE* rgExcludedSubtree;
};
#pragma pack(pop)

/* 2049 */
#pragma pack(push, 1)
class tagCHARSETINFO
{
	unsigned int ciCharset;
	unsigned int ciACP;
	tagFONTSIGNATURE fs;
};
#pragma pack(pop)

/* 2050 */
#pragma pack(push, 1)
class tagTTPOLYGONHEADER
{
	unsigned int cb;
	unsigned int dwType;
	tagPOINTFX pfxStart;
};
#pragma pack(pop)

/* 2051 */
#pragma pack(push, 1)
class _MODLOAD_DATA
{
	unsigned int ssize;
	unsigned int ssig;
	void* data;
	unsigned int size;
	unsigned int flags;
};
#pragma pack(pop)

/* 2052 */
#pragma pack(push, 1)
class _IMAGE_ARCHIVE_MEMBER_HEADER
{
	unsigned __int8 Name[16];
	unsigned __int8 Date[12];
	unsigned __int8 UserID[6];
	unsigned __int8 GroupID[6];
	unsigned __int8 Mode[8];
	unsigned __int8 Size[10];
	unsigned __int8 EndHeader[2];
};
#pragma pack(pop)

/* 2053 */
#pragma pack(push, 1)
class _CERT_DSS_PARAMETERS
{
	_CRYPTOAPI_BLOB p;
	_CRYPTOAPI_BLOB q;
	_CRYPTOAPI_BLOB g;
};
#pragma pack(pop)

/* 2054 */
#pragma pack(push, 1)
class _IMAGEHLP_DUPLICATE_SYMBOL64
{
	unsigned int SizeOfclass;
	unsigned int NumberOfDups;
	_IMAGEHLP_SYMBOL64* Symbol;
	unsigned int SelectedSymbol;
};
#pragma pack(pop)

/* 2055 */
#pragma pack(push, 1)
class _MINIDUMP_THREAD_LIST
{
	unsigned int NumberOfThreads;
	_MINIDUMP_THREAD Threads[];
};
#pragma pack(pop)

/* 2056 */
#pragma pack(push, 1)
class _CERT_CHAIN
{
	unsigned int cCerts;
	_CRYPTOAPI_BLOB* certs;
	_CRYPT_KEY_PROV_INFO keyLocatorInfo;
};
#pragma pack(pop)

/* 2057 */
#pragma pack(push, 1)
class _IMAGEHLP_DUPLICATE_SYMBOL
{
	unsigned int SizeOfclass;
	unsigned int NumberOfDups;
	_IMAGEHLP_SYMBOL* Symbol;
	unsigned int SelectedSymbol;
};
#pragma pack(pop)

/* 2058 */
#pragma pack(push, 1)
class IMAGE_COR20_HEADER
{
	unsigned int cb;
	unsigned __int16 MajorRuntimeVersion;
	unsigned __int16 MinorRuntimeVersion;
	_IMAGE_DATA_DIRECTORY MetaData;
	unsigned int Flags;
	unsigned int EntryPointToken;
	_IMAGE_DATA_DIRECTORY Resources;
	_IMAGE_DATA_DIRECTORY StrongNameSignature;
	_IMAGE_DATA_DIRECTORY CodeManagerTable;
	_IMAGE_DATA_DIRECTORY VTableFixups;
	_IMAGE_DATA_DIRECTORY ExportAddressTableJumps;
	_IMAGE_DATA_DIRECTORY ManagedNativeHeader;
};
#pragma pack(pop)

/* 2059 */
#pragma pack(push, 1)
class _IMAGE_EXPORT_DIRECTORY
{
	unsigned int Characteristics;
	unsigned int TimeDateStamp;
	unsigned __int16 MajorVersion;
	unsigned __int16 MinorVersion;
	unsigned int Name;
	unsigned int Base;
	unsigned int NumberOfFunctions;
	unsigned int NumberOfNames;
	unsigned int AddressOfFunctions;
	unsigned int AddressOfNames;
	unsigned int AddressOfNameOrdinals;
};
#pragma pack(pop)

/* 2060 */
#pragma pack(push, 1)
class tagNEWTEXTMETRICW
{
	int tmHeight;
	int tmAscent;
	int tmDescent;
	int tmInternalLeading;
	int tmExternalLeading;
	int tmAveCharWidth;
	int tmMaxCharWidth;
	int tmWeight;
	int tmOverhang;
	int tmDigitizedAspectX;
	int tmDigitizedAspectY;
	unsigned __int16 tmFirstChar;
	unsigned __int16 tmLastChar;
	unsigned __int16 tmDefaultChar;
	unsigned __int16 tmBreakChar;
	unsigned __int8 tmItalic;
	unsigned __int8 tmUnderlined;
	unsigned __int8 tmStruckOut;
	unsigned __int8 tmPitchAndFamily;
	unsigned __int8 tmCharSet;
	__declspec(align(4)) unsigned int ntmFlags;
	unsigned int ntmSizeEM;
	unsigned int ntmCellHeight;
	unsigned int ntmAvgWidth;
};
#pragma pack(pop)

/* 2061 */
#pragma pack(push, 1)
class tagNEWTEXTMETRICEXW
{
	tagNEWTEXTMETRICW ntmTm;
	tagFONTSIGNATURE ntmFontSig;
};
#pragma pack(pop)

/* 2062 */
#pragma pack(push, 1)
class tagENUMTEXTMETRICW
{
	tagNEWTEXTMETRICEXW etmNewTextMetricEx;
	tagAXESLISTW etmAxesList;
};
#pragma pack(pop)

/* 2063 */
#pragma pack(push, 1)
class tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA
{
	void* lpInformation;
	void* lpSectionBase;
	unsigned int ulSectionLength;
	void* lpSectionGlobalDataBase;
	unsigned int ulSectionGlobalDataLength;
};
#pragma pack(pop)

/* 2064 */
#pragma pack(push, 1)
class tagACTCTX_SECTION_KEYED_DATA
{
	unsigned int cbSize;
	unsigned int ulDataFormatVersion;
	void* lpData;
	unsigned int ulLength;
	void* lpSectionGlobalData;
	unsigned int ulSectionGlobalDataLength;
	void* lpSectionBase;
	unsigned int ulSectionTotalLength;
	void* hActCtx;
	unsigned int ulAssemblyRosterIndex;
	unsigned int ulFlags;
	tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;
};
#pragma pack(pop)

/* 2065 */
#pragma pack(push, 1)
class _CRYPT_KEY_SIGN_MESSAGE_PARA
{
	unsigned int cbSize;
	unsigned int dwMsgAndCertEncodingType;
	unsigned int hCryptProv;
	unsigned int dwKeySpec;
	_CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
	void* pvHashAuxInfo;
	_CRYPT_ALGORITHM_IDENTIFIER PubKeyAlgorithm;
};
#pragma pack(pop)

/* 2066 */
#pragma pack(push, 1)
class tagEMRPLGBLT
{
	tagEMR emr;
	_RECTL rclBounds;
	_POINTL aptlDest[3];
	int xSrc;
	int ySrc;
	int cxSrc;
	int cySrc;
	tagXFORM xformSrc;
	unsigned int crBkColorSrc;
	unsigned int iUsageSrc;
	unsigned int offBmiSrc;
	unsigned int cbBmiSrc;
	unsigned int offBitsSrc;
	unsigned int cbBitsSrc;
	int xMask;
	int yMask;
	unsigned int iUsageMask;
	unsigned int offBmiMask;
	unsigned int cbBmiMask;
	unsigned int offBitsMask;
	unsigned int cbBitsMask;
};
#pragma pack(pop)

/* 2067 */
#pragma pack(push, 1)
class __declspec(align(4)) _LOAD_DLL_DEBUG_INFO
{
	void* hFile;
	void* lpBaseOfDll;
	unsigned int dwDebugInfoFileOffset;
	unsigned int nDebugInfoSize;
	void* lpImageName;
	unsigned __int16 fUnicode;
};
#pragma pack(pop)

/* 2068 */
#pragma pack(push, 1)
class _IMAGE_RUNTIME_FUNCTION_ENTRY
{
	unsigned int BeginAddress;
	unsigned int EndAddress;
	unsigned int UnwindInfoAddress;
};
#pragma pack(pop)

/* 2069 */
#pragma pack(push, 1)
class _CMSG_HASHED_ENCODE_INFO
{
	unsigned int cbSize;
	unsigned int hCryptProv;
	_CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
	void* pvHashAuxInfo;
};
#pragma pack(pop)

/* 2070 */
#pragma pack(push, 1)
class _CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA
{
	unsigned int cbSize;
	unsigned int hCryptProv;
	unsigned int dwSignerIndex;
	unsigned int dwSignerType;
	void* pvSigner;
};
#pragma pack(pop)

/* 2071 */
#pragma pack(push, 1)
class tagEMRCREATEMONOBRUSH
{
	tagEMR emr;
	unsigned int ihBrush;
	unsigned int iUsage;
	unsigned int offBmi;
	unsigned int cbBmi;
	unsigned int offBits;
	unsigned int cbBits;
};
#pragma pack(pop)

/* 2072 */
#pragma pack(push, 1)
union _FILE_SEGMENT_ELEMENT
{
	void* Buffer;
	unsigned __int64 Alignment;
};
#pragma pack(pop)

/* 2073 */
#pragma pack(push, 1)
class _div_t
{
	int quot;
	int rem;
};
#pragma pack(pop)

/* 2074 */
#pragma pack(push, 1)
class _GLYPHMETRICS
{
	unsigned int gmBlackBoxX;
	unsigned int gmBlackBoxY;
	tagPOINT gmptGlyphOrigin;
	__int16 gmCellIncX;
	__int16 gmCellIncY;
};
#pragma pack(pop)

/* 2076 */
#pragma pack(push, 1)
class CMemory::CInit
{
};
#pragma pack(pop)

/* 2079 */
#pragma pack(push, 1)
class CMemory::tagEntryEnd
{
	int sizeBack;
};
#pragma pack(pop)

/* 2083 */
#pragma pack(push, 1)
class _JOB_SET_ARRAY
{
	void* JobHandle;
	unsigned int MemberLevel;
	unsigned int Flags;
};
#pragma pack(pop)

/* 2084 */
#pragma pack(push, 1)
class _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION
{
	_LARGE_INTEGER TotalUserTime;
	_LARGE_INTEGER TotalKernelTime;
	_LARGE_INTEGER ThisPeriodTotalUserTime;
	_LARGE_INTEGER ThisPeriodTotalKernelTime;
	unsigned int TotalPageFaultCount;
	unsigned int TotalProcesses;
	unsigned int ActiveProcesses;
	unsigned int TotalTerminatedProcesses;
};
#pragma pack(pop)

/* 2085 */
#pragma pack(push, 1)
class _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION
{
	_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
	_IO_COUNTERS IoInfo;
};
#pragma pack(pop)

/* 2086 */
#pragma pack(push, 1)
class _MINIDUMP_MISC_INFO
{
	unsigned int SizeOfInfo;
	unsigned int Flags1;
	unsigned int ProcessId;
	unsigned int ProcessCreateTime;
	unsigned int ProcessUserTime;
	unsigned int ProcessKernelTime;
};
#pragma pack(pop)

/* 2087 */
#pragma pack(push, 1)
class tagEMRSETMITERLIMIT
{
	tagEMR emr;
	float eMiterLimit;
};
#pragma pack(pop)

/* 2088 */
#pragma pack(push, 1)
class tagEMRCREATEBRUSHINDIRECT
{
	tagEMR emr;
	unsigned int ihBrush;
	tagLOGBRUSH32 lb;
};
#pragma pack(pop)

/* 2089 */
#pragma pack(push, 1)
class _CERT_DH_PARAMETERS
{
	_CRYPTOAPI_BLOB p;
	_CRYPTOAPI_BLOB g;
};
#pragma pack(pop)

/* 2090 */
#pragma pack(push, 1)
class __declspec(align(8)) _IMAGEHLP_MODULE64W
{
	unsigned int SizeOfclass;
	__declspec(align(8)) unsigned __int64 BaseOfImage;
	unsigned int ImageSize;
	unsigned int TimeDateStamp;
	unsigned int CheckSum;
	unsigned int NumSyms;
	SYM_TYPE SymType;
	unsigned __int16 ModuleName[32];
	unsigned __int16 ImageName[256];
	unsigned __int16 LoadedImageName[256];
};
#pragma pack(pop)

/* 2091 */
#pragma pack(push, 1)
class $153CE9C77BA5C09AC231C456F449F21C
{
	unsigned __int8 s_b1;
	unsigned __int8 s_b2;
	unsigned __int8 s_b3;
	unsigned __int8 s_b4;
};
#pragma pack(pop)

/* 2092 */
#pragma pack(push, 1)
class $85E44F9BC294178B5635C5AD72B7AA6A
{
	unsigned __int16 s_w1;
	unsigned __int16 s_w2;
};
#pragma pack(pop)

/* 2093 */
#pragma pack(push, 1)
union $46BD699BCC3C194538A3AF39FCD96929
{
	$153CE9C77BA5C09AC231C456F449F21C S_un_b;
	$85E44F9BC294178B5635C5AD72B7AA6A S_un_w;
	unsigned int S_addr;
};
#pragma pack(pop)

/* 2094 */
#pragma pack(push, 1)
class _ACTIVATION_CONTEXT_DETAILED_INFORMATION
{
	unsigned int dwFlags;
	unsigned int ulFormatVersion;
	unsigned int ulAssemblyCount;
	unsigned int ulRootManifestPathType;
	unsigned int ulRootManifestPathChars;
	unsigned int ulRootConfigurationPathType;
	unsigned int ulRootConfigurationPathChars;
	unsigned int ulAppDirPathType;
	unsigned int ulAppDirPathChars;
	const unsigned __int16* lpRootManifestPath;
	const unsigned __int16* lpRootConfigurationPath;
	const unsigned __int16* lpAppDirPath;
};
#pragma pack(pop)

/* 2095 */
#pragma pack(push, 1)
class _CREATE_THREAD_DEBUG_INFO
{
	void* hThread;
	void* lpThreadLocalBase;
	unsigned int(__stdcall* lpStartAddress)(void*);
};
#pragma pack(pop)

/* 2096 */
#pragma pack(push, 1)
union $94E0F9575F440397D67592BBECD298BD
{
	_EXCEPTION_DEBUG_INFO Exception;
	_CREATE_THREAD_DEBUG_INFO CreateThread;
	_CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
	_EXIT_THREAD_DEBUG_INFO ExitThread;
	_EXIT_PROCESS_DEBUG_INFO ExitProcess;
	_LOAD_DLL_DEBUG_INFO LoadDll;
	_UNLOAD_DLL_DEBUG_INFO UnloadDll;
	_OUTPUT_DEBUG_STRING_INFO DebugString;
	_RIP_INFO RipInfo;
};
#pragma pack(pop)

/* 2097 */
#pragma pack(push, 1)
class _DEBUG_EVENT
{
	unsigned int dwDebugEventCode;
	unsigned int dwProcessId;
	unsigned int dwThreadId;
	$94E0F9575F440397D67592BBECD298BD u;
};
#pragma pack(pop)

/* 2098 */
#pragma pack(push, 1)
class _SECURITY_DESCRIPTOR_RELATIVE
{
	unsigned __int8 Revision;
	unsigned __int8 Sbz1;
	unsigned __int16 Control;
	unsigned int Owner;
	unsigned int Group;
	unsigned int Sacl;
	unsigned int Dacl;
};
#pragma pack(pop)

/* 2099 */
#pragma pack(push, 1)
class _MINIDUMP_MEMORY_LIST
{
	unsigned int NumberOfMemoryRanges;
	_MINIDUMP_MEMORY_DESCRIPTOR MemoryRanges[];
};
#pragma pack(pop)

/* 2100 */
#pragma pack(push, 1)
class _CERT_REVOCATION_STATUS
{
	unsigned int cbSize;
	unsigned int dwIndex;
	unsigned int dwError;
	unsigned int dwReason;
	int fHasFreshnessTime;
	unsigned int dwFreshnessTime;
};
#pragma pack(pop)

/* 2101 */
#pragma pack(push, 1)
class _TOKEN_STATISTICS
{
	_LUID TokenId;
	_LUID AuthenticationId;
	_LARGE_INTEGER ExpirationTime;
	_TOKEN_TYPE TokenType;
	_SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
	unsigned int DynamicCharged;
	unsigned int DynamicAvailable;
	unsigned int GroupCount;
	unsigned int PrivilegeCount;
	_LUID ModifiedId;
};
#pragma pack(pop)

/* 2102 */
#pragma pack(push, 1)
class _PRIVILEGE_SET
{
	unsigned int PrivilegeCount;
	unsigned int Control;
	_LUID_AND_ATTRIBUTES Privilege[1];
};
#pragma pack(pop)

/* 2103 */
#pragma pack(push, 1)
class _TAPE_GET_POSITION
{
	unsigned int Type;
	unsigned int Partition;
	_LARGE_INTEGER Offset;
};
#pragma pack(pop)

/* 2104 */
#pragma pack(push, 1)
class _CERT_CHAIN_POLICY_STATUS
{
	unsigned int cbSize;
	unsigned int dwError;
	int lChainIndex;
	int lElementIndex;
	void* pvExtraPolicyStatus;
};
#pragma pack(pop)

/* 2105 */
#pragma pack(push, 1)
class _CRYPT_PKCS8_EXPORT_PARAMS
{
	unsigned int hCryptProv;
	unsigned int dwKeySpec;
	char* pszPrivateKeyObjId;
	int(__stdcall* pEncryptPrivateKeyFunc)(_CRYPT_ALGORITHM_IDENTIFIER*, _CRYPTOAPI_BLOB*, unsigned __int8*, unsigned int*, void*);
	void* pVoidEncryptFunc;
};
#pragma pack(pop)

/* 2106 */
#pragma pack(push, 1)
class tagMOUSEHOOKclassEX : tagMOUSEHOOKclass
{
	unsigned int mouseData;
};
#pragma pack(pop)

/* 2107 */
#pragma pack(push, 1)
class _SPC_SP_OPUS_INFO
{
	const unsigned __int16* pwszProgramName;
	SPC_LINK_* pMoreInfo;
	SPC_LINK_* pPublisherInfo;
};
#pragma pack(pop)

/* 2108 */
#pragma pack(push, 1)
class tagCWPclass
{
	int lParam;
	unsigned int wParam;
	unsigned int message;
	HWND__* hwnd;
};
#pragma pack(pop)

/* 2109 */
#pragma pack(push, 1)
class tagALTTABINFO
{
	unsigned int cbSize;
	int cItems;
	int cColumns;
	int cRows;
	int iColFocus;
	int iRowFocus;
	int cxItem;
	int cyItem;
	tagPOINT ptStart;
};
#pragma pack(pop)

/* 2110 */
#pragma pack(push, 1)
class _RSAPUBKEY
{
	unsigned int magic;
	unsigned int bitlen;
	unsigned int pubexp;
};
#pragma pack(pop)

/* 2111 */
#pragma pack(push, 1)
class _IMAGE_TLS_DIRECTORY32
{
	unsigned int StartAddressOfRawData;
	unsigned int EndAddressOfRawData;
	unsigned int AddressOfIndex;
	unsigned int AddressOfCallBacks;
	unsigned int SizeOfZeroFill;
	unsigned int Characteristics;
};
#pragma pack(pop)

/* 2112 */
#pragma pack(push, 1)
class __declspec(align(4)) tagEMRPOLYDRAW16
{
	tagEMR emr;
	_RECTL rclBounds;
	unsigned int cpts;
	tagPOINTS apts[1];
	unsigned __int8 abTypes[1];
};
#pragma pack(pop)

/* 2113 */
#pragma pack(push, 1)
class _GRADIENT_RECT
{
	unsigned int UpperLeft;
	unsigned int LowerRight;
};
#pragma pack(pop)

/* 2114 */
#pragma pack(push, 1)
class _QOS_SHAPING_RATE
{
	QOS_OBJECT_HDR ObjectHdr;
	unsigned int ShapingRate;
};
#pragma pack(pop)

/* 2115 */
#pragma pack(push, 1)
class __declspec(align(4)) _TAPE_ERASE
{
	unsigned int Type;
	unsigned __int8 Immediate;
};
#pragma pack(pop)

/* 2116 */
#pragma pack(push, 1)
class HRSRC__
{
	int unused;
};
#pragma pack(pop)

/* 2117 */
#pragma pack(push, 1)
class _ACL_SIZE_INFORMATION
{
	unsigned int AceCount;
	unsigned int AclBytesInUse;
	unsigned int AclBytesFree;
};
#pragma pack(pop)

/* 2118 */
#pragma pack(push, 1)
class _CMSG_SP3_COMPATIBLE_AUX_INFO
{
	unsigned int cbSize;
	unsigned int dwFlags;
};
#pragma pack(pop)

/* 2119 */
#pragma pack(push, 1)
class tagEMRPOLYPOLYLINE16
{
	tagEMR emr;
	_RECTL rclBounds;
	unsigned int nPolys;
	unsigned int cpts;
	unsigned int aPolyCounts[1];
	tagPOINTS apts[1];
};
#pragma pack(pop)

/* 2120 */
#pragma pack(push, 1)
class _CRYPT_PRIVATE_KEY_INFO
{
	unsigned int Version;
	_CRYPT_ALGORITHM_IDENTIFIER Algorithm;
	_CRYPTOAPI_BLOB PrivateKey;
	_CRYPT_ATTRIBUTES* pAttributes;
};
#pragma pack(pop)

/* 2121 */
#pragma pack(push, 1)
class _MINIDUMP_DIRECTORY
{
	unsigned int StreamType;
	_MINIDUMP_LOCATION_DESCRIPTOR Location;
};
#pragma pack(pop)

/* 2122 */
#pragma pack(push, 1)
class __declspec(align(2)) tagHW_PROFILE_INFOA
{
	unsigned int dwDockInfo;
	char szHwProfileGuid[39];
	char szHwProfileName[80];
};
#pragma pack(pop)

/* 2123 */
#pragma pack(push, 1)
class _ENUM_SERVICE_STATUS_PROCESSW
{
	unsigned __int16* lpServiceName;
	unsigned __int16* lpDisplayName;
	_SERVICE_STATUS_PROCESS ServiceStatusProcess;
};
#pragma pack(pop)

/* 2124 */
#pragma pack(push, 1)
class _CMSG_RC2_AUX_INFO
{
	unsigned int cbSize;
	unsigned int dwBitLen;
};
#pragma pack(pop)

/* 2125 */
#pragma pack(push, 1)
class tagKERNINGPAIR
{
	unsigned __int16 wFirst;
	unsigned __int16 wSecond;
	int iKernAmount;
};
#pragma pack(pop)

/* 2126 */
#pragma pack(push, 1)
class $A0E32B10408BE57C27C8DE3C02733E6D
{
	unsigned int LowPart;
	unsigned int HighPart;
};
#pragma pack(pop)

/* 2127 */
#pragma pack(push, 1)
union _ULARGE_INTEGER
{
	$A0E32B10408BE57C27C8DE3C02733E6D __s0;
	$A0E32B10408BE57C27C8DE3C02733E6D u;
	unsigned __int64 QuadPart;
};
#pragma pack(pop)

/* 2128 */
#pragma pack(push, 1)
class _SPC_PE_IMAGE_DATA
{
	_CRYPT_BIT_BLOB Flags;
	SPC_LINK_* pFile;
};
#pragma pack(pop)

/* 2129 */
#pragma pack(push, 1)
class tagEMRCREATEPEN
{
	tagEMR emr;
	unsigned int ihPen;
	tagLOGPEN lopn;
};
#pragma pack(pop)

/* 2130 */
#pragma pack(push, 1)
union $8D8B851CA9C289E8971C1A573A53B865
{
	unsigned __int16 UnicodeChar;
	char AsciiChar;
};
#pragma pack(pop)

/* 2131 */
#pragma pack(push, 1)
class _KEY_EVENT_RECORD
{
	int bKeyDown;
	unsigned __int16 wRepeatCount;
	unsigned __int16 wVirtualKeyCode;
	unsigned __int16 wVirtualScanCode;
	$8D8B851CA9C289E8971C1A573A53B865 uChar;
	unsigned int dwControlKeyState;
};
#pragma pack(pop)

/* 2132 */
#pragma pack(push, 1)
class tagGLYPHSET
{
	unsigned int cbThis;
	unsigned int flAccel;
	unsigned int cGlyphsSupported;
	unsigned int cRanges;
	tagWCRANGE ranges[1];
};
#pragma pack(pop)

/* 2133 */
#pragma pack(push, 1)
class _QUERY_SERVICE_LOCK_STATUSA
{
	unsigned int fIsLocked;
	char* lpLockOwner;
	unsigned int dwLockDuration;
};
#pragma pack(pop)

/* 2134 */
#pragma pack(push, 1)
class _OBJECTID
{
	_GUID Lineage;
	unsigned int Uniquifier;
};
#pragma pack(pop)

/* 2135 */
#pragma pack(push, 1)
class _SYSTEM_ALARM_ACE
{
	_ACE_HEADER Header;
	unsigned int Mask;
	unsigned int SidStart;
};
#pragma pack(pop)

/* 2136 */
#pragma pack(push, 1)
class IMAGE_LOAD_CONFIG_DIRECTORY64
{
	unsigned int Size;
	unsigned int TimeDateStamp;
	unsigned __int16 MajorVersion;
	unsigned __int16 MinorVersion;
	unsigned int GlobalFlagsClear;
	unsigned int GlobalFlagsSet;
	unsigned int CriticalSectionDefaultTimeout;
	unsigned __int64 DeCommitFreeBlockThreshold;
	unsigned __int64 DeCommitTotalFreeThreshold;
	unsigned __int64 LockPrefixTable;
	unsigned __int64 MaximumAllocationSize;
	unsigned __int64 VirtualMemoryThreshold;
	unsigned __int64 ProcessAffinityMask;
	unsigned int ProcessHeapFlags;
	unsigned __int16 CSDVersion;
	unsigned __int16 Reserved1;
	unsigned __int64 EditList;
	unsigned __int64 SecurityCookie;
	unsigned __int64 SEHandlerTable;
	unsigned __int64 SEHandlerCount;
};
#pragma pack(pop)

/* 2137 */
#pragma pack(push, 1)
class tagEMRSETPIXELV
{
	tagEMR emr;
	_POINTL ptlPixel;
	unsigned int crColor;
};
#pragma pack(pop)

/* 2138 */
#pragma pack(push, 1)
class linger
{
	unsigned __int16 l_onoff;
	unsigned __int16 l_linger;
};
#pragma pack(pop)

/* 2139 */
#pragma pack(push, 1)
union $C293A7A53CC7467984AD33B1021505BD
{
	unsigned __int64 FiberData;
	unsigned int Version;
};
#pragma pack(pop)

/* 2140 */
#pragma pack(push, 1)
class _NT_TIB64
{
	unsigned __int64 ExceptionList;
	unsigned __int64 StackBase;
	unsigned __int64 StackLimit;
	unsigned __int64 SubSystemTib;
	$C293A7A53CC7467984AD33B1021505BD ___u4;
	unsigned __int64 ArbitraryUserPointer;
	unsigned __int64 Self;
};
#pragma pack(pop)

/* 2141 */
#pragma pack(push, 1)
class _ABCFLOAT
{
	float abcfA;
	float abcfB;
	float abcfC;
};
#pragma pack(pop)

/* 2142 */
#pragma pack(push, 1)
class _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
{
	unsigned __int64 BeginAddress;
	unsigned __int64 EndAddress;
	unsigned __int64 ExceptionHandler;
	unsigned __int64 HandlerData;
	unsigned __int64 PrologEndAddress;
};
#pragma pack(pop)

/* 2143 */
#pragma pack(push, 1)
class _CONSOLE_CURSOR_INFO
{
	unsigned int dwSize;
	int bVisible;
};
#pragma pack(pop)

/* 2144 */
#pragma pack(push, 1)
class _CERT_NAME_VALUE
{
	unsigned int dwValueType;
	_CRYPTOAPI_BLOB Value;
};
#pragma pack(pop)

/* 2145 */
#pragma pack(push, 1)
class _CPS_URLS
{
	unsigned __int16* pszURL;
	_CRYPT_ALGORITHM_IDENTIFIER* pAlgorithm;
	_CRYPTOAPI_BLOB* pDigest;
};
#pragma pack(pop)

/* 2146 */
#pragma pack(push, 1)
class __declspec(align(8)) _TAPE_GET_MEDIA_PARAMETERS
{
	_LARGE_INTEGER Capacity;
	_LARGE_INTEGER Remaining;
	unsigned int BlockSize;
	unsigned int PartitionCount;
	unsigned __int8 WriteProtected;
};
#pragma pack(pop)

/* 2147 */
#pragma pack(push, 1)
class _PROV_ENUMALGS
{
	unsigned int aiAlgid;
	unsigned int dwBitLen;
	unsigned int dwNameLen;
	char szName[20];
};
#pragma pack(pop)

/* 2148 */
#pragma pack(push, 1)
class _wfinddatai64_t
{
	unsigned int attrib;
	int time_create;
	int time_access;
	int time_write;
	__int64 size;
	wchar_t name[260];
};
#pragma pack(pop)

/* 2149 */
#pragma pack(push, 1)
class _CRL_ISSUING_DIST_POINT
{
	_CRL_DIST_POINT_NAME DistPointName;
	int fOnlyContainsUserCerts;
	int fOnlyContainsCACerts;
	_CRYPT_BIT_BLOB OnlySomeReasonFlags;
	int fIndirectCRL;
};
#pragma pack(pop)

/* 2150 */
#pragma pack(push, 1)
class _SERVICE_DESCRIPTIONA
{
	char* lpDescription;
};
#pragma pack(pop)

/* 2151 */
#pragma pack(push, 1)
class _CRYPT_ENROLLMENT_NAME_VALUE_PAIR
{
	unsigned __int16* pwszName;
	unsigned __int16* pwszValue;
};
#pragma pack(pop)

/* 2152 */
#pragma pack(push, 1)
class timeval
{
	int tv_sec;
	int tv_usec;
};
#pragma pack(pop)

/* 2153 */
#pragma pack(push, 1)
class tagBITMAP
{
	int bmType;
	int bmWidth;
	int bmHeight;
	int bmWidthBytes;
	unsigned __int16 bmPlanes;
	unsigned __int16 bmBitsPixel;
	void* bmBits;
};
#pragma pack(pop)

/* 2154 */
#pragma pack(push, 1)
class tagDIBSECTION
{
	tagBITMAP dsBm;
	tagBITMAPINFOHEADER dsBmih;
	unsigned int dsBitfields[3];
	void* dshSection;
	unsigned int dsOffset;
};
#pragma pack(pop)

/* 2155 */
#pragma pack(push, 1)
class __declspec(align(4)) _WIN32_STREAM_ID
{
	unsigned int dwStreamId;
	unsigned int dwStreamAttributes;
	_LARGE_INTEGER Size;
	unsigned int dwStreamNameSize;
	unsigned __int16 cStreamName[1];
};
#pragma pack(pop)

/* 2156 */
#pragma pack(push, 1)
class _TOKEN_OWNER
{
	void* Owner;
};
#pragma pack(pop)

/* 2157 */
#pragma pack(push, 1)
class _CMSG_RC4_AUX_INFO
{
	unsigned int cbSize;
	unsigned int dwBitLen;
};
#pragma pack(pop)

/* 2158 */
#pragma pack(push, 1)
class _EVENTSFORLOGFILE
{
	unsigned int ulSize;
	unsigned __int16 szLogicalLogFile[256];
	unsigned int ulNumRecords;
	_EVENTLOGRECORD pEventLogRecords[];
};
#pragma pack(pop)

/* 2159 */
#pragma pack(push, 1)
class __declspec(align(2)) _IMAGE_RESOURCE_DIRECTORY_STRING
{
	unsigned __int16 Length;
	char NameString[1];
};
#pragma pack(pop)

/* 2160 */
#pragma pack(push, 1)
class _CRYPT_CSP_PROVIDER
{
	unsigned int dwKeySpec;
	unsigned __int16* pwszProviderName;
	_CRYPT_BIT_BLOB Signature;
};
#pragma pack(pop)

/* 2161 */
#pragma pack(push, 1)
class _ACCESS_DENIED_OBJECT_ACE
{
	_ACE_HEADER Header;
	unsigned int Mask;
	unsigned int Flags;
	_GUID ObjectType;
	_GUID InheritedObjectType;
	unsigned int SidStart;
};
#pragma pack(pop)

/* 2162 */
#pragma pack(push, 1)
class _IMAGE_DOS_HEADER
{
	unsigned __int16 e_magic;
	unsigned __int16 e_cblp;
	unsigned __int16 e_cp;
	unsigned __int16 e_crlc;
	unsigned __int16 e_cparhdr;
	unsigned __int16 e_minalloc;
	unsigned __int16 e_maxalloc;
	unsigned __int16 e_ss;
	unsigned __int16 e_sp;
	unsigned __int16 e_csum;
	unsigned __int16 e_ip;
	unsigned __int16 e_cs;
	unsigned __int16 e_lfarlc;
	unsigned __int16 e_ovno;
	unsigned __int16 e_res[4];
	unsigned __int16 e_oemid;
	unsigned __int16 e_oeminfo;
	unsigned __int16 e_res2[10];
	int e_lfanew;
};
#pragma pack(pop)

/* 2163 */
#pragma pack(push, 1)
class _CTL_ANY_SUBJECT_INFO
{
	_CRYPT_ALGORITHM_IDENTIFIER SubjectAlgorithm;
	_CRYPTOAPI_BLOB SubjectIdentifier;
};
#pragma pack(pop)

/* 2164 */
#pragma pack(push, 1)
class _PRIVKEYVER3
{
	unsigned int magic;
	unsigned int bitlenP;
	unsigned int bitlenQ;
	unsigned int bitlenJ;
	unsigned int bitlenX;
	_DSSSEED DSSSeed;
};
#pragma pack(pop)

/* 2165 */
#pragma pack(push, 1)
class tagLASTINPUTINFO
{
	unsigned int cbSize;
	unsigned int dwTime;
};
#pragma pack(pop)

/* 2166 */
#pragma pack(push, 1)
class tagIMEMENUITEMINFOW
{
	unsigned int cbSize;
	unsigned int fType;
	unsigned int fState;
	unsigned int wID;
	HBITMAP__* hbmpChecked;
	HBITMAP__* hbmpUnchecked;
	unsigned int dwItemData;
	unsigned __int16 szString[80];
	HBITMAP__* hbmpItem;
};
#pragma pack(pop)

/* 2167 */
#pragma pack(push, 1)
class tagCOLORADJUSTMENT
{
	unsigned __int16 caSize;
	unsigned __int16 caFlags;
	unsigned __int16 caIlluminantIndex;
	unsigned __int16 caRedGamma;
	unsigned __int16 caGreenGamma;
	unsigned __int16 caBlueGamma;
	unsigned __int16 caReferenceBlack;
	unsigned __int16 caReferenceWhite;
	__int16 caContrast;
	__int16 caBrightness;
	__int16 caColorfulness;
	__int16 caRedGreenTint;
};
#pragma pack(pop)

/* 2168 */
#pragma pack(push, 1)
class tagEMRSETCOLORADJUSTMENT
{
	tagEMR emr;
	tagCOLORADJUSTMENT ColorAdjustment;
};
#pragma pack(pop)

/* 2169 */
#pragma pack(push, 1)
class _CERT_NAME_INFO
{
	unsigned int cRDN;
	_CERT_RDN* rgRDN;
};
#pragma pack(pop)

/* 2170 */
#pragma pack(push, 1)
class tagNONCLIENTMETRICSW
{
	unsigned int cbSize;
	int iBorderWidth;
	int iScrollWidth;
	int iScrollHeight;
	int iCaptionWidth;
	int iCaptionHeight;
	tagLOGFONTW lfCaptionFont;
	int iSmCaptionWidth;
	int iSmCaptionHeight;
	tagLOGFONTW lfSmCaptionFont;
	int iMenuWidth;
	int iMenuHeight;
	tagLOGFONTW lfMenuFont;
	tagLOGFONTW lfStatusFont;
	tagLOGFONTW lfMessageFont;
};
#pragma pack(pop)

/* 2171 */
#pragma pack(push, 1)
class tagEMRSETVIEWPORTORGEX
{
	tagEMR emr;
	_POINTL ptlOrigin;
};
#pragma pack(pop)

/* 2172 */
#pragma pack(push, 1)
class _SERVICE_TABLE_ENTRYA
{
	char* lpServiceName;
	void(__stdcall* lpServiceProc)(unsigned int, char**);
};
#pragma pack(pop)

/* 2173 */
#pragma pack(push, 1)
class _MENU_EVENT_RECORD
{
	unsigned int dwCommandId;
};
#pragma pack(pop)

/* 2174 */
#pragma pack(push, 1)
class _RGNDATAHEADER
{
	unsigned int dwSize;
	unsigned int iType;
	unsigned int nCount;
	unsigned int nRgnSize;
	tagRECT rcBound;
};
#pragma pack(pop)

/* 2175 */
#pragma pack(push, 1)
class __declspec(align(4)) _RGNDATA
{
	_RGNDATAHEADER rdh;
	char Buffer[1];
};
#pragma pack(pop)

/* 2176 */
#pragma pack(push, 1)
class _REMOTE_NAME_INFOA
{
	char* lpUniversalName;
	char* lpConnectionName;
	char* lpRemainingPath;
};
#pragma pack(pop)

/* 2177 */
#pragma pack(push, 1)
class _CMSG_STREAM_INFO
{
	unsigned int cbContent;
	int(__stdcall* pfnStreamOutput)(const void*, unsigned __int8*, unsigned int, int);
	void* pvArg;
};
#pragma pack(pop)

/* 2178 */
#pragma pack(push, 1)
class tagFILTERKEYS
{
	unsigned int cbSize;
	unsigned int dwFlags;
	unsigned int iWaitMSec;
	unsigned int iDelayMSec;
	unsigned int iRepeatMSec;
	unsigned int iBounceMSec;
};
#pragma pack(pop)

/* 2179 */
#pragma pack(push, 1)
class _CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO
{
	unsigned int cbSize;
	_CMSG_SIGNED_ENCODE_INFO SignedInfo;
	_CMSG_ENVELOPED_ENCODE_INFO EnvelopedInfo;
};
#pragma pack(pop)

/* 2180 */
#pragma pack(push, 1)
class tagEMRSETTEXTCOLOR
{
	tagEMR emr;
	unsigned int crColor;
};
#pragma pack(pop)

/* 2181 */
#pragma pack(push, 1)
class _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA
{
	unsigned int cbSize;
	unsigned int dwRegPolicySettings;
	_CMSG_SIGNER_INFO* pSignerInfo;
};
#pragma pack(pop)

/* 2182 */
#pragma pack(push, 1)
class _DOCINFOW
{
	int cbSize;
	const unsigned __int16* lpszDocName;
	const unsigned __int16* lpszOutput;
	const unsigned __int16* lpszDatatype;
	unsigned int fwType;
};
#pragma pack(pop)

/* 2183 */
#pragma pack(push, 1)
class tagDELETEITEMclass
{
	unsigned int CtlType;
	unsigned int CtlID;
	unsigned int itemID;
	HWND__* hwndItem;
	unsigned int itemData;
};
#pragma pack(pop)

/* 2184 */
#pragma pack(push, 1)
class _WSANETWORKEVENTS
{
	int lNetworkEvents;
	int iErrorCode[10];
};
#pragma pack(pop)

/* 2185 */
#pragma pack(push, 1)
class _s__ThrowInfo
{
	unsigned int attributes;
	void(__cdecl* pmfnUnwind)();
	int (*pForwardCompat)(...);
	const _s__CatchableTypeArray* pCatchableTypeArray;
};
#pragma pack(pop)

/* 2186 */
#pragma pack(push, 1)
class tagMONITORINFOEXW : tagMONITORINFO
{
	unsigned __int16 szDevice[32];
};
#pragma pack(pop)

/* 2187 */
#pragma pack(push, 1)
class _SPC_STATEMENT_TYPE
{
	unsigned int cKeyPurposeId;
	char** rgpszKeyPurposeId;
};
#pragma pack(pop)

/* 2188 */
#pragma pack(push, 1)
class _SYSTEM_POWER_POLICY
{
	unsigned int Revision;
	POWER_ACTION_POLICY PowerButton;
	POWER_ACTION_POLICY SleepButton;
	POWER_ACTION_POLICY LidClose;
	_SYSTEM_POWER_STATE LidOpenWake;
	unsigned int Reserved;
	POWER_ACTION_POLICY Idle;
	unsigned int IdleTimeout;
	unsigned __int8 IdleSensitivity;
	unsigned __int8 DynamicThrottle;
	unsigned __int8 Spare2[2];
	_SYSTEM_POWER_STATE MinSleep;
	_SYSTEM_POWER_STATE MaxSleep;
	_SYSTEM_POWER_STATE ReducedLatencySleep;
	unsigned int WinLogonFlags;
	unsigned int Spare3;
	unsigned int DozeS4Timeout;
	unsigned int BroadcastCapacityResolution;
	SYSTEM_POWER_LEVEL DischargePolicy[4];
	unsigned int VideoTimeout;
	unsigned __int8 VideoDimDisplay;
	__declspec(align(4)) unsigned int VideoReserved[3];
	unsigned int SpindownTimeout;
	unsigned __int8 OptimizeForPower;
	unsigned __int8 FanThrottleTolerance;
	unsigned __int8 ForcedThrottle;
	unsigned __int8 MinThrottle;
	POWER_ACTION_POLICY OverThrottled;
};
#pragma pack(pop)

/* 2189 */
#pragma pack(push, 1)
class $44E7751A2B70AB36D090951818B95330
{
	unsigned int VendorId[3];
	unsigned int VersionInformation;
	unsigned int FeatureInformation;
	unsigned int AMDExtendedCpuFeatures;
};
#pragma pack(pop)

/* 2190 */
#pragma pack(push, 1)
class $A28000F58A7F124D98C6BF6C6DA7C605
{
	unsigned __int64 ProcessorFeatures[2];
};
#pragma pack(pop)

/* 2191 */
#pragma pack(push, 1)
union _MINIDUMP_SYSTEM_INFO::_CPU_INFORMATION
{
	$44E7751A2B70AB36D090951818B95330 X86CpuInfo;
	$A28000F58A7F124D98C6BF6C6DA7C605 OtherCpuInfo;
};
#pragma pack(pop)

/* 2192 */
#pragma pack(push, 1)
class $38C9EA4E2E79446463212EE9EB9DB941
{
	unsigned __int8 NumberOfProcessors;
	unsigned __int8 ProductType;
};
#pragma pack(pop)

/* 2193 */
#pragma pack(push, 1)
union $3557C061EB51CE99B2AB22ECDA46911A
{
	unsigned __int16 Reserved0;
	$38C9EA4E2E79446463212EE9EB9DB941 __s1;
};
#pragma pack(pop)

/* 2194 */
#pragma pack(push, 1)
class $D5B077CA334BA913C0B57B91D139B80B
{
	unsigned __int16 SuiteMask;
	unsigned __int16 Reserved2;
};
#pragma pack(pop)

/* 2195 */
#pragma pack(push, 1)
union $8A9A4BB81A03D3F018D9D99561F28276
{
	unsigned int Reserved1;
	$D5B077CA334BA913C0B57B91D139B80B __s1;
};
#pragma pack(pop)

/* 2196 */
#pragma pack(push, 1)
class _MINIDUMP_SYSTEM_INFO
{
	unsigned __int16 ProcessorArchitecture;
	unsigned __int16 ProcessorLevel;
	unsigned __int16 ProcessorRevision;
	$3557C061EB51CE99B2AB22ECDA46911A ___u3;
	unsigned int MajorVersion;
	unsigned int MinorVersion;
	unsigned int BuildNumber;
	unsigned int PlatformId;
	unsigned int CSDVersionRva;
	$8A9A4BB81A03D3F018D9D99561F28276 ___u9;
	_MINIDUMP_SYSTEM_INFO::_CPU_INFORMATION Cpu;
};
#pragma pack(pop)

/* 2197 */
#pragma pack(push, 1)
class _IMAGE_RESOURCE_DIR_STRING_U
{
	unsigned __int16 Length;
	unsigned __int16 NameString[1];
};
#pragma pack(pop)

/* 2198 */
#pragma pack(push, 1)
class tagEMRMASKBLT
{
	tagEMR emr;
	_RECTL rclBounds;
	int xDest;
	int yDest;
	int cxDest;
	int cyDest;
	unsigned int dwRop;
	int xSrc;
	int ySrc;
	tagXFORM xformSrc;
	unsigned int crBkColorSrc;
	unsigned int iUsageSrc;
	unsigned int offBmiSrc;
	unsigned int cbBmiSrc;
	unsigned int offBitsSrc;
	unsigned int cbBitsSrc;
	int xMask;
	int yMask;
	unsigned int iUsageMask;
	unsigned int offBmiMask;
	unsigned int cbBmiMask;
	unsigned int offBitsMask;
	unsigned int cbBitsMask;
};
#pragma pack(pop)

/* 2199 */
#pragma pack(push, 1)
class BATTERY_REPORTING_SCALE
{
	unsigned int Granularity;
	unsigned int Capacity;
};
#pragma pack(pop)

/* 2200 */
#pragma pack(push, 1)
class tagEMRPIXELFORMAT
{
	tagEMR emr;
	tagPIXELFORMATDESCRIPTOR pfd;
};
#pragma pack(pop)

/* 2201 */
#pragma pack(push, 1)
class _SYSTEM_AUDIT_ACE
{
	_ACE_HEADER Header;
	unsigned int Mask;
	unsigned int SidStart;
};
#pragma pack(pop)

/* 2202 */
#pragma pack(push, 1)
class SERVICE_STATUS_HANDLE__
{
	int unused;
};
#pragma pack(pop)

/* 2203 */
#pragma pack(push, 1)
class tagMENUINFO
{
	unsigned int cbSize;
	unsigned int fMask;
	unsigned int dwStyle;
	unsigned int cyMax;
	HBRUSH__* hbrBack;
	unsigned int dwContextHelpID;
	unsigned int dwMenuData;
};
#pragma pack(pop)

/* 2204 */
#pragma pack(push, 1)
class _ICONINFO
{
	int fIcon;
	unsigned int xHotspot;
	unsigned int yHotspot;
	HBITMAP__* hbmMask;
	HBITMAP__* hbmColor;
};
#pragma pack(pop)

/* 2205 */
#pragma pack(push, 1)
class _CRYPTPROTECT_PROMPTclass
{
	unsigned int cbSize;
	unsigned int dwPromptFlags;
	HWND__* hwndApp;
	const unsigned __int16* szPrompt;
};
#pragma pack(pop)

/* 2206 */
#pragma pack(push, 1)
class _RTL_VERIFIER_PROVIDER_DESCRIPTOR
{
	unsigned int Length;
	_RTL_VERIFIER_DLL_DESCRIPTOR* ProviderDlls;
	void(__stdcall* ProviderDllLoadCallback)(unsigned __int16*, void*, unsigned int, void*);
	void(__stdcall* ProviderDllUnloadCallback)(unsigned __int16*, void*, unsigned int, void*);
	unsigned __int16* VerifierImage;
	unsigned int VerifierFlags;
	unsigned int VerifierDebug;
	void* RtlpGetStackTraceAddress;
	void* RtlpDebugPageHeapCreate;
	void* RtlpDebugPageHeapDestroy;
};
#pragma pack(pop)

/* 2207 */
#pragma pack(push, 1)
class _PROCESS_INFORMATION
{
	void* hProcess;
	void* hThread;
	unsigned int dwProcessId;
	unsigned int dwThreadId;
};
#pragma pack(pop)

/* 2208 */
#pragma pack(push, 1)
class __declspec(align(4)) _cpinfo
{
	unsigned int MaxCharSize;
	unsigned __int8 DefaultChar[2];
	unsigned __int8 LeadByte[12];
};
#pragma pack(pop)

/* 2209 */
#pragma pack(push, 1)
class _CRYPT_SEQUENCE_OF_ANY
{
	unsigned int cValue;
	_CRYPTOAPI_BLOB* rgValue;
};
#pragma pack(pop)

/* 2210 */
#pragma pack(push, 1)
class SHELLHOOKINFO
{
	HWND__* hwnd;
	tagRECT rc;
};
#pragma pack(pop)

/* 2211 */
#pragma pack(push, 1)
class _PSFEATURE_OUTPUT
{
	int bPageIndependent;
	int bSetPageDevice;
};
#pragma pack(pop)

/* 2212 */
#pragma pack(push, 1)
class _wfinddata_t
{
	unsigned int attrib;
	int time_create;
	int time_access;
	int time_write;
	unsigned int size;
	wchar_t name[260];
};
#pragma pack(pop)

/* 2213 */
#pragma pack(push, 1)
class _SYSTEM_AUDIT_OBJECT_ACE
{
	_ACE_HEADER Header;
	unsigned int Mask;
	unsigned int Flags;
	_GUID ObjectType;
	_GUID InheritedObjectType;
	unsigned int SidStart;
};
#pragma pack(pop)

/* 2214 */
#pragma pack(push, 1)
class netent
{
	char* n_name;
	char** n_aliases;
	__int16 n_addrtype;
	__declspec(align(4)) unsigned int n_net;
};
#pragma pack(pop)

/* 2215 */
#pragma pack(push, 1)
class _CRYPT_PKCS8_IMPORT_PARAMS
{
	_CRYPTOAPI_BLOB PrivateKey;
	int(__stdcall* pResolvehCryptProvFunc)(_CRYPT_PRIVATE_KEY_INFO*, unsigned int*, void*);
	void* pVoidResolveFunc;
	int(__stdcall* pDecryptPrivateKeyFunc)(_CRYPT_ALGORITHM_IDENTIFIER, _CRYPTOAPI_BLOB, unsigned __int8*, unsigned int*, void*);
	void* pVoidDecryptFunc;
};
#pragma pack(pop)

/* 2216 */
#pragma pack(push, 1)
class __declspec(align(4)) tagEMRGDICOMMENT
{
	tagEMR emr;
	unsigned int cbData;
	unsigned __int8 Data[1];
};
#pragma pack(pop)

/* 2217 */
#pragma pack(push, 1)
class _CRYPT_ENCRYPT_MESSAGE_PARA
{
	unsigned int cbSize;
	unsigned int dwMsgEncodingType;
	unsigned int hCryptProv;
	_CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
	void* pvEncryptionAuxInfo;
	unsigned int dwFlags;
	unsigned int dwInnerContentType;
};
#pragma pack(pop)

/* 2218 */
#pragma pack(push, 1)
class __declspec(align(4)) tagCURSORSHAPE
{
	int xHotSpot;
	int yHotSpot;
	int cx;
	int cy;
	int cbWidth;
	unsigned __int8 Planes;
	unsigned __int8 BitsPixel;
};
#pragma pack(pop)

/* 2219 */
#pragma pack(push, 1)
class _IMAGEHLP_CBA_EVENT
{
	unsigned int severity;
	unsigned int code;
	char* desc;
	void* object;
};
#pragma pack(pop)

/* 2220 */
#pragma pack(push, 1)
class provider_info
{
	unsigned int(__cdecl* pi_R0_1val)(void*, val_context*, unsigned int, void*, unsigned int*, unsigned int);
	unsigned int(__cdecl* pi_R0_allvals)(void*, val_context*, unsigned int, void*, unsigned int*, unsigned int);
	unsigned int(__cdecl* pi_R3_1val)(void*, val_context*, unsigned int, void*, unsigned int*, unsigned int);
	unsigned int(__cdecl* pi_R3_allvals)(void*, val_context*, unsigned int, void*, unsigned int*, unsigned int);
	unsigned int pi_flags;
	void* pi_key_context;
};
#pragma pack(pop)

/* 2221 */
#pragma pack(push, 1)
class _CERT_SYSTEM_STORE_INFO
{
	unsigned int cbSize;
};
#pragma pack(pop)

/* 2222 */
#pragma pack(push, 1)
class HCOLORSPACE__
{
	int unused;
};
#pragma pack(pop)

/* 2223 */
#pragma pack(push, 1)
class _TAPE_CREATE_PARTITION
{
	unsigned int Method;
	unsigned int Count;
	unsigned int Size;
};
#pragma pack(pop)

/* 2224 */
#pragma pack(push, 1)
class tagEMRSETCOLORSPACE
{
	tagEMR emr;
	unsigned int ihCS;
};
#pragma pack(pop)

/* 2225 */
#pragma pack(push, 1)
class tagSOUNDSENTRYW
{
	unsigned int cbSize;
	unsigned int dwFlags;
	unsigned int iFSTextEffect;
	unsigned int iFSTextEffectMSec;
	unsigned int iFSTextEffectColorBits;
	unsigned int iFSGrafEffect;
	unsigned int iFSGrafEffectMSec;
	unsigned int iFSGrafEffectColor;
	unsigned int iWindowsEffect;
	unsigned int iWindowsEffectMSec;
	unsigned __int16* lpszWindowsEffectDLL;
	unsigned int iWindowsEffectOrdinal;
};
#pragma pack(pop)

/* 2226 */
#pragma pack(push, 1)
class _CERT_REGISTRY_STORE_CLIENT_GPT_PARA
{
	HKEY__* hKeyBase;
	unsigned __int16* pwszRegPath;
};
#pragma pack(pop)

/* 2227 */
#pragma pack(push, 1)
class tagENUMLOGFONTW
{
	tagLOGFONTW elfLogFont;
	unsigned __int16 elfFullName[64];
	unsigned __int16 elfStyle[32];
};
#pragma pack(pop)

/* 2228 */
#pragma pack(push, 1)
class _TOKEN_AUDIT_POLICY
{
	unsigned int PolicyCount;
	_TOKEN_AUDIT_POLICY_ELEMENT Policy[1];
};
#pragma pack(pop)

/* 2229 */
#pragma pack(push, 1)
class _CONSOLE_FONT_INFO
{
	unsigned int nFont;
	_COORD dwFontSize;
};
#pragma pack(pop)

/* 2230 */
#pragma pack(push, 1)
class _DISCDLGclassW
{
	unsigned int cbclassure;
	HWND__* hwndOwner;
	unsigned __int16* lpLocalName;
	unsigned __int16* lpRemoteName;
	unsigned int dwFlags;
};
#pragma pack(pop)

/* 2231 */
#pragma pack(push, 1)
class _JOBOBJECT_BASIC_PROCESS_ID_LIST
{
	unsigned int NumberOfAssignedProcesses;
	unsigned int NumberOfProcessIdsInList;
	unsigned int ProcessIdList[1];
};
#pragma pack(pop)

/* 2232 */
#pragma pack(push, 1)
class __declspec(align(4)) _FILE_NOTIFY_INFORMATION
{
	unsigned int NextEntryOffset;
	unsigned int Action;
	unsigned int FileNameLength;
	unsigned __int16 FileName[1];
};
#pragma pack(pop)

/* 2233 */
#pragma pack(push, 1)
class _MINIDUMP_UNLOADED_MODULE
{
	unsigned __int64 BaseOfImage;
	unsigned int SizeOfImage;
	unsigned int CheckSum;
	unsigned int TimeDateStamp;
	unsigned int ModuleNameRva;
};
#pragma pack(pop)

/* 2234 */
#pragma pack(push, 1)
class _IMAGE_RESOURCE_DIRECTORY
{
	unsigned int Characteristics;
	unsigned int TimeDateStamp;
	unsigned __int16 MajorVersion;
	unsigned __int16 MinorVersion;
	unsigned __int16 NumberOfNamedEntries;
	unsigned __int16 NumberOfIdEntries;
};
#pragma pack(pop)

/* 2235 */
#pragma pack(push, 1)
class tagCOMPOSITIONFORM
{
	unsigned int dwStyle;
	tagPOINT ptCurrentPos;
	tagRECT rcArea;
};
#pragma pack(pop)

/* 2236 */
#pragma pack(push, 1)
class _SERVICE_DESCRIPTIONW
{
	unsigned __int16* lpDescription;
};
#pragma pack(pop)

/* 2237 */
#pragma pack(push, 1)
class _ldiv_t
{
	int quot;
	int rem;
};
#pragma pack(pop)

/* 2238 */
#pragma pack(push, 1)
union $CF9F4782CD5AF348D50DD0FF8046F6F7
{
	unsigned int FiberData;
	unsigned int Version;
};
#pragma pack(pop)

/* 2239 */
#pragma pack(push, 1)
class _NT_TIB32
{
	unsigned int ExceptionList;
	unsigned int StackBase;
	unsigned int StackLimit;
	unsigned int SubSystemTib;
	$CF9F4782CD5AF348D50DD0FF8046F6F7 ___u4;
	unsigned int ArbitraryUserPointer;
	unsigned int Self;
};
#pragma pack(pop)

/* 2240 */
#pragma pack(push, 1)
class _IMAGE_NT_HEADERS64
{
	unsigned int Signature;
	_IMAGE_FILE_HEADER FileHeader;
	_IMAGE_OPTIONAL_HEADER64 OptionalHeader;
};
#pragma pack(pop)

/* 2242 */
#pragma pack(push, 1)
class _IMAGE_TLS_DIRECTORY64
{
	unsigned __int64 StartAddressOfRawData;
	unsigned __int64 EndAddressOfRawData;
	unsigned __int64 AddressOfIndex;
	unsigned __int64 AddressOfCallBacks;
	unsigned int SizeOfZeroFill;
	unsigned int Characteristics;
};
#pragma pack(pop)

/* 2243 */
#pragma pack(push, 1)
class _CERT_EXTENSIONS
{
	unsigned int cExtension;
	_CERT_EXTENSION* rgExtension;
};
#pragma pack(pop)

/* 2244 */
#pragma pack(push, 1)
class _CMC_DATA_INFO
{
	unsigned int cTaggedAttribute;
	_CMC_TAGGED_ATTRIBUTE* rgTaggedAttribute;
	unsigned int cTaggedRequest;
	_CMC_TAGGED_REQUEST* rgTaggedRequest;
	unsigned int cTaggedContentInfo;
	_CMC_TAGGED_CONTENT_INFO* rgTaggedContentInfo;
	unsigned int cTaggedOtherMsg;
	_CMC_TAGGED_OTHER_MSG* rgTaggedOtherMsg;
};
#pragma pack(pop)

/* 2245 */
#pragma pack(push, 1)
class stat
{
	unsigned int st_dev;
	unsigned __int16 st_ino;
	unsigned __int16 st_mode;
	__int16 st_nlink;
	__int16 st_uid;
	__int16 st_gid;
	__declspec(align(4)) unsigned int st_rdev;
	int st_size;
	int st_atime;
	int st_mtime;
	int st_ctime;
};
#pragma pack(pop)

/* 2246 */
#pragma pack(push, 1)
class tagEMRGRADIENTFILL
{
	tagEMR emr;
	_RECTL rclBounds;
	unsigned int nVer;
	unsigned int nTri;
	unsigned int ulMode;
	_TRIVERTEX Ver[1];
};
#pragma pack(pop)

/* 2247 */
#pragma pack(push, 1)
class _CRYPT_DECODE_PARA
{
	unsigned int cbSize;
	void* (__stdcall* pfnAlloc)(unsigned int);
	void(__stdcall* pfnFree)(void*);
};
#pragma pack(pop)

/* 2248 */
#pragma pack(push, 1)
class _TI_FINDCHILDREN_PARAMS
{
	unsigned int Count;
	unsigned int Start;
	unsigned int ChildId[1];
};
#pragma pack(pop)

/* 2249 */
#pragma pack(push, 1)
class _SE_IMPERSONATION_STATE
{
	void* Token;
	unsigned __int8 CopyOnOpen;
	unsigned __int8 EffectiveOnly;
	__declspec(align(4)) _SECURITY_IMPERSONATION_LEVEL Level;
};
#pragma pack(pop)

/* 2250 */
#pragma pack(push, 1)
class tagEMREXTFLOODFILL
{
	tagEMR emr;
	_POINTL ptlStart;
	unsigned int crColor;
	unsigned int iMode;
};
#pragma pack(pop)

/* 2251 */
#pragma pack(push, 1)
class _ACCESS_ALLOWED_CALLBACK_ACE
{
	_ACE_HEADER Header;
	unsigned int Mask;
	unsigned int SidStart;
};
#pragma pack(pop)

/* 2252 */
#pragma pack(push, 1)
class _EVENTLOG_FULL_INFORMATION
{
	unsigned int dwFull;
};
#pragma pack(pop)

/* 2253 */
#pragma pack(push, 1)
class tagCBT_CREATEWNDA
{
	tagCREATEclassA* lpcs;
	HWND__* hwndInsertAfter;
};
#pragma pack(pop)

/* 2254 */
#pragma pack(push, 1)
class HHOOK__
{
	int unused;
};
#pragma pack(pop)

/* 2255 */
#pragma pack(push, 1)
class _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS
{
	unsigned int cbSize;
	int fCommercial;
};
#pragma pack(pop)

/* 2256 */
#pragma pack(push, 1)
class $81CFBC79F215A1EA9FB894A85185475E
{
	unsigned __int8 DataBuffer[1];
};
#pragma pack(pop)

/* 2257 */
#pragma pack(push, 1)
class __declspec(align(4)) _REPARSE_GUID_DATA_BUFFER
{
	unsigned int ReparseTag;
	unsigned __int16 ReparseDataLength;
	unsigned __int16 Reserved;
	_GUID ReparseGuid;
	$81CFBC79F215A1EA9FB894A85185475E GenericReparseBuffer;
};
#pragma pack(pop)

/* 2258 */
#pragma pack(push, 1)
class _SECURITY_DESCRIPTOR
{
	unsigned __int8 Revision;
	unsigned __int8 Sbz1;
	unsigned __int16 Control;
	void* Owner;
	void* Group;
	_ACL* Sacl;
	_ACL* Dacl;
};
#pragma pack(pop)

/* 2259 */
#pragma pack(push, 1)
class _CRYPT_ENCRYPTED_PRIVATE_KEY_INFO
{
	_CRYPT_ALGORITHM_IDENTIFIER EncryptionAlgorithm;
	_CRYPTOAPI_BLOB EncryptedPrivateKey;
};
#pragma pack(pop)

/* 2260 */
#pragma pack(push, 1)
class __stat64
{
	unsigned int st_dev;
	unsigned __int16 st_ino;
	unsigned __int16 st_mode;
	__int16 st_nlink;
	__int16 st_uid;
	__int16 st_gid;
	__declspec(align(4)) unsigned int st_rdev;
	__declspec(align(8)) __int64 st_size;
	__int64 st_atime;
	__int64 st_mtime;
	__int64 st_ctime;
};
#pragma pack(pop)

/* 2261 */
#pragma pack(push, 1)
class tagTTPOLYCURVE
{
	unsigned __int16 wType;
	unsigned __int16 cpfx;
	tagPOINTFX apfx[1];
};
#pragma pack(pop)

/* 2262 */
#pragma pack(push, 1)
class __declspec(align(4)) tagHW_PROFILE_INFOW
{
	unsigned int dwDockInfo;
	unsigned __int16 szHwProfileGuid[39];
	unsigned __int16 szHwProfileName[80];
};
#pragma pack(pop)

/* 2263 */
#pragma pack(push, 1)
class bad_cast : exception
{
};
#pragma pack(pop)

/* 2264 */
#pragma pack(push, 1)
class /*VFT*/ bad_cast_vtbl
{
	void(__thiscall * ~exception)(exception* this);
	const char* (__thiscall* what)(exception* this);
};
#pragma pack(pop)

/* 2265 */
#pragma pack(push, 1)
class __declspec(align(4)) _TAPE_PREPARE
{
	unsigned int Operation;
	unsigned __int8 Immediate;
};
#pragma pack(pop)

/* 2266 */
#pragma pack(push, 1)
class _CHAR_INFO
{
	$8D8B851CA9C289E8971C1A573A53B865 Char;
	unsigned __int16 Attributes;
};
#pragma pack(pop)

/* 2267 */
#pragma pack(push, 1)
class tagEMRCREATEPALETTE
{
	tagEMR emr;
	unsigned int ihPal;
	tagLOGPALETTE lgpl;
};
#pragma pack(pop)

/* 2268 */
#pragma pack(push, 1)
class _JOBOBJECT_BASIC_UI_RESTRICTIONS
{
	unsigned int UIRestrictionsClass;
};
#pragma pack(pop)

/* 2269 */
#pragma pack(push, 1)
class LIST_ENTRY64
{
	unsigned __int64 Flink;
	unsigned __int64 Blink;
};
#pragma pack(pop)

/* 2270 */
#pragma pack(push, 1)
class HPEN__
{
	int unused;
};
#pragma pack(pop)

/* 2271 */
#pragma pack(push, 1)
class __declspec(align(4)) _SECURITY_QUALITY_OF_SERVICE
{
	unsigned int Length;
	_SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
	unsigned __int8 ContextTrackingMode;
	unsigned __int8 EffectiveOnly;
};
#pragma pack(pop)

/* 2272 */
#pragma pack(push, 1)
class tagDRAWITEMclass
{
	unsigned int CtlType;
	unsigned int CtlID;
	unsigned int itemID;
	unsigned int itemAction;
	unsigned int itemState;
	HWND__* hwndItem;
	HDC__* hDC;
	tagRECT rcItem;
	unsigned int itemData;
};
#pragma pack(pop)

/* 2273 */
#pragma pack(push, 1)
class __declspec(align(8)) _stati64
{
	unsigned int st_dev;
	unsigned __int16 st_ino;
	unsigned __int16 st_mode;
	__int16 st_nlink;
	__int16 st_uid;
	__int16 st_gid;
	__declspec(align(4)) unsigned int st_rdev;
	__declspec(align(8)) __int64 st_size;
	int st_atime;
	int st_mtime;
	int st_ctime;
};
#pragma pack(pop)

/* 2274 */
#pragma pack(push, 1)
class _CRYPT_URL_INFO
{
	unsigned int cbSize;
	unsigned int dwSyncDeltaTime;
	unsigned int cGroup;
	unsigned int* rgcGroupEntry;
};
#pragma pack(pop)

/* 2275 */
#pragma pack(push, 1)
class _CAT_NAMEVALUE
{
	unsigned __int16* pwszTag;
	unsigned int fdwFlags;
	_CRYPTOAPI_BLOB Value;
};
#pragma pack(pop)

/* 2276 */
#pragma pack(push, 1)
class _TAPE_GET_DRIVE_PARAMETERS
{
	unsigned __int8 ECC;
	unsigned __int8 Compression;
	unsigned __int8 DataPadding;
	unsigned __int8 ReportSetmarks;
	unsigned int DefaultBlockSize;
	unsigned int MaximumBlockSize;
	unsigned int MinimumBlockSize;
	unsigned int MaximumPartitionCount;
	unsigned int FeaturesLow;
	unsigned int FeaturesHigh;
	unsigned int EOTWarningZoneSize;
};
#pragma pack(pop)

/* 2277 */
#pragma pack(push, 1)
class _CTL_USAGE_MATCH
{
	unsigned int dwType;
	_CTL_USAGE Usage;
};
#pragma pack(pop)

/* 2278 */
#pragma pack(push, 1)
class _CrtMemState
{
	_CrtMemBlockHeader* pBlockHeader;
	unsigned int lCounts[5];
	unsigned int lSizes[5];
	unsigned int lHighWaterCount;
	unsigned int lTotalCount;
};
#pragma pack(pop)

/* 2279 */
#pragma pack(push, 1)
class _TAPE_SET_MEDIA_PARAMETERS
{
	unsigned int BlockSize;
};
#pragma pack(pop)

/* 2280 */
#pragma pack(push, 1)
class tagMDICREATEclassW
{
	const unsigned __int16* szClass;
	const unsigned __int16* szTitle;
	void* hOwner;
	int x;
	int y;
	int cx;
	int cy;
	unsigned int style;
	int lParam;
};
#pragma pack(pop)

/* 2281 */
#pragma pack(push, 1)
class _CONSOLE_SELECTION_INFO
{
	unsigned int dwFlags;
	_COORD dwSelectionAnchor;
	_SMALL_RECT srSelection;
};
#pragma pack(pop)

/* 2282 */
#pragma pack(push, 1)
class SYSTEM_POWER_CAPABILITIES
{
	unsigned __int8 PowerButtonPresent;
	unsigned __int8 SleepButtonPresent;
	unsigned __int8 LidPresent;
	unsigned __int8 SystemS1;
	unsigned __int8 SystemS2;
	unsigned __int8 SystemS3;
	unsigned __int8 SystemS4;
	unsigned __int8 SystemS5;
	unsigned __int8 HiberFilePresent;
	unsigned __int8 FullWake;
	unsigned __int8 VideoDimPresent;
	unsigned __int8 ApmPresent;
	unsigned __int8 UpsPresent;
	unsigned __int8 ThermalControl;
	unsigned __int8 ProcessorThrottle;
	unsigned __int8 ProcessorMinThrottle;
	unsigned __int8 ProcessorMaxThrottle;
	unsigned __int8 spare2[4];
	unsigned __int8 DiskSpinDown;
	unsigned __int8 spare3[8];
	unsigned __int8 SystemBatteriesPresent;
	unsigned __int8 BatteriesAreShortTerm;
	BATTERY_REPORTING_SCALE BatteryScale[3];
	_SYSTEM_POWER_STATE AcOnLineWake;
	_SYSTEM_POWER_STATE SoftLidWake;
	_SYSTEM_POWER_STATE RtcWake;
	_SYSTEM_POWER_STATE MinDeviceWakeState;
	_SYSTEM_POWER_STATE DefaultLowLatencyWake;
};
#pragma pack(pop)

/* 2283 */
#pragma pack(push, 1)
class __declspec(align(8)) _IMAGEHLP_SYMBOL64_PACKAGE
{
	_IMAGEHLP_SYMBOL64 sym;
	char name[2001];
};
#pragma pack(pop)

/* 2284 */
#pragma pack(push, 1)
class __declspec(align(4)) tagEMRGLSBOUNDEDRECORD
{
	tagEMR emr;
	_RECTL rclBounds;
	unsigned int cbData;
	unsigned __int8 Data[1];
};
#pragma pack(pop)

/* 2285 */
#pragma pack(push, 1)
union $6B84D2CDCE6E5204C10DDF1976147828
{
	unsigned int Characteristics;
	unsigned int OriginalFirstThunk;
};
#pragma pack(pop)

/* 2286 */
#pragma pack(push, 1)
class _IMAGE_IMPORT_DESCRIPTOR
{
	$6B84D2CDCE6E5204C10DDF1976147828 ___u0;
	unsigned int TimeDateStamp;
	unsigned int ForwarderChain;
	unsigned int Name;
	unsigned int FirstThunk;
};
#pragma pack(pop)

/* 2287 */
#pragma pack(push, 1)
class _DRAWPATRECT
{
	tagPOINT ptPosition;
	tagPOINT ptSize;
	unsigned __int16 wStyle;
	unsigned __int16 wPattern;
};
#pragma pack(pop)

/* 2288 */
#pragma pack(push, 1)
class tagEMRBITBLT
{
	tagEMR emr;
	_RECTL rclBounds;
	int xDest;
	int yDest;
	int cxDest;
	int cyDest;
	unsigned int dwRop;
	int xSrc;
	int ySrc;
	tagXFORM xformSrc;
	unsigned int crBkColorSrc;
	unsigned int iUsageSrc;
	unsigned int offBmiSrc;
	unsigned int cbBmiSrc;
	unsigned int offBitsSrc;
	unsigned int cbBitsSrc;
};
#pragma pack(pop)

/* 2289 */
#pragma pack(push, 1)
class _SERVICE_FAILURE_ACTIONSW
{
	unsigned int dwResetPeriod;
	unsigned __int16* lpRebootMsg;
	unsigned __int16* lpCommand;
	unsigned int cActions;
	_SC_ACTION* lpsaActions;
};
#pragma pack(pop)

/* 2290 */
#pragma pack(push, 1)
class _SID
{
	unsigned __int8 Revision;
	unsigned __int8 SubAuthorityCount;
	_SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
	unsigned int SubAuthority[1];
};
#pragma pack(pop)

/* 2291 */
#pragma pack(push, 1)
class tagEMRSETMAPPERFLAGS
{
	tagEMR emr;
	unsigned int dwFlags;
};
#pragma pack(pop)

/* 2292 */
#pragma pack(push, 1)
class tagMDINEXTMENU
{
	HMENU__* hmenuIn;
	HMENU__* hmenuNext;
	HWND__* hwndNext;
};
#pragma pack(pop)

/* 2293 */
#pragma pack(push, 1)
class bad_typeid : exception
{
};
#pragma pack(pop)

/* 2294 */
#pragma pack(push, 1)
class /*VFT*/ bad_typeid_vtbl
{
	void(__thiscall * ~exception)(exception* this);
	const char* (__thiscall* what)(exception* this);
};
#pragma pack(pop)

/* 2295 */
#pragma pack(push, 1)
class __non_rtti_object : bad_typeid
{
};
#pragma pack(pop)

/* 2296 */
#pragma pack(push, 1)
class /*VFT*/ __non_rtti_object_vtbl
{
	void(__thiscall * ~exception)(exception* this);
	const char* (__thiscall* what)(exception* this);
};
#pragma pack(pop)

/* 2297 */
#pragma pack(push, 1)
class tagEMRSETPALETTEENTRIES
{
	tagEMR emr;
	unsigned int ihPal;
	unsigned int iStart;
	unsigned int cEntries;
	tagPALETTEENTRY aPalEntries[1];
};
#pragma pack(pop)

/* 2298 */
#pragma pack(push, 1)
class _WIN_TRUST_SUBJECT_FILE_AND_DISPLAY
{
	void* hFile;
	const unsigned __int16* lpPath;
	const unsigned __int16* lpDisplayName;
};
#pragma pack(pop)

/* 2299 */
#pragma pack(push, 1)
class _EXCEPTION_RECORD64
{
	unsigned int ExceptionCode;
	unsigned int ExceptionFlags;
	unsigned __int64 ExceptionRecord;
	unsigned __int64 ExceptionAddress;
	unsigned int NumberParameters;
	unsigned int __unusedAlignment;
	unsigned __int64 ExceptionInformation[15];
};
#pragma pack(pop)

/* 2300 */
#pragma pack(push, 1)
class tagEMRRESIZEPALETTE
{
	tagEMR emr;
	unsigned int ihPal;
	unsigned int cEntries;
};
#pragma pack(pop)

/* 2301 */
#pragma pack(push, 1)
class _OBJECT_TYPE_LIST
{
	unsigned __int16 Level;
	unsigned __int16 Sbz;
	_GUID* ObjectType;
};
#pragma pack(pop)

/* 2302 */
#pragma pack(push, 1)
class _TIME_ZONE_INFORMATION
{
	int Bias;
	unsigned __int16 StandardName[32];
	_SYSTEMTIME StandardDate;
	int StandardBias;
	unsigned __int16 DaylightName[32];
	_SYSTEMTIME DaylightDate;
	int DaylightBias;
};
#pragma pack(pop)

/* 2303 */
#pragma pack(push, 1)
class _CERT_POLICY95_QUALIFIER1
{
	unsigned __int16* pszPracticesReference;
	char* pszNoticeIdentifier;
	char* pszNSINoticeIdentifier;
	unsigned int cCPSURLs;
	_CPS_URLS* rgCPSURLs;
};
#pragma pack(pop)

/* 2304 */
#pragma pack(push, 1)
class tagTPMPARAMS
{
	unsigned int cbSize;
	tagRECT rcExclude;
};
#pragma pack(pop)

/* 2305 */
#pragma pack(push, 1)
class pvalueW
{
	unsigned __int16* pv_valuename;
	int pv_valuelen;
	void* pv_value_context;
	unsigned int pv_type;
};
#pragma pack(pop)

/* 2306 */
#pragma pack(push, 1)
class _WINDOW_BUFFER_SIZE_RECORD
{
	_COORD dwSize;
};
#pragma pack(pop)

/* 2307 */
#pragma pack(push, 1)
union $42C71B314E25157035E31C91D5943160
{
	_KEY_EVENT_RECORD KeyEvent;
	_MOUSE_EVENT_RECORD MouseEvent;
	_WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
	_MENU_EVENT_RECORD MenuEvent;
	_FOCUS_EVENT_RECORD FocusEvent;
};
#pragma pack(pop)

/* 2308 */
#pragma pack(push, 1)
class _INPUT_RECORD
{
	unsigned __int16 EventType;
	__declspec(align(4)) $42C71B314E25157035E31C91D5943160 Event;
};
#pragma pack(pop)

/* 2309 */
#pragma pack(push, 1)
union $016E46D5E420760DC50D7CB12CBF6D6F
{
	HKEY__* hKeyBase;
	void* pvBase;
};
#pragma pack(pop)

/* 2310 */
#pragma pack(push, 1)
union $1DB679CB627BC5FA25847724F7AEEA1F
{
	void* pvSystemStore;
	const char* pszSystemStore;
	const unsigned __int16* pwszSystemStore;
};
#pragma pack(pop)

/* 2311 */
#pragma pack(push, 1)
class _CERT_SYSTEM_STORE_RELOCATE_PARA
{
	$016E46D5E420760DC50D7CB12CBF6D6F ___u0;
	$1DB679CB627BC5FA25847724F7AEEA1F ___u1;
};
#pragma pack(pop)

/* 2312 */
#pragma pack(push, 1)
class tm
{
	int tm_sec;
	int tm_min;
	int tm_hour;
	int tm_mday;
	int tm_mon;
	int tm_year;
	int tm_wday;
	int tm_yday;
	int tm_isdst;
};
#pragma pack(pop)

/* 2313 */
#pragma pack(push, 1)
class _MINIDUMP_LOCATION_DESCRIPTOR64
{
	unsigned __int64 DataSize;
	unsigned __int64 Rva;
};
#pragma pack(pop)

/* 2314 */
#pragma pack(push, 1)
class _PSFEATURE_CUSTPAPER
{
	int lOrientation;
	int lWidth;
	int lHeight;
	int lWidthOffset;
	int lHeightOffset;
};
#pragma pack(pop)

/* 2315 */
#pragma pack(push, 1)
union $E13F4F8FF4D15A76AC53ACCE0FD29C88
{
	unsigned __int64 ForwarderString;
	unsigned __int64 Function;
	unsigned __int64 Ordinal;
	unsigned __int64 AddressOfData;
};
#pragma pack(pop)

/* 2316 */
#pragma pack(push, 1)
class _IMAGE_THUNK_DATA64
{
	$E13F4F8FF4D15A76AC53ACCE0FD29C88 u1;
};
#pragma pack(pop)

/* 2317 */
#pragma pack(push, 1)
class __declspec(align(4)) protoent
{
	char* p_name;
	char** p_aliases;
	__int16 p_proto;
};
#pragma pack(pop)

/* 2318 */
#pragma pack(push, 1)
class HDESK__
{
	int unused;
};
#pragma pack(pop)

/* 2319 */
#pragma pack(push, 1)
class _QOS_SD_MODE
{
	QOS_OBJECT_HDR ObjectHdr;
	unsigned int ShapeDiscardMode;
};
#pragma pack(pop)

/* 2320 */
#pragma pack(push, 1)
class MENUITEMTEMPLATE
{
	unsigned __int16 mtOption;
	unsigned __int16 mtID;
	unsigned __int16 mtString[1];
};
#pragma pack(pop)

/* 2321 */
#pragma pack(push, 1)
class _PUBLICKEYSTRUC
{
	unsigned __int8 bType;
	unsigned __int8 bVersion;
	unsigned __int16 reserved;
	unsigned int aiKeyAlg;
};
#pragma pack(pop)

/* 2322 */
#pragma pack(push, 1)
class tagGCP_RESULTSW
{
	unsigned int lclassSize;
	unsigned __int16* lpOutString;
	unsigned int* lpOrder;
	int* lpDx;
	int* lpCaretPos;
	char* lpClass;
	unsigned __int16* lpGlyphs;
	unsigned int nGlyphs;
	int nMaxFit;
};
#pragma pack(pop)

/* 2323 */
#pragma pack(push, 1)
class tagHARDWAREHOOKclass
{
	HWND__* hwnd;
	unsigned int message;
	unsigned int wParam;
	int lParam;
};
#pragma pack(pop)

/* 2324 */
#pragma pack(push, 1)
class _QUOTA_LIMITS_EX
{
	unsigned int PagedPoolLimit;
	unsigned int NonPagedPoolLimit;
	unsigned int MinimumWorkingSetSize;
	unsigned int MaximumWorkingSetSize;
	unsigned int PagefileLimit;
	__declspec(align(8)) _LARGE_INTEGER TimeLimit;
	unsigned int Reserved1;
	unsigned int Reserved2;
	unsigned int Reserved3;
	unsigned int Reserved4;
	unsigned int Flags;
	unsigned int Reserved5;
};
#pragma pack(pop)

/* 2325 */
#pragma pack(push, 1)
class __declspec(align(2)) _IMAGE_IMPORT_BY_NAME
{
	unsigned __int16 Hint;
	unsigned __int8 Name[1];
};
#pragma pack(pop)

/* 2326 */
#pragma pack(push, 1)
class __s_GUID
{
	unsigned int Data1;
	unsigned __int16 Data2;
	unsigned __int16 Data3;
	unsigned __int8 Data4[8];
};
#pragma pack(pop)

/* 2327 */
#pragma pack(push, 1)
class _CRYPT_KEY_VERIFY_MESSAGE_PARA
{
	unsigned int cbSize;
	unsigned int dwMsgEncodingType;
	unsigned int hCryptProv;
};
#pragma pack(pop)

/* 2328 */
#pragma pack(push, 1)
class _CERT_CHAIN_ENGINE_CONFIG
{
	unsigned int cbSize;
	void* hRestrictedRoot;
	void* hRestrictedTrust;
	void* hRestrictedOther;
	unsigned int cAdditionalStore;
	void** rghAdditionalStore;
	unsigned int dwFlags;
	unsigned int dwUrlRetrievalTimeout;
	unsigned int MaximumCachedCertificates;
	unsigned int CycleDetectionModulus;
};
#pragma pack(pop)

/* 2329 */
#pragma pack(push, 1)
class HSTR__
{
	int unused;
};
#pragma pack(pop)

/* 2330 */
#pragma pack(push, 1)
class _ACL_REVISION_INFORMATION
{
	unsigned int AclRevision;
};
#pragma pack(pop)

/* 2331 */
#pragma pack(push, 1)
class DATE_TIME
{
	int year;
	int month;
	int day;
	int hour;
	int minute;
	int second;
};
#pragma pack(pop)

/* 2332 */
#pragma pack(push, 1)
class CDBSocket : CIOSocket
{
};
#pragma pack(pop)

/* 2333 */
#pragma pack(push, 1)
class /*VFT*/ CDBSocket_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	void(__thiscall* OnCreate)(CIOSocket* this);
	void(__thiscall* OnClose)(CIOSocket* this);
	void(__thiscall* OnRead)(CIOSocket* this);
};
#pragma pack(pop)

/* 2334 */
#pragma pack(push, 1)
class __unaligned __declspec(align(1)) DBPACKET
{
	unsigned __int16 wSize;
	unsigned __int8 byType;
	char data[];
};
#pragma pack(pop)

/* 2335 */
#pragma pack(push, 1)
class CAuthSocket : CIOSocket
{
};
#pragma pack(pop)

/* 2336 */
#pragma pack(push, 1)
class /*VFT*/ CAuthSocket_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	void(__thiscall* OnCreate)(CIOSocket* this);
	void(__thiscall* OnClose)(CIOSocket* this);
	void(__thiscall* OnRead)(CIOSocket* this);
};
#pragma pack(pop)

/* 2337 */
#pragma pack(push, 1)
class __unaligned __declspec(align(1)) AUTHPACKET
{
	unsigned __int16 wSize;
	unsigned __int8 byType;
	char data[];
};
#pragma pack(pop)

/* 2338 */
#pragma pack(push, 1)
class std::binary_function<CPlayer*, CPlayer*, bool>
{
};
#pragma pack(pop)

/* 2339 */
#pragma pack(push, 1)
class std::less<CPlayer*> : std::binary_function<CPlayer*, CPlayer*, bool>
{
};
#pragma pack(pop)

/* 2340 */
#pragma pack(push, 1)
class std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0>
{
	std::less<CPlayer*> comp;
};
#pragma pack(pop)

/* 2341 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2342 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2343 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> > : std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 2344 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2345 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2346 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> > : std::_Tree_nod<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 2347 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<CPlayer* const, int> >
{
};
#pragma pack(pop)

/* 2348 */
#pragma pack(push, 1)
class std::allocator<std::pair<CPlayer* const, int> > : std::_Allocator_base<std::pair<CPlayer* const, int> >
{
};
#pragma pack(pop)

/* 2349 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >
{
	std::allocator<std::pair<CPlayer* const, int> > _Alval;
};
#pragma pack(pop)

/* 2350 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::_Node* _Right;
	std::pair<CPlayer* const, int> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 2351 */
#pragma pack(push, 1)
class std::pair<CPlayer* const, int>
{
	CPlayer* const first;
	int second;
};
#pragma pack(pop)

/* 2352 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> > : std::_Tree_val<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 2353 */
#pragma pack(push, 1)
class std::map<CPlayer*, int> : std::_Tree<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >
{
};
#pragma pack(pop)

/* 2354 */
#pragma pack(push, 1)
class std::binary_function<CParty*, CParty*, bool>
{
};
#pragma pack(pop)

/* 2355 */
#pragma pack(push, 1)
class std::less<CParty*> : std::binary_function<CParty*, CParty*, bool>
{
};
#pragma pack(pop)

/* 2356 */
#pragma pack(push, 1)
class std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0>
{
	std::less<CParty*> comp;
};
#pragma pack(pop)

/* 2357 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2358 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2359 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> > : std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 2360 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2361 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2362 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> > : std::_Tree_nod<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 2363 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<CParty* const, int> >
{
};
#pragma pack(pop)

/* 2364 */
#pragma pack(push, 1)
class std::allocator<std::pair<CParty* const, int> > : std::_Allocator_base<std::pair<CParty* const, int> >
{
};
#pragma pack(pop)

/* 2365 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >
{
	std::allocator<std::pair<CParty* const, int> > _Alval;
};
#pragma pack(pop)

/* 2366 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >::_Node* _Right;
	std::pair<CParty* const, int> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 2373 */
#pragma pack(push, 1)
class std::pair<CParty* const, int>
{
	CParty* const first;
	int second;
};
#pragma pack(pop)

/* 2367 */
#pragma pack(push, 1)
class std::_Allocator_base<CPlayer*>
{
};
#pragma pack(pop)

/* 2368 */
#pragma pack(push, 1)
class std::allocator<CPlayer*> : std::_Allocator_base<CPlayer*>
{
};
#pragma pack(pop)

/* 2369 */
#pragma pack(push, 1)
class std::_Vector_val<CPlayer*>
{
	std::allocator<CPlayer*> _Alval;
};
#pragma pack(pop)

/* 2370 */
#pragma pack(push, 1)
class std::vector<CPlayer*> : std::_Vector_val<CPlayer*>
{
	__declspec(align(4)) CPlayer** _Myfirst;
	CPlayer** _Mylast;
	CPlayer** _Myend;
};
#pragma pack(pop)

/* 2371 */
#pragma pack(push, 1)
class CParty : CIOObject
{
	int m_nId;
	CPlayer* m_pHead;
	int m_nTopLevel;
	int m_bEnd;
	std::vector<CPlayer*> m_vecParty;
	CIOCriticalSection m_lock;
	CBaseList* m_pItemList;
};
#pragma pack(pop)

/* 2372 */
#pragma pack(push, 1)
class /*VFT*/ CParty_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
};
#pragma pack(pop)

/* 2374 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> > : std::_Tree_val<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 2375 */
#pragma pack(push, 1)
class std::map<CParty*, int> : std::_Tree<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >
{
};
#pragma pack(pop)

/* 2376 */
#pragma pack(push, 1)
class CGenMonster : CBase
{
	int m_nIndex;
	int m_nMap;
	int m_nArea;
	int m_nMax;
	int m_nLive;
	int m_nRange;
	tagRECT m_rtGen;
	CSMap* m_pMap;
	unsigned int m_dwNextGen;
	unsigned int m_dwGenCycle;
	CGenMonster* m_pNextGen;
};
#pragma pack(pop)

/* 2377 */
#pragma pack(push, 1)
class /*VFT*/ CGenMonster_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
};
#pragma pack(pop)

/* 2378 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_List_nod<CMonster*>::_Node>
{
};
#pragma pack(pop)

/* 2379 */
#pragma pack(push, 1)
class std::allocator<std::_List_nod<CMonster*>::_Node> : std::_Allocator_base<std::_List_nod<CMonster*>::_Node>
{
};
#pragma pack(pop)

/* 2380 */
#pragma pack(push, 1)
class std::_List_nod<CMonster*>
{
	std::allocator<std::_List_nod<CMonster*>::_Node> _Alnod;
};
#pragma pack(pop)

/* 2381 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_List_nod<CMonster*>::_Node*>
{
};
#pragma pack(pop)

/* 2382 */
#pragma pack(push, 1)
class std::allocator<std::_List_nod<CMonster*>::_Node*> : std::_Allocator_base<std::_List_nod<CMonster*>::_Node*>
{
};
#pragma pack(pop)

/* 2383 */
#pragma pack(push, 1)
class std::_List_ptr<CMonster*> : std::_List_nod<CMonster*>
{
	std::allocator<std::_List_nod<CMonster*>::_Node*> _Alptr;
};
#pragma pack(pop)

/* 2384 */
#pragma pack(push, 1)
class std::_Allocator_base<CMonster*>
{
};
#pragma pack(pop)

/* 2385 */
#pragma pack(push, 1)
class std::allocator<CMonster*> : std::_Allocator_base<CMonster*>
{
};
#pragma pack(pop)

/* 2386 */
#pragma pack(push, 1)
class std::_List_val<CMonster*> : std::_List_ptr<CMonster*>
{
	std::allocator<CMonster*> _Alval;
};
#pragma pack(pop)

/* 2387 */
#pragma pack(push, 1)
class std::_List_nod<CMonster*>::_Node
{
	std::_List_nod<CMonster*>::_Node* _Next;
	std::_List_nod<CMonster*>::_Node* _Prev;
	CMonster* _Myval;
};
#pragma pack(pop)

/* 2388 */
#pragma pack(push, 1)
class std::list<CMonster*> : std::_List_val<CMonster*>
{
	__declspec(align(2)) std::_List_nod<CMonster*>::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 2390 */
#pragma pack(push, 1)
union $EEDA990337C0644BCB17C6E7C3C1C1E4
{
	CFindPath::NODE* pParent;
	CFindPath::NODE* m_pNext;
};
#pragma pack(pop)

/* 2389 */
#pragma pack(push, 1)
class CFindPath::NODE
{
	$EEDA990337C0644BCB17C6E7C3C1C1E4 ___u0;
	unsigned int f;
	unsigned int g;
	unsigned int h;
	int nChild;
	tagPOINT ptPixel;
	CFindPath::NODE* pChild[8];
	CFindPath::NODE* pNextBestH;
	CFindPath::NODE* pNextBestF;
};
#pragma pack(pop)

/* 2391 */
#pragma pack(push, 1)
class CFindPath
{
	CMonster* m_pOwner;
	CSMap* m_pMap;
	CFindPath::NODE* m_pTopBestH;
	CFindPath::NODE* m_pTopBestF;
	CFindPath::NODE* m_pCurrent;
	tagPOINT m_ptSPixel;
	tagPOINT m_ptEPixel;
	int m_nPowRange;
};
#pragma pack(pop)

/* 2392 */
#pragma pack(push, 1)
class std::iterator<std::random_access_iterator_tag, QUESTITEMDROP, int, QUESTITEMDROP const*, QUESTITEMDROP const&>
{
};
#pragma pack(pop)

/* 2393 */
#pragma pack(push, 1)
class std::_Ranit<QUESTITEMDROP, int, QUESTITEMDROP const*, QUESTITEMDROP const&> : std::iterator<std::random_access_iterator_tag, QUESTITEMDROP, int, QUESTITEMDROP const*, QUESTITEMDROP const&>
{
};
#pragma pack(pop)

/* 2394 */
#pragma pack(push, 1)
class std::vector<QUESTITEMDROP>::const_iterator : std::_Ranit<QUESTITEMDROP, int, QUESTITEMDROP const*, QUESTITEMDROP const&>
{
	QUESTITEMDROP* _Myptr;
};
#pragma pack(pop)

/* 2395 */
#pragma pack(push, 1)
class std::vector<QUESTITEMDROP>::iterator : std::vector<QUESTITEMDROP>::const_iterator
{
};
#pragma pack(pop)

/* 2396 */
#pragma pack(push, 1)
class std::iterator<std::random_access_iterator_tag, MSKILL, int, MSKILL const*, MSKILL const&>
{
};
#pragma pack(pop)

/* 2397 */
#pragma pack(push, 1)
class std::_Ranit<MSKILL, int, MSKILL const*, MSKILL const&> : std::iterator<std::random_access_iterator_tag, MSKILL, int, MSKILL const*, MSKILL const&>
{
};
#pragma pack(pop)

/* 2398 */
#pragma pack(push, 1)
class std::vector<MSKILL>::const_iterator : std::_Ranit<MSKILL, int, MSKILL const*, MSKILL const&>
{
	MSKILL* _Myptr;
};
#pragma pack(pop)

/* 2399 */
#pragma pack(push, 1)
class std::vector<MSKILL>::iterator : std::vector<MSKILL>::const_iterator
{
};
#pragma pack(pop)

/* 2400 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<CPlayer* const, int>, int, std::pair<CPlayer* const, int> const*, std::pair<CPlayer* const, int> const&>
{
};
#pragma pack(pop)

/* 2401 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<CPlayer* const, int>, int, std::pair<CPlayer* const, int> const*, std::pair<CPlayer* const, int> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<CPlayer* const, int>, int, std::pair<CPlayer* const, int> const*, std::pair<CPlayer* const, int> const&>
{
};
#pragma pack(pop)

/* 2402 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::const_iterator : std::_Bidit<std::pair<CPlayer* const, int>, int, std::pair<CPlayer* const, int> const*, std::pair<CPlayer* const, int> const&>
{
	std::_Tree_nod<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 2403 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 2404 */
#pragma pack(push, 1)
class CMonsterReal : CMonster
{
	tagPOINT m_ptPReturn;
	int m_nSight[2];
	int m_nRoam;
	unsigned int m_dwNextMove;
	std::map<CPlayer*, int> m_mapHostility;
	CIOCriticalSection m_lockHostility;
	int m_nAllHostility;
	int m_nMaxHostility;
	CFindPath m_findpath;
	int m_bRefindPath;
	int m_bRest;
	unsigned int m_dwAttacked;
};
#pragma pack(pop)

/* 2405 */
#pragma pack(push, 1)
class CMonsterMaguni : CMonsterReal
{
};
#pragma pack(pop)

/* 2406 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 2407 */
#pragma pack(push, 1)
class std::pair<std::_Tree<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::iterator, std::_Tree<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::iterator>
{
	std::_Tree<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::iterator first;
	std::_Tree<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::iterator second;
};
#pragma pack(pop)

/* 2408 */
#pragma pack(push, 1)
class std::allocator<std::pair<CPlayer* const, int> >::rebind<std::pair<CPlayer* const, int> >
{
};
#pragma pack(pop)

/* 2409 */
#pragma pack(push, 1)
class std::allocator<std::pair<CPlayer* const, int> >::rebind<std::_Tree_nod<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2410 */
#pragma pack(push, 1)
class std::allocator<std::pair<CPlayer* const, int> >::rebind<std::_Tree_nod<std::_Tmap_traits<CPlayer*, int, std::less<CPlayer*>, std::allocator<std::pair<CPlayer* const, int> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2411 */
#pragma pack(push, 1)
class std::allocator<std::pair<CPlayer* const, int> >::rebind<CPlayer*>
{
};
#pragma pack(pop)

/* 2412 */
#pragma pack(push, 1)
class std::allocator<std::pair<CPlayer* const, int> >::rebind<char>
{
};
#pragma pack(pop)

/* 2413 */
#pragma pack(push, 1)
class CMonsterMaguniWithSkillOnly : CMonsterMaguni
{
};
#pragma pack(pop)

/* 2414 */
#pragma pack(push, 1)
class __declspec(align(8)) CMonsterMaguniWithSkill : CMonsterMaguni
{
	unsigned int m_dwSkillTick;
};
#pragma pack(pop)

/* 2415 */
#pragma pack(push, 1)
class CMonsterTowerBoss : CMonsterReal
{
	unsigned int m_dwTick[7];
	CGenMonster* m_pGen;
};
#pragma pack(pop)

/* 2416 */
#pragma pack(push, 1)
class CMonsterNotReal : CMonster
{
};
#pragma pack(pop)

/* 2417 */
#pragma pack(push, 1)
class CMonsterInactive : CMonsterNotReal
{
};
#pragma pack(pop)

/* 2418 */
#pragma pack(push, 1)
class __declspec(align(8)) CMonsterGuildWar : CMonsterNotReal
{
	int m_nGID;
	char m_szGuildName[17];
	__declspec(align(4)) unsigned int m_dwTickExDeclare;
};
#pragma pack(pop)

/* 2419 */
#pragma pack(push, 1)
class CMonsterItem : CMonsterNotReal
{
};
#pragma pack(pop)

/* 2420 */
#pragma pack(push, 1)
class CMonsterMagic : CMonsterNotReal
{
};
#pragma pack(pop)

/* 2421 */
#pragma pack(push, 1)
class CMonsterBlackBug : CMonsterReal
{
	unsigned int m_dwTick[1];
	CGenMonster* m_pGen;
};
#pragma pack(pop)

/* 2422 */
#pragma pack(push, 1)
class CMonsterEgg : CMonsterReal
{
	unsigned int m_dwTick[1];
	CGenMonster* m_pGen;
};
#pragma pack(pop)

/* 2423 */
#pragma pack(push, 1)
class CMonsterCocoon : CMonsterReal
{
	unsigned int m_dwTick[1];
	CGenMonster* m_pGen;
};
#pragma pack(pop)

/* 2424 */
#pragma pack(push, 1)
class CMonsterMaguniMaster : CMonsterReal
{
	CGenMonster* m_pGen;
	unsigned int m_dwTick[5];
};
#pragma pack(pop)

/* 2425 */
#pragma pack(push, 1)
class CMonsterBigBirdMother : CMonsterReal
{
	unsigned int m_dwTick[3];
	CGenMonster* m_pGen;
};
#pragma pack(pop)

/* 2426 */
#pragma pack(push, 1)
class __declspec(align(8)) CMonsterFireFlower : CMonsterReal
{
	unsigned int m_dwTick[2];
	CGenMonster* m_pGen;
};
#pragma pack(pop)

/* 2427 */
#pragma pack(push, 1)
class __declspec(align(8)) CMonsterBigBirdMaster : CMonsterReal
{
	CGenMonster* m_pGen;
	unsigned int m_dwTick[4];
};
#pragma pack(pop)

/* 2428 */
#pragma pack(push, 1)
class __declspec(align(8)) CMonsterSiegeGun : CMonsterReal
{
	char m_szGuildName[17];
	__declspec(align(4)) unsigned int m_dwTickExDeclare;
	unsigned int m_dwTick[1];
	int m_nSkill;
	tagPOINT m_ptTarget;
	int m_nOriginalDir;
	int m_nNPC;
	int m_nCID;
};
#pragma pack(pop)

/* 2429 */
#pragma pack(push, 1)
class __declspec(align(8)) CMonsterSiegeGunBall : CMonsterReal
{
	unsigned int m_dwTick[2];
	CGenMonster* m_pGen;
};
#pragma pack(pop)

/* 2430 */
#pragma pack(push, 1)
class __declspec(align(8)) CMonsterSiegeGunRuins : CMonsterReal
{
	unsigned int m_dwTick[2];
	CGenMonster* m_pGen;
};
#pragma pack(pop)

/* 2431 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 2432 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2433 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2434 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> > : std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 2435 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2436 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2437 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 2438 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, CGuild*> >
{
};
#pragma pack(pop)

/* 2439 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGuild*> > : std::_Allocator_base<std::pair<int const, CGuild*> >
{
};
#pragma pack(pop)

/* 2440 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >
{
	std::allocator<std::pair<int const, CGuild*> > _Alval;
};
#pragma pack(pop)

/* 2441 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::_Node* _Right;
	std::pair<int const, CGuild*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 2442 */
#pragma pack(push, 1)
class std::pair<int const, CGuild*>
{
	const int first;
	CGuild* second;
};
#pragma pack(pop)

/* 2443 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 2444 */
#pragma pack(push, 1)
class std::map<int, CGuild*> : std::_Tree<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >
{
};
#pragma pack(pop)

/* 2445 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CGuild*>, int, std::pair<int const, CGuild*> const*, std::pair<int const, CGuild*> const&>
{
};
#pragma pack(pop)

/* 2446 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, CGuild*>, int, std::pair<int const, CGuild*> const*, std::pair<int const, CGuild*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CGuild*>, int, std::pair<int const, CGuild*> const*, std::pair<int const, CGuild*> const&>
{
};
#pragma pack(pop)

/* 2447 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, CGuild*>, int, std::pair<int const, CGuild*> const*, std::pair<int const, CGuild*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 2448 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 2449 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, stMember*>, int, std::pair<int const, stMember*> const*, std::pair<int const, stMember*> const&>
{
};
#pragma pack(pop)

/* 2450 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, stMember*>, int, std::pair<int const, stMember*> const*, std::pair<int const, stMember*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, stMember*>, int, std::pair<int const, stMember*> const*, std::pair<int const, stMember*> const&>
{
};
#pragma pack(pop)

/* 2451 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, stMember*>, int, std::pair<int const, stMember*> const*, std::pair<int const, stMember*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 2452 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 2453 */
#pragma pack(push, 1)
class CInitNPC : CBase
{
	int m_nKind;
	int m_nMoveType;
};
#pragma pack(pop)

/* 2454 */
#pragma pack(push, 1)
class /*VFT*/ CInitNPC_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
};
#pragma pack(pop)

/* 2455 */
#pragma pack(push, 1)
class /*VFT*/ CGenNPC_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
};
#pragma pack(pop)

/* 2456 */
#pragma pack(push, 1)
class CNPC : CChar
{
	CInitNPC* m_pInit;
	CGenNPC* m_pGen;
	int m_nIndex;
	int m_nShape;
	int m_nHtml;
	unsigned int m_dwQuestKey;
	int m_nCID;
	int m_nWarRelation;
};
#pragma pack(pop)

/* 2457 */
#pragma pack(push, 1)
class /*VFT*/ CNPC_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	int* (__thiscall* CanReply)(CNPC* this, tagPOINT*);
	void(__thiscall* Reply)(CNPC* this, CPlayer*);
	void(__thiscall* SendItemList)(CNPC* this, CPlayer*);
	void(__thiscall* AI)(CNPC* this);
	void(__thiscall* Tick)(CNPC* this);
	void(__thiscall* InitScenario)(CNPC* this);
	void(__thiscall* Process)(CNPC* this, CPlayer*, char*, char*);
	void(__thiscall* SiegeGunSet)(CNPC* this, CPlayer*, int, int);
	void(__thiscall* SiegeGunUnSet)(CNPC* this, CPlayer*, int);
};
#pragma pack(pop)

/* 2458 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_List_nod<CNPC*>::_Node>
{
};
#pragma pack(pop)

/* 2459 */
#pragma pack(push, 1)
class std::allocator<std::_List_nod<CNPC*>::_Node> : std::_Allocator_base<std::_List_nod<CNPC*>::_Node>
{
};
#pragma pack(pop)

/* 2460 */
#pragma pack(push, 1)
class std::_List_nod<CNPC*>
{
	std::allocator<std::_List_nod<CNPC*>::_Node> _Alnod;
};
#pragma pack(pop)

/* 2461 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_List_nod<CNPC*>::_Node*>
{
};
#pragma pack(pop)

/* 2462 */
#pragma pack(push, 1)
class std::allocator<std::_List_nod<CNPC*>::_Node*> : std::_Allocator_base<std::_List_nod<CNPC*>::_Node*>
{
};
#pragma pack(pop)

/* 2463 */
#pragma pack(push, 1)
class std::_List_ptr<CNPC*> : std::_List_nod<CNPC*>
{
	std::allocator<std::_List_nod<CNPC*>::_Node*> _Alptr;
};
#pragma pack(pop)

/* 2464 */
#pragma pack(push, 1)
class std::_Allocator_base<CNPC*>
{
};
#pragma pack(pop)

/* 2465 */
#pragma pack(push, 1)
class std::allocator<CNPC*> : std::_Allocator_base<CNPC*>
{
};
#pragma pack(pop)

/* 2466 */
#pragma pack(push, 1)
class std::_List_val<CNPC*> : std::_List_ptr<CNPC*>
{
	std::allocator<CNPC*> _Alval;
};
#pragma pack(pop)

/* 2467 */
#pragma pack(push, 1)
class std::_List_nod<CNPC*>::_Node
{
	std::_List_nod<CNPC*>::_Node* _Next;
	std::_List_nod<CNPC*>::_Node* _Prev;
	CNPC* _Myval;
};
#pragma pack(pop)

/* 2468 */
#pragma pack(push, 1)
class std::list<CNPC*> : std::_List_val<CNPC*>
{
	__declspec(align(2)) std::_List_nod<CNPC*>::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 2469 */
#pragma pack(push, 1)
class __declspec(align(8)) CNPCTeleport : CNPC
{
	int m_nTelCount;
	int* m_nTelMap;
	tagPOINT* m_ptPTel;
};
#pragma pack(pop)

/* 2470 */
#pragma pack(push, 1)
class /*VFT*/ CNPCTeleport_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	_BYTE gapBC[8];
	void(__thiscall* SendItemList)(CNPC* this, CPlayer*);
	void(__thiscall* AI)(CNPC* this);
	void(__thiscall* Tick)(CNPC* this);
	void(__thiscall* InitScenario)(CNPC* this);
	void(__thiscall* Process)(CNPC* this, CPlayer*, char*, char*);
	void(__thiscall* SiegeGunSet)(CNPC* this, CPlayer*, int, int);
	void(__thiscall* SiegeGunUnSet)(CNPC* this, CPlayer*, int);
};
#pragma pack(pop)

/* 2471 */
#pragma pack(push, 1)
class CNPCMerchant : CNPC
{
};
#pragma pack(pop)

/* 2472 */
#pragma pack(push, 1)
class /*VFT*/ CNPCMerchant_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	_BYTE gapBC[8];
	void(__thiscall* SendItemList)(CNPC* this, CPlayer*);
	void(__thiscall* AI)(CNPC* this);
	void(__thiscall* Tick)(CNPC* this);
	void(__thiscall* InitScenario)(CNPC* this);
	void(__thiscall* Process)(CNPC* this, CPlayer*, char*, char*);
	void(__thiscall* SiegeGunSet)(CNPC* this, CPlayer*, int, int);
	void(__thiscall* SiegeGunUnSet)(CNPC* this, CPlayer*, int);
};
#pragma pack(pop)

/* 2473 */
#pragma pack(push, 1)
class CNPCInformant : CNPC
{
};
#pragma pack(pop)

/* 2474 */
#pragma pack(push, 1)
class /*VFT*/ CNPCInformant_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	_BYTE gapBC[8];
	void(__thiscall* SendItemList)(CNPC* this, CPlayer*);
	void(__thiscall* AI)(CNPC* this);
	void(__thiscall* Tick)(CNPC* this);
	void(__thiscall* InitScenario)(CNPC* this);
	void(__thiscall* Process)(CNPC* this, CPlayer*, char*, char*);
	void(__thiscall* SiegeGunSet)(CNPC* this, CPlayer*, int, int);
	void(__thiscall* SiegeGunUnSet)(CNPC* this, CPlayer*, int);
};
#pragma pack(pop)

/* 2475 */
#pragma pack(push, 1)
class CNPCGuard : CNPC
{
};
#pragma pack(pop)

/* 2476 */
#pragma pack(push, 1)
class /*VFT*/ CNPCGuard_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	_BYTE gapBC[8];
	void(__thiscall* SendItemList)(CNPC* this, CPlayer*);
	void(__thiscall* AI)(CNPC* this);
	void(__thiscall* Tick)(CNPC* this);
	void(__thiscall* InitScenario)(CNPC* this);
	void(__thiscall* Process)(CNPC* this, CPlayer*, char*, char*);
	void(__thiscall* SiegeGunSet)(CNPC* this, CPlayer*, int, int);
	void(__thiscall* SiegeGunUnSet)(CNPC* this, CPlayer*, int);
};
#pragma pack(pop)

/* 2477 */
#pragma pack(push, 1)
class CNPCQuest : CNPC
{
};
#pragma pack(pop)

/* 2478 */
#pragma pack(push, 1)
class /*VFT*/ CNPCQuest_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	_BYTE gapBC[8];
	void(__thiscall* SendItemList)(CNPC* this, CPlayer*);
	void(__thiscall* AI)(CNPC* this);
	void(__thiscall* Tick)(CNPC* this);
	void(__thiscall* InitScenario)(CNPC* this);
	void(__thiscall* Process)(CNPC* this, CPlayer*, char*, char*);
	void(__thiscall* SiegeGunSet)(CNPC* this, CPlayer*, int, int);
	void(__thiscall* SiegeGunUnSet)(CNPC* this, CPlayer*, int);
};
#pragma pack(pop)

/* 2479 */
#pragma pack(push, 1)
class __declspec(align(8)) CNPCScenario : CNPC
{
	int m_nMirror;
	int m_nItemIndex;
	unsigned int m_dwTick;
};
#pragma pack(pop)

/* 2480 */
#pragma pack(push, 1)
class /*VFT*/ CNPCScenario_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	_BYTE gapBC[8];
	void(__thiscall* SendItemList)(CNPC* this, CPlayer*);
	void(__thiscall* AI)(CNPC* this);
	void(__thiscall* Tick)(CNPC* this);
	void(__thiscall* InitScenario)(CNPC* this);
	void(__thiscall* Process)(CNPC* this, CPlayer*, char*, char*);
	void(__thiscall* SiegeGunSet)(CNPC* this, CPlayer*, int, int);
	void(__thiscall* SiegeGunUnSet)(CNPC* this, CPlayer*, int);
};
#pragma pack(pop)

/* 2481 */
#pragma pack(push, 1)
class __declspec(align(8)) CNPCDoor : CNPC
{
	int m_nItemIndex;
	int m_nOpenPeriod;
	unsigned int m_dwTick;
};
#pragma pack(pop)

/* 2482 */
#pragma pack(push, 1)
class /*VFT*/ CNPCDoor_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	_BYTE gapBC[8];
	void(__thiscall* SendItemList)(CNPC* this, CPlayer*);
	void(__thiscall* AI)(CNPC* this);
	void(__thiscall* Tick)(CNPC* this);
	void(__thiscall* InitScenario)(CNPC* this);
	void(__thiscall* Process)(CNPC* this, CPlayer*, char*, char*);
	void(__thiscall* SiegeGunSet)(CNPC* this, CPlayer*, int, int);
	void(__thiscall* SiegeGunUnSet)(CNPC* this, CPlayer*, int);
};
#pragma pack(pop)

/* 2483 */
#pragma pack(push, 1)
class __declspec(align(8)) CNPCSiegeGunStone : CNPC
{
	int m_nItemIndex;
	int m_nOpenPeriod;
	tagPOINT m_ptSGXY;
	tagPOINT m_ptSGDir;
	unsigned int m_dwTick;
	int m_nOperator;
	int m_nSiegeGun;
	int m_nStandard;
	int m_nSiegegunIndex;
};
#pragma pack(pop)

/* 2484 */
#pragma pack(push, 1)
class CNPCSiegeGunStone_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	int CanReply;
	int Reply;
	void(__thiscall* SendItemList)(CNPC* this, CPlayer*);
	void(__thiscall* AI)(CNPC* this);
	void(__thiscall* Tick)(CNPC* this);
	void(__thiscall* InitScenario)(CNPC* this);
	void(__thiscall* Process)(CNPC* this, CPlayer*, char*, char*);
	void(__thiscall* SiegeGunSet)(CNPC* this, CPlayer*, int, int);
	void(__thiscall* SiegeGunUnSet)(CNPC* this, CPlayer*, int);
	void(__thiscall* Show)(CNPCSiegeGunStone* this, int);
};
#pragma pack(pop)

/* 2485 */
#pragma pack(push, 1)
class CNPCReturnPoint : CNPC
{
};
#pragma pack(pop)

/* 2486 */
#pragma pack(push, 1)
class /*VFT*/ CNPCReturnPoint_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	_BYTE gapBC[8];
	void(__thiscall* SendItemList)(CNPC* this, CPlayer*);
	void(__thiscall* AI)(CNPC* this);
	void(__thiscall* Tick)(CNPC* this);
	void(__thiscall* InitScenario)(CNPC* this);
	void(__thiscall* Process)(CNPC* this, CPlayer*, char*, char*);
	void(__thiscall* SiegeGunSet)(CNPC* this, CPlayer*, int, int);
	void(__thiscall* SiegeGunUnSet)(CNPC* this, CPlayer*, int);
};
#pragma pack(pop)

/* 2487 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGuild*> >::rebind<std::pair<int const, CGuild*> >
{
};
#pragma pack(pop)

/* 2488 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGuild*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2489 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGuild*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2490 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGuild*> >::rebind<int>
{
};
#pragma pack(pop)

/* 2491 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGuild*> >::rebind<char>
{
};
#pragma pack(pop)

/* 2492 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 2493 */
#pragma pack(push, 1)
class std::pair<std::_Tree<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::iterator, std::_Tree<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::iterator>
{
	std::_Tree<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::iterator first;
	std::_Tree<std::_Tmap_traits<int, CGuild*, std::less<int>, std::allocator<std::pair<int const, CGuild*> >, 0> >::iterator second;
};
#pragma pack(pop)

/* 2494 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, stMember*> >::rebind<std::pair<int const, stMember*> >
{
};
#pragma pack(pop)

/* 2495 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, stMember*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2496 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, stMember*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2497 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, stMember*> >::rebind<int>
{
};
#pragma pack(pop)

/* 2498 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, stMember*> >::rebind<char>
{
};
#pragma pack(pop)

/* 2499 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, stMember*, std::less<int>, std::allocator<std::pair<int const, stMember*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 2500 */
#pragma pack(push, 1)
class CWar : CBase
{
	CWar* m_pNextWar;
	int m_nAID;
	int m_nGID;
	char m_szGuildName[17];
	char m_szLeaderName[17];
	__declspec(align(4)) CGuild* m_pGuild;
};
#pragma pack(pop)

/* 2501 */
#pragma pack(push, 1)
class /*VFT*/ CWar_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
};
#pragma pack(pop)

/* 2502 */
#pragma pack(push, 1)
class std::_Vector_val<CMonster*>
{
	std::allocator<CMonster*> _Alval;
};
#pragma pack(pop)

/* 2503 */
#pragma pack(push, 1)
class std::vector<CMonster*> : std::_Vector_val<CMonster*>
{
	__declspec(align(4)) CMonster** _Myfirst;
	CMonster** _Mylast;
	CMonster** _Myend;
};
#pragma pack(pop)

/* 2504 */
#pragma pack(push, 1)
class CCastle : CBase
{
	int m_nGID;
	int m_nTax;
	int m_nTaxRate;
	int m_nGateLimit;
	CGuild* m_pGuild;
	CWar* m_pWarHead;
	CGuild* m_pCurStandardGuild;
	int m_nCurStandardGID;
	int m_bCurStandardUnfurl;
	int m_nCID;
	int m_nExtendedCnt;
	int m_nWarEnd;
	int m_bCurLordDeclare;
	int m_nLordDeclareEnd;
	std::vector<CMonster*> m_cGateVec;
};
#pragma pack(pop)

/* 2505 */
#pragma pack(push, 1)
class /*VFT*/ CCastle_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
};
#pragma pack(pop)

/* 2506 */
#pragma pack(push, 1)
class CStatus
{
};
#pragma pack(pop)

/* 2507 */
#pragma pack(push, 1)
class /*VFT*/ CIOServer_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CIOSocket* (__thiscall* CreateSocket)(CIOServer* this, unsigned int, sockaddr_in*);
};
#pragma pack(pop)

/* 2508 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 2509 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2510 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2511 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> > : std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 2512 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2513 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2514 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 2515 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, CSocket*> >
{
};
#pragma pack(pop)

/* 2516 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CSocket*> > : std::_Allocator_base<std::pair<int const, CSocket*> >
{
};
#pragma pack(pop)

/* 2517 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >
{
	std::allocator<std::pair<int const, CSocket*> > _Alval;
};
#pragma pack(pop)

/* 2518 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::_Node* _Right;
	std::pair<int const, CSocket*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 2519 */
#pragma pack(push, 1)
class std::pair<int const, CSocket*>
{
	const int first;
	CSocket* second;
};
#pragma pack(pop)

/* 2520 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 2521 */
#pragma pack(push, 1)
class std::map<int, CSocket*> : std::_Tree<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >
{
};
#pragma pack(pop)

/* 2522 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CSocket*>, int, std::pair<int const, CSocket*> const*, std::pair<int const, CSocket*> const&>
{
};
#pragma pack(pop)

/* 2523 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, CSocket*>, int, std::pair<int const, CSocket*> const*, std::pair<int const, CSocket*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CSocket*>, int, std::pair<int const, CSocket*> const*, std::pair<int const, CSocket*> const&>
{
};
#pragma pack(pop)

/* 2524 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, CSocket*>, int, std::pair<int const, CSocket*> const*, std::pair<int const, CSocket*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 2525 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 2526 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CSocket*> >::rebind<std::pair<int const, CSocket*> >
{
};
#pragma pack(pop)

/* 2527 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CSocket*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2528 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CSocket*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2529 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CSocket*> >::rebind<int>
{
};
#pragma pack(pop)

/* 2530 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CSocket*> >::rebind<char>
{
};
#pragma pack(pop)

/* 2531 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 2532 */
#pragma pack(push, 1)
class std::pair<std::_Tree<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::iterator, std::_Tree<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::iterator>
{
	std::_Tree<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::iterator first;
	std::_Tree<std::_Tmap_traits<int, CSocket*, std::less<int>, std::allocator<std::pair<int const, CSocket*> >, 0> >::iterator second;
};
#pragma pack(pop)

/* 2533 */
#pragma pack(push, 1)
class /*VFT*/ CServer_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CIOSocket* (__thiscall* CreateSocket)(CIOServer* this, unsigned int, sockaddr_in*);
};
#pragma pack(pop)

/* 2534 */
#pragma pack(push, 1)
class std::allocator<QUESTITEMDROP>::rebind<QUESTITEMDROP>
{
};
#pragma pack(pop)

/* 2535 */
#pragma pack(push, 1)
class std::allocator<MSKILL>::rebind<MSKILL>
{
};
#pragma pack(pop)

/* 2536 */
#pragma pack(push, 1)
class _HSCRYPT_KEYINFO
{
	unsigned __int8 byInitKey[16];
	unsigned __int8 AesEncKey[550];
	unsigned __int8 AesDecKey[550];
};
#pragma pack(pop)

/* 2537 */
#pragma pack(push, 1)
class __unaligned __declspec(align(1)) PACKET
{
	unsigned __int16 wSize;
	unsigned __int8 byType;
	char data[];
};
#pragma pack(pop)

/* 2538 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, CCastle*> >
{
};
#pragma pack(pop)

/* 2539 */
#pragma pack(push, 1)
class std::pair<int const, CCastle*>
{
	const int first;
	CCastle* second;
};
#pragma pack(pop)

/* 2540 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CCastle*> > : std::_Allocator_base<std::pair<int const, CCastle*> >
{
};
#pragma pack(pop)

/* 2541 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CCastle*> >::rebind<std::pair<int const, CCastle*> >
{
};
#pragma pack(pop)

/* 2542 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CCastle*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2543 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CCastle*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2544 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CCastle*> >::rebind<int>
{
};
#pragma pack(pop)

/* 2545 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CCastle*> >::rebind<char>
{
};
#pragma pack(pop)

/* 2546 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2547 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >::_Node* _Right;
	std::pair<int const, CCastle*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 2548 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2549 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 2550 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2551 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2552 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> > : std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 2553 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 2554 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >
{
	std::allocator<std::pair<int const, CCastle*> > _Alval;
};
#pragma pack(pop)

/* 2555 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 2556 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CCastle*>, int, std::pair<int const, CCastle*> const*, std::pair<int const, CCastle*> const&>
{
};
#pragma pack(pop)

/* 2557 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, CCastle*>, int, std::pair<int const, CCastle*> const*, std::pair<int const, CCastle*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CCastle*>, int, std::pair<int const, CCastle*> const*, std::pair<int const, CCastle*> const&>
{
};
#pragma pack(pop)

/* 2558 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, CCastle*>, int, std::pair<int const, CCastle*> const*, std::pair<int const, CCastle*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 2559 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 2560 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 2561 */
#pragma pack(push, 1)
class std::map<int, CCastle*> : std::_Tree<std::_Tmap_traits<int, CCastle*, std::less<int>, std::allocator<std::pair<int const, CCastle*> >, 0> >
{
};
#pragma pack(pop)

/* 2562 */
#pragma pack(push, 1)
class std::allocator<CMonster*>::rebind<CMonster*>
{
};
#pragma pack(pop)

/* 2563 */
#pragma pack(push, 1)
class std::iterator<std::random_access_iterator_tag, CMonster*, int, CMonster* const*, CMonster* const&>
{
};
#pragma pack(pop)

/* 2564 */
#pragma pack(push, 1)
class std::_Ranit<CMonster*, int, CMonster* const*, CMonster* const&> : std::iterator<std::random_access_iterator_tag, CMonster*, int, CMonster* const*, CMonster* const&>
{
};
#pragma pack(pop)

/* 2565 */
#pragma pack(push, 1)
class std::vector<CMonster*>::const_iterator : std::_Ranit<CMonster*, int, CMonster* const*, CMonster* const&>
{
	CMonster** _Myptr;
};
#pragma pack(pop)

/* 2566 */
#pragma pack(push, 1)
class std::vector<CMonster*>::iterator : std::vector<CMonster*>::const_iterator
{
};
#pragma pack(pop)

/* 2567 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 2568 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2569 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2570 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> > : std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 2571 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2572 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2573 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 2574 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, CAlliance*> >
{
};
#pragma pack(pop)

/* 2575 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CAlliance*> > : std::_Allocator_base<std::pair<int const, CAlliance*> >
{
};
#pragma pack(pop)

/* 2576 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >
{
	std::allocator<std::pair<int const, CAlliance*> > _Alval;
};
#pragma pack(pop)

/* 2577 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >::_Node* _Right;
	std::pair<int const, CAlliance*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 2578 */
#pragma pack(push, 1)
class std::pair<int const, CAlliance*>
{
	const int first;
	CAlliance* second;
};
#pragma pack(pop)

/* 2579 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 2580 */
#pragma pack(push, 1)
class std::map<int, CAlliance*> : std::_Tree<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >
{
};
#pragma pack(pop)

/* 2581 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CAlliance*>, int, std::pair<int const, CAlliance*> const*, std::pair<int const, CAlliance*> const&>
{
};
#pragma pack(pop)

/* 2582 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, CAlliance*>, int, std::pair<int const, CAlliance*> const*, std::pair<int const, CAlliance*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CAlliance*>, int, std::pair<int const, CAlliance*> const*, std::pair<int const, CAlliance*> const&>
{
};
#pragma pack(pop)

/* 2583 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, CAlliance*>, int, std::pair<int const, CAlliance*> const*, std::pair<int const, CAlliance*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 2584 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 2585 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CAlliance*> >::rebind<std::pair<int const, CAlliance*> >
{
};
#pragma pack(pop)

/* 2586 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CAlliance*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2587 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CAlliance*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2588 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CAlliance*> >::rebind<int>
{
};
#pragma pack(pop)

/* 2589 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CAlliance*> >::rebind<char>
{
};
#pragma pack(pop)

/* 2590 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, CAlliance*, std::less<int>, std::allocator<std::pair<int const, CAlliance*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 2591 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 2592 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2593 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2594 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> > : std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 2595 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2596 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2597 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 2598 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, CSMap*> >
{
};
#pragma pack(pop)

/* 2599 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CSMap*> > : std::_Allocator_base<std::pair<int const, CSMap*> >
{
};
#pragma pack(pop)

/* 2600 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >
{
	std::allocator<std::pair<int const, CSMap*> > _Alval;
};
#pragma pack(pop)

/* 2601 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >::_Node* _Right;
	std::pair<int const, CSMap*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 2602 */
#pragma pack(push, 1)
class std::pair<int const, CSMap*>
{
	const int first;
	CSMap* second;
};
#pragma pack(pop)

/* 2603 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 2604 */
#pragma pack(push, 1)
class std::map<int, CSMap*> : std::_Tree<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >
{
};
#pragma pack(pop)

/* 2605 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CSMap*>, int, std::pair<int const, CSMap*> const*, std::pair<int const, CSMap*> const&>
{
};
#pragma pack(pop)

/* 2606 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, CSMap*>, int, std::pair<int const, CSMap*> const*, std::pair<int const, CSMap*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CSMap*>, int, std::pair<int const, CSMap*> const*, std::pair<int const, CSMap*> const&>
{
};
#pragma pack(pop)

/* 2607 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, CSMap*>, int, std::pair<int const, CSMap*> const*, std::pair<int const, CSMap*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 2608 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 2609 */
#pragma pack(push, 1)
class CMapObject : CIOObject
{
	int m_nMap;
	int m_nCurState;
	int m_nNextState;
	CIOCriticalSection m_lock;
};
#pragma pack(pop)

/* 2610 */
#pragma pack(push, 1)
class /*VFT*/ CMapObject_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
};
#pragma pack(pop)

/* 2611 */
#pragma pack(push, 1)
class __declspec(align(4)) CInitMap : CBase
{
	int m_nIndex;
	int m_nKind;
	int m_nX;
	int m_nY;
	char m_szPath[129];
};
#pragma pack(pop)

/* 2612 */
#pragma pack(push, 1)
class /*VFT*/ CInitMap_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
};
#pragma pack(pop)

/* 2613 */
#pragma pack(push, 1)
class std::iterator<std::random_access_iterator_tag, CPlayer*, int, CPlayer* const*, CPlayer* const&>
{
};
#pragma pack(pop)

/* 2614 */
#pragma pack(push, 1)
class std::_Ranit<CPlayer*, int, CPlayer* const*, CPlayer* const&> : std::iterator<std::random_access_iterator_tag, CPlayer*, int, CPlayer* const*, CPlayer* const&>
{
};
#pragma pack(pop)

/* 2615 */
#pragma pack(push, 1)
class std::vector<CPlayer*>::const_iterator : std::_Ranit<CPlayer*, int, CPlayer* const*, CPlayer* const&>
{
	CPlayer** _Myptr;
};
#pragma pack(pop)

/* 2616 */
#pragma pack(push, 1)
class std::vector<CPlayer*>::iterator : std::vector<CPlayer*>::const_iterator
{
};
#pragma pack(pop)

/* 2617 */
#pragma pack(push, 1)
class std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0>
{
	StrCmp comp;
};
#pragma pack(pop)

/* 2618 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2619 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2620 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> > : std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 2621 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2622 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2623 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> > : std::_Tree_nod<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 2624 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<char const* const, GOTO> >
{
};
#pragma pack(pop)

/* 2625 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, GOTO> > : std::_Allocator_base<std::pair<char const* const, GOTO> >
{
};
#pragma pack(pop)

/* 2626 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >
{
	std::allocator<std::pair<char const* const, GOTO> > _Alval;
};
#pragma pack(pop)

/* 2627 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >::_Node* _Right;
	std::pair<char const* const, GOTO> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 2628 */
#pragma pack(push, 1)
class GOTO
{
	int nMap;
	tagPOINT pt;
	int nZ;
};
#pragma pack(pop)

/* 2629 */
#pragma pack(push, 1)
class std::pair<char const* const, GOTO>
{
	const char* const first;
	GOTO second;
};
#pragma pack(pop)

/* 2630 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> > : std::_Tree_val<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 2631 */
#pragma pack(push, 1)
class std::map<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> > > : std::_Tree<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >
{
};
#pragma pack(pop)

/* 2632 */
#pragma pack(push, 1)
class CGoto : CBase
{
	const char* m_szName;
	GOTO m_goto;
};
#pragma pack(pop)

/* 2633 */
#pragma pack(push, 1)
class /*VFT*/ CGoto_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
};
#pragma pack(pop)

/* 2634 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<char const* const, GOTO>, int, std::pair<char const* const, GOTO> const*, std::pair<char const* const, GOTO> const&>
{
};
#pragma pack(pop)

/* 2635 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<char const* const, GOTO>, int, std::pair<char const* const, GOTO> const*, std::pair<char const* const, GOTO> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<char const* const, GOTO>, int, std::pair<char const* const, GOTO> const*, std::pair<char const* const, GOTO> const&>
{
};
#pragma pack(pop)

/* 2636 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >::const_iterator : std::_Bidit<std::pair<char const* const, GOTO>, int, std::pair<char const* const, GOTO> const*, std::pair<char const* const, GOTO> const&>
{
	std::_Tree_nod<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 2637 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 2638 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, GOTO> >::rebind<std::pair<char const* const, GOTO> >
{
};
#pragma pack(pop)

/* 2639 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, GOTO> >::rebind<std::_Tree_nod<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2640 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, GOTO> >::rebind<std::_Tree_nod<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2641 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, GOTO> >::rebind<char const*>
{
};
#pragma pack(pop)

/* 2642 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, GOTO> >::rebind<char>
{
};
#pragma pack(pop)

/* 2643 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<char const*, GOTO, StrCmp, std::allocator<std::pair<char const* const, GOTO> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 2644 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_List_nod<PORTAL>::_Node>
{
};
#pragma pack(pop)

/* 2645 */
#pragma pack(push, 1)
class std::allocator<std::_List_nod<PORTAL>::_Node> : std::_Allocator_base<std::_List_nod<PORTAL>::_Node>
{
};
#pragma pack(pop)

/* 2646 */
#pragma pack(push, 1)
class std::_List_nod<PORTAL>
{
	std::allocator<std::_List_nod<PORTAL>::_Node> _Alnod;
};
#pragma pack(pop)

/* 2647 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_List_nod<PORTAL>::_Node*>
{
};
#pragma pack(pop)

/* 2648 */
#pragma pack(push, 1)
class std::allocator<std::_List_nod<PORTAL>::_Node*> : std::_Allocator_base<std::_List_nod<PORTAL>::_Node*>
{
};
#pragma pack(pop)

/* 2649 */
#pragma pack(push, 1)
class std::_List_ptr<PORTAL> : std::_List_nod<PORTAL>
{
	std::allocator<std::_List_nod<PORTAL>::_Node*> _Alptr;
};
#pragma pack(pop)

/* 2650 */
#pragma pack(push, 1)
class std::_Allocator_base<PORTAL>
{
};
#pragma pack(pop)

/* 2651 */
#pragma pack(push, 1)
class std::allocator<PORTAL> : std::_Allocator_base<PORTAL>
{
};
#pragma pack(pop)

/* 2652 */
#pragma pack(push, 1)
class std::_List_val<PORTAL> : std::_List_ptr<PORTAL>
{
	std::allocator<PORTAL> _Alval;
};
#pragma pack(pop)

/* 2653 */
#pragma pack(push, 1)
class std::_List_nod<PORTAL>::_Node
{
	std::_List_nod<PORTAL>::_Node* _Next;
	std::_List_nod<PORTAL>::_Node* _Prev;
	PORTAL _Myval;
};
#pragma pack(pop)

/* 2654 */
#pragma pack(push, 1)
class PORTAL
{
	int nFromMap;
	tagRECT rtFrom;
	int nToMap;
	tagPOINT ptPTo;
	int nToZ;
};
#pragma pack(pop)

/* 2655 */
#pragma pack(push, 1)
class std::list<PORTAL> : std::_List_val<PORTAL>
{
	__declspec(align(2)) std::_List_nod<PORTAL>::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 2656 */
#pragma pack(push, 1)
class CPortal : CBase
{
	PORTAL m_portal;
	unsigned int m_dwCountry;
};
#pragma pack(pop)

/* 2657 */
#pragma pack(push, 1)
class /*VFT*/ CPortal_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
};
#pragma pack(pop)

/* 2658 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, PORTAL, int, PORTAL const*, PORTAL const&>
{
};
#pragma pack(pop)

/* 2659 */
#pragma pack(push, 1)
class std::_Bidit<PORTAL, int, PORTAL const*, PORTAL const&> : std::iterator<std::bidirectional_iterator_tag, PORTAL, int, PORTAL const*, PORTAL const&>
{
};
#pragma pack(pop)

/* 2660 */
#pragma pack(push, 1)
class std::list<PORTAL>::const_iterator : std::_Bidit<PORTAL, int, PORTAL const*, PORTAL const&>
{
	std::_List_nod<PORTAL>::_Node* _Ptr;
};
#pragma pack(pop)

/* 2661 */
#pragma pack(push, 1)
class std::list<PORTAL>::iterator : std::list<PORTAL>::const_iterator
{
};
#pragma pack(pop)

/* 2662 */
#pragma pack(push, 1)
class std::allocator<PORTAL>::rebind<std::_List_nod<PORTAL>::_Node>
{
};
#pragma pack(pop)

/* 2663 */
#pragma pack(push, 1)
class std::allocator<PORTAL>::rebind<std::_List_nod<PORTAL>::_Node*>
{
};
#pragma pack(pop)

/* 2664 */
#pragma pack(push, 1)
class std::allocator<PORTAL>::rebind<PORTAL>
{
};
#pragma pack(pop)

/* 2665 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CSMap*> >::rebind<std::pair<int const, CSMap*> >
{
};
#pragma pack(pop)

/* 2666 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CSMap*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2667 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CSMap*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CSMap*, std::less<int>, std::allocator<std::pair<int const, CSMap*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2668 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CSMap*> >::rebind<int>
{
};
#pragma pack(pop)

/* 2669 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CSMap*> >::rebind<char>
{
};
#pragma pack(pop)

/* 2670 */
#pragma pack(push, 1)
class std::allocator<CPlayer*>::rebind<CPlayer*>
{
};
#pragma pack(pop)

/* 2671 */
#pragma pack(push, 1)
class /*VFT*/ CBuffMoveSpeed_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2672 */
#pragma pack(push, 1)
class CBuffMoveSpeed : CBuff
{
	int m_nCount;
};
#pragma pack(pop)

/* 2673 */
#pragma pack(push, 1)
class /*VFT*/ CBuffStone_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2674 */
#pragma pack(push, 1)
class CBuffStone : CBuff
{
	int m_nValue2;
};
#pragma pack(pop)

/* 2675 */
#pragma pack(push, 1)
class /*VFT*/ CBuffMeditation_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2676 */
#pragma pack(push, 1)
class CBuffMeditation : CBuff
{
	unsigned int m_dwTickNext;
};
#pragma pack(pop)

/* 2677 */
#pragma pack(push, 1)
class /*VFT*/ CBuffFatalChance_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2678 */
#pragma pack(push, 1)
class CBuffFatalChance : CBuff
{
	int m_nValue2;
};
#pragma pack(pop)

/* 2679 */
#pragma pack(push, 1)
class /*VFT*/ CBuffRevivalSequela_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2680 */
#pragma pack(push, 1)
class CBuffRevivalSequela : CBuff
{
};
#pragma pack(pop)

/* 2681 */
#pragma pack(push, 1)
class /*VFT*/ CBuffStun_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2682 */
#pragma pack(push, 1)
class CBuffStun : CBuff
{
	int m_nCount;
};
#pragma pack(pop)

/* 2683 */
#pragma pack(push, 1)
class /*VFT*/ CBuffMoveStop_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2684 */
#pragma pack(push, 1)
class CBuffMoveStop : CBuff
{
	int m_nCount;
};
#pragma pack(pop)

/* 2685 */
#pragma pack(push, 1)
class /*VFT*/ CBuffPoison_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2686 */
#pragma pack(push, 1)
class CBuffPoison : CBuff
{
	int m_nCount;
	unsigned int m_dwTickNext;
};
#pragma pack(pop)

/* 2687 */
#pragma pack(push, 1)
class /*VFT*/ CBuffPoisonCloud_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2688 */
#pragma pack(push, 1)
class CBuffPoisonCloud : CBuff
{
	int m_nCount;
	unsigned int m_dwTickNext;
};
#pragma pack(pop)

/* 2689 */
#pragma pack(push, 1)
class /*VFT*/ CBuffHaste_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2690 */
#pragma pack(push, 1)
class CBuffHaste : CBuff
{
};
#pragma pack(pop)

/* 2691 */
#pragma pack(push, 1)
class /*VFT*/ CBuffHP_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2692 */
#pragma pack(push, 1)
class CBuffHP : CBuff
{
};
#pragma pack(pop)

/* 2693 */
#pragma pack(push, 1)
class /*VFT*/ CBuffMP_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2694 */
#pragma pack(push, 1)
class CBuffMP : CBuff
{
};
#pragma pack(pop)

/* 2695 */
#pragma pack(push, 1)
class /*VFT*/ CBuffSleep_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2696 */
#pragma pack(push, 1)
class CBuffSleep : CBuff
{
	int m_nCount;
};
#pragma pack(pop)

/* 2697 */
#pragma pack(push, 1)
class /*VFT*/ CBuffCTDefensePer_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2698 */
#pragma pack(push, 1)
class CBuffCTDefensePer : CBuff
{
	int m_nValue2;
};
#pragma pack(pop)

/* 2699 */
#pragma pack(push, 1)
class /*VFT*/ CBuffCTHealing_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2700 */
#pragma pack(push, 1)
class CBuffCTHealing : CBuff
{
	unsigned int m_dwTickNext;
};
#pragma pack(pop)

/* 2701 */
#pragma pack(push, 1)
class /*VFT*/ CBuffCTPrtyPtEx_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2702 */
#pragma pack(push, 1)
class CBuffCTPrtyPtEx : CBuff
{
	int m_nValue2;
	int m_nCharPrty;
	int m_nMStateEx;
};
#pragma pack(pop)

/* 2703 */
#pragma pack(push, 1)
class /*VFT*/ CBuffSuffering_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2704 */
#pragma pack(push, 1)
class CBuffSuffering : CBuff
{
	int m_nCount;
};
#pragma pack(pop)

/* 2705 */
#pragma pack(push, 1)
class /*VFT*/ CBuffInchantWeapon_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2706 */
#pragma pack(push, 1)
class CBuffInchantWeapon : CBuff
{
};
#pragma pack(pop)

/* 2707 */
#pragma pack(push, 1)
class /*VFT*/ CBuffSpiritDmg_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2708 */
#pragma pack(push, 1)
class CBuffSpiritDmg : CBuff
{
	int m_nCount;
};
#pragma pack(pop)

/* 2709 */
#pragma pack(push, 1)
class /*VFT*/ CBuffFlagPrty_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2710 */
#pragma pack(push, 1)
class CBuffFlagPrty : CBuff
{
	int m_nUpType;
	int m_nValue2;
	int m_nCharPrty;
	__declspec(align(8)) __int64 m_nMState;
};
#pragma pack(pop)

/* 2711 */
#pragma pack(push, 1)
class /*VFT*/ CBuffFlagHP_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2712 */
#pragma pack(push, 1)
class CBuffFlagHP : CBuff
{
};
#pragma pack(pop)

/* 2713 */
#pragma pack(push, 1)
class /*VFT*/ CBuffBerserk_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2714 */
#pragma pack(push, 1)
class CBuffBerserk : CBuff
{
	int m_nValue2;
};
#pragma pack(pop)

/* 2715 */
#pragma pack(push, 1)
class /*VFT*/ CBuffSilenceShot_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2716 */
#pragma pack(push, 1)
class CBuffSilenceShot : CBuff
{
	int m_nCount;
};
#pragma pack(pop)

/* 2717 */
#pragma pack(push, 1)
class /*VFT*/ CBuffManaBurn_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2718 */
#pragma pack(push, 1)
class CBuffManaBurn : CBuff
{
	int m_nCount;
};
#pragma pack(pop)

/* 2719 */
#pragma pack(push, 1)
class /*VFT*/ CBuffPrty_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2720 */
#pragma pack(push, 1)
class CBuffPrty : CBuff
{
	int m_nCount;
	int m_nUpType;
	int m_nValue2;
	int m_nCharPrty;
	__int64 m_nMState;
};
#pragma pack(pop)

/* 2721 */
#pragma pack(push, 1)
class /*VFT*/ CBuffPrtyEx_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2722 */
#pragma pack(push, 1)
class CBuffPrtyEx : CBuff
{
	int m_nCount;
	int m_nUpType;
	int m_nValue2;
	int m_nCharPrty;
	int m_nMStateEx;
};
#pragma pack(pop)

/* 2723 */
#pragma pack(push, 1)
class /*VFT*/ CBuffExpire_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2724 */
#pragma pack(push, 1)
class CBuffExpire : CBuff
{
	__int64 m_nBState;
};
#pragma pack(pop)

/* 2725 */
#pragma pack(push, 1)
class /*VFT*/ CBuffExpireEvent_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2726 */
#pragma pack(push, 1)
class CBuffExpireEvent : CBuffExpire
{
};
#pragma pack(pop)

/* 2727 */
#pragma pack(push, 1)
class /*VFT*/ CBuffExpireLuckyStone2_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2728 */
#pragma pack(push, 1)
class CBuffExpireLuckyStone2 : CBuffExpire
{
};
#pragma pack(pop)

/* 2729 */
#pragma pack(push, 1)
class /*VFT*/ CBuffRemain_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2730 */
#pragma pack(push, 1)
union $B8B621EF1BDA066BC3C4F73570BA6C4A
{
	int m_nEState;
	int m_nGState;
	__int64 m_nBState;
};
#pragma pack(pop)

/* 2731 */
#pragma pack(push, 1)
class CBuffRemain : CBuff
{
	$B8B621EF1BDA066BC3C4F73570BA6C4A ___u1;
};
#pragma pack(pop)

/* 2732 */
#pragma pack(push, 1)
class /*VFT*/ CBuffRemainEx_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2733 */
#pragma pack(push, 1)
class CBuffRemainEx : CBuffRemain
{
};
#pragma pack(pop)

/* 2734 */
#pragma pack(push, 1)
class /*VFT*/ CBuffRemainDead_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2735 */
#pragma pack(push, 1)
class CBuffRemainDead : CBuffRemain
{
};
#pragma pack(pop)

/* 2736 */
#pragma pack(push, 1)
class /*VFT*/ CBuffRemainDeadEx_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2737 */
#pragma pack(push, 1)
class CBuffRemainDeadEx : CBuffRemainDead
{
};
#pragma pack(pop)

/* 2738 */
#pragma pack(push, 1)
class /*VFT*/ CBuffRemainXBlow_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2739 */
#pragma pack(push, 1)
class CBuffRemainXBlow : CBuffRemain
{
};
#pragma pack(pop)

/* 2740 */
#pragma pack(push, 1)
class /*VFT*/ CBuffRemainPrty_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2741 */
#pragma pack(push, 1)
class __declspec(align(8)) CBuffRemainPrty : CBuffRemain
{
	int m_nCharPrty;
};
#pragma pack(pop)

/* 2742 */
#pragma pack(push, 1)
class /*VFT*/ CBuffRemainCount_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2743 */
#pragma pack(push, 1)
class CBuffRemainCount : CBuffRemain
{
};
#pragma pack(pop)

/* 2744 */
#pragma pack(push, 1)
class /*VFT*/ CBuffRemainLuckyStone1_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2745 */
#pragma pack(push, 1)
class CBuffRemainLuckyStone1 : CBuffRemain
{
};
#pragma pack(pop)

/* 2746 */
#pragma pack(push, 1)
class /*VFT*/ CBuffRemainPet_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2747 */
#pragma pack(push, 1)
class __declspec(align(8)) CBuffRemainPet : CBuffRemain
{
	int m_nPetType;
};
#pragma pack(pop)

/* 2748 */
#pragma pack(push, 1)
class /*VFT*/ CBuffHydrochloricAcid_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2749 */
#pragma pack(push, 1)
class CBuffHydrochloricAcid : CBuff
{
	int m_nCount;
	unsigned int m_dwNext;
};
#pragma pack(pop)

/* 2750 */
#pragma pack(push, 1)
class /*VFT*/ CBuffMixDamage_vtbl
{
	int(__thiscall* SetBuff)(CBuff* this, CChar*);
	int(__thiscall* ApplyBuff)(CBuff* this, CChar*);
	void(__thiscall* FreeBuff)(CBuff* this, CChar*);
	int(__thiscall* UpdateBuff)(CBuff* this, CBuff*, CChar*);
	int(__thiscall* IsExpired)(CBuff* this, CChar*);
	CBuff* (__thiscall* Copy)(CBuff* this);
	void(__thiscall* SaveRemain)(CBuff* this, CChar*);
};
#pragma pack(pop)

/* 2751 */
#pragma pack(push, 1)
class CBuffMixDamage : CBuff
{
	int m_nCount;
	int m_nDamage;
	unsigned int m_dwNext;
	unsigned int m_dwTerm;
};
#pragma pack(pop)

/* 2752 */
#pragma pack(push, 1)
class /*VFT*/ CHhatchingInsect_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 2753 */
#pragma pack(push, 1)
class CHhatchingInsect : CSkill
{
};
#pragma pack(pop)

/* 2754 */
#pragma pack(push, 1)
class /*VFT*/ CSeparation_vtbl
{
	int(__thiscall* CanExcute)(CSkill* this, CPlayer*, CChar*);
	void(__thiscall* Excute)(CSkill* this, CPlayer*, char*, char*);
	void(__thiscall* ExcutePassive)(CSkill* this, CPlayer*, int, int);
	void(__thiscall* ExcutePassiveV)(CSkill* this, CPlayer*, char*);
	int(__thiscall* GetAttack)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetMagic)(CSkill* this, CPlayer*, int);
	int(__thiscall* GetHostility)(CSkill* this);
	int(__thiscall* GetFatalRate)(CSkill* this);
	int(__thiscall* GetSpendMP)(CSkill* this, CPlayer*);
	unsigned int(__thiscall* GetDelay)(CSkill* this, CPlayer*);
	int(__thiscall* CanContiSkill)(CSkill* this, CPlayer*, CChar*);
	int(__thiscall* CanSkillUp)(CSkill* this, CPlayer*);
	int(__thiscall* Redistribute)(CSkill* this, CPlayer*);
	int(__thiscall* IsPhysical)(CSkill* this);
	void(__thiscall* SpendMPRage)(CSkill* this, CPlayer*);
	int(__thiscall* CanLearn)(CSkill* this, int, unsigned int);
	int(__thiscall* PreExcute)(CSkill* this, CPlayer*, int);
	void(__thiscall* PreExcuteM)(CSkill* this, CMonster*);
	void(__thiscall* ExcuteM)(CSkill* this, CMonster*, CChar*);
	int(__thiscall* CanExcuteM)(CSkill* this, CMonster*, CChar*);
};
#pragma pack(pop)

/* 2755 */
#pragma pack(push, 1)
class CSeparation : CSkill
{
};
#pragma pack(pop)

/* 2756 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 2757 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2758 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2759 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> > : std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 2760 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2761 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2762 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 2763 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, CQuest*> >
{
};
#pragma pack(pop)

/* 2764 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CQuest*> > : std::_Allocator_base<std::pair<int const, CQuest*> >
{
};
#pragma pack(pop)

/* 2765 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >
{
	std::allocator<std::pair<int const, CQuest*> > _Alval;
};
#pragma pack(pop)

/* 2766 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >::_Node* _Right;
	std::pair<int const, CQuest*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 2807 */
#pragma pack(push, 1)
class std::pair<int const, CQuest*>
{
	const int first;
	CQuest* second;
};
#pragma pack(pop)

/* 2806 */
#pragma pack(push, 1)
class /*VFT*/ CQuest_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
};
#pragma pack(pop)

/* 2808 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 2809 */
#pragma pack(push, 1)
class std::map<int, CQuest*> : std::_Tree<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >
{
};
#pragma pack(pop)

/* 2810 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CQuest*>, int, std::pair<int const, CQuest*> const*, std::pair<int const, CQuest*> const&>
{
};
#pragma pack(pop)

/* 2811 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, CQuest*>, int, std::pair<int const, CQuest*> const*, std::pair<int const, CQuest*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CQuest*>, int, std::pair<int const, CQuest*> const*, std::pair<int const, CQuest*> const&>
{
};
#pragma pack(pop)

/* 2812 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, CQuest*>, int, std::pair<int const, CQuest*> const*, std::pair<int const, CQuest*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 2813 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 2814 */
#pragma pack(push, 1)
class QUESTITEM
{
	int nIndex;
	int nPrefix;
	int nNum;
	int bInsert;
};
#pragma pack(pop)

/* 2815 */
#pragma pack(push, 1)
class std::_Allocator_base<QUESTITEM>
{
};
#pragma pack(pop)

/* 2816 */
#pragma pack(push, 1)
class std::allocator<QUESTITEM> : std::_Allocator_base<QUESTITEM>
{
};
#pragma pack(pop)

/* 2817 */
#pragma pack(push, 1)
class std::_Vector_val<QUESTITEM>
{
	std::allocator<QUESTITEM> _Alval;
};
#pragma pack(pop)

/* 2818 */
#pragma pack(push, 1)
class std::vector<QUESTITEM> : std::_Vector_val<QUESTITEM>
{
	__declspec(align(4)) QUESTITEM* _Myfirst;
	QUESTITEM* _Mylast;
	QUESTITEM* _Myend;
};
#pragma pack(pop)

/* 2819 */
#pragma pack(push, 1)
class std::iterator<std::random_access_iterator_tag, QUESTITEM, int, QUESTITEM const*, QUESTITEM const&>
{
};
#pragma pack(pop)

/* 2820 */
#pragma pack(push, 1)
class std::_Ranit<QUESTITEM, int, QUESTITEM const*, QUESTITEM const&> : std::iterator<std::random_access_iterator_tag, QUESTITEM, int, QUESTITEM const*, QUESTITEM const&>
{
};
#pragma pack(pop)

/* 2821 */
#pragma pack(push, 1)
class std::vector<QUESTITEM>::const_iterator : std::_Ranit<QUESTITEM, int, QUESTITEM const*, QUESTITEM const&>
{
	QUESTITEM* _Myptr;
};
#pragma pack(pop)

/* 2822 */
#pragma pack(push, 1)
class std::vector<QUESTITEM>::iterator : std::vector<QUESTITEM>::const_iterator
{
};
#pragma pack(pop)

/* 2823 */
#pragma pack(push, 1)
class CCondClass : CCondition
{
};
#pragma pack(pop)

/* 2824 */
#pragma pack(push, 1)
class /*VFT*/ CCondClass_vtbl
{
	void(__thiscall * ~CCondition)(CCondition* this);
	int(__thiscall* IsMeet)(CCondition* this, CPlayer*);
};
#pragma pack(pop)

/* 2825 */
#pragma pack(push, 1)
class CCondLevel : CCondition
{
};
#pragma pack(pop)

/* 2826 */
#pragma pack(push, 1)
class /*VFT*/ CCondLevel_vtbl
{
	void(__thiscall * ~CCondition)(CCondition* this);
	int(__thiscall* IsMeet)(CCondition* this, CPlayer*);
};
#pragma pack(pop)

/* 2827 */
#pragma pack(push, 1)
class CCondSpecialty : CCondition
{
};
#pragma pack(pop)

/* 2828 */
#pragma pack(push, 1)
class /*VFT*/ CCondSpecialty_vtbl
{
	void(__thiscall * ~CCondition)(CCondition* this);
	int(__thiscall* IsMeet)(CCondition* this, CPlayer*);
};
#pragma pack(pop)

/* 2829 */
#pragma pack(push, 1)
class CCondContribute : CCondition
{
};
#pragma pack(pop)

/* 2830 */
#pragma pack(push, 1)
class /*VFT*/ CCondContribute_vtbl
{
	void(__thiscall * ~CCondition)(CCondition* this);
	int(__thiscall* IsMeet)(CCondition* this, CPlayer*);
};
#pragma pack(pop)

/* 2831 */
#pragma pack(push, 1)
class CCondItem : CCondition
{
	std::vector<QUESTITEM> m_vecQItem;
};
#pragma pack(pop)

/* 2832 */
#pragma pack(push, 1)
class /*VFT*/ CCondItem_vtbl
{
	void(__thiscall * ~CCondition)(CCondition* this);
	int(__thiscall* IsMeet)(CCondition* this, CPlayer*);
};
#pragma pack(pop)

/* 2833 */
#pragma pack(push, 1)
class CCondParty : CCondition
{
};
#pragma pack(pop)

/* 2834 */
#pragma pack(push, 1)
class /*VFT*/ CCondParty_vtbl
{
	void(__thiscall * ~CCondition)(CCondition* this);
	int(__thiscall* IsMeet)(CCondition* this, CPlayer*);
};
#pragma pack(pop)

/* 2835 */
#pragma pack(push, 1)
class CCondQuest : CCondition
{
};
#pragma pack(pop)

/* 2836 */
#pragma pack(push, 1)
class /*VFT*/ CCondQuest_vtbl
{
	void(__thiscall * ~CCondition)(CCondition* this);
	int(__thiscall* IsMeet)(CCondition* this, CPlayer*);
};
#pragma pack(pop)

/* 2837 */
#pragma pack(push, 1)
class CCondClear : CCondition
{
};
#pragma pack(pop)

/* 2838 */
#pragma pack(push, 1)
class /*VFT*/ CCondClear_vtbl
{
	void(__thiscall * ~CCondition)(CCondition* this);
	int(__thiscall* IsMeet)(CCondition* this, CPlayer*);
};
#pragma pack(pop)

/* 2839 */
#pragma pack(push, 1)
class CCondNotClear : CCondition
{
};
#pragma pack(pop)

/* 2840 */
#pragma pack(push, 1)
class /*VFT*/ CCondNotClear_vtbl
{
	void(__thiscall * ~CCondition)(CCondition* this);
	int(__thiscall* IsMeet)(CCondition* this, CPlayer*);
};
#pragma pack(pop)

/* 2841 */
#pragma pack(push, 1)
class CCondGState : CCondition
{
};
#pragma pack(pop)

/* 2842 */
#pragma pack(push, 1)
class /*VFT*/ CCondGState_vtbl
{
	void(__thiscall * ~CCondition)(CCondition* this);
	int(__thiscall* IsMeet)(CCondition* this, CPlayer*);
};
#pragma pack(pop)

/* 2843 */
#pragma pack(push, 1)
class CActionHtml : CAction
{
};
#pragma pack(pop)

/* 2844 */
#pragma pack(push, 1)
class /*VFT*/ CActionHtml_vtbl
{
	void(__thiscall * ~CAction)(CAction* this);
	void(__thiscall* Action)(CAction* this, CPlayer*);
};
#pragma pack(pop)

/* 2845 */
#pragma pack(push, 1)
class CActionLink : CAction
{
};
#pragma pack(pop)

/* 2846 */
#pragma pack(push, 1)
class /*VFT*/ CActionLink_vtbl
{
	void(__thiscall * ~CAction)(CAction* this);
	void(__thiscall* Action)(CAction* this, CPlayer*);
};
#pragma pack(pop)

/* 2847 */
#pragma pack(push, 1)
class CActionSpecialty : CAction
{
};
#pragma pack(pop)

/* 2848 */
#pragma pack(push, 1)
class /*VFT*/ CActionSpecialty_vtbl
{
	void(__thiscall * ~CAction)(CAction* this);
	void(__thiscall* Action)(CAction* this, CPlayer*);
};
#pragma pack(pop)

/* 2849 */
#pragma pack(push, 1)
class CActionExp : CAction
{
};
#pragma pack(pop)

/* 2850 */
#pragma pack(push, 1)
class /*VFT*/ CActionExp_vtbl
{
	void(__thiscall * ~CAction)(CAction* this);
	void(__thiscall* Action)(CAction* this, CPlayer*);
};
#pragma pack(pop)

/* 2851 */
#pragma pack(push, 1)
class CActionItem : CAction
{
	std::vector<QUESTITEM> m_vecQItem;
};
#pragma pack(pop)

/* 2852 */
#pragma pack(push, 1)
class /*VFT*/ CActionItem_vtbl
{
	void(__thiscall * ~CAction)(CAction* this);
	void(__thiscall* Action)(CAction* this, CPlayer*);
};
#pragma pack(pop)

/* 2853 */
#pragma pack(push, 1)
class CActionItemRand : CAction
{
};
#pragma pack(pop)

/* 2854 */
#pragma pack(push, 1)
class /*VFT*/ CActionItemRand_vtbl
{
	void(__thiscall * ~CAction)(CAction* this);
	void(__thiscall* Action)(CAction* this, CPlayer*);
};
#pragma pack(pop)

/* 2855 */
#pragma pack(push, 1)
class CActionCon : CAction
{
};
#pragma pack(pop)

/* 2856 */
#pragma pack(push, 1)
class /*VFT*/ CActionCon_vtbl
{
	void(__thiscall * ~CAction)(CAction* this);
	void(__thiscall* Action)(CAction* this, CPlayer*);
};
#pragma pack(pop)

/* 2857 */
#pragma pack(push, 1)
class CActionSUP : CAction
{
};
#pragma pack(pop)

/* 2858 */
#pragma pack(push, 1)
class /*VFT*/ CActionSUP_vtbl
{
	void(__thiscall * ~CAction)(CAction* this);
	void(__thiscall* Action)(CAction* this, CPlayer*);
};
#pragma pack(pop)

/* 2859 */
#pragma pack(push, 1)
class CActionSaveFlag : CAction
{
};
#pragma pack(pop)

/* 2860 */
#pragma pack(push, 1)
class /*VFT*/ CActionSaveFlag_vtbl
{
	void(__thiscall * ~CAction)(CAction* this);
	void(__thiscall* Action)(CAction* this, CPlayer*);
};
#pragma pack(pop)

/* 2861 */
#pragma pack(push, 1)
class CActionClear : CAction
{
};
#pragma pack(pop)

/* 2862 */
#pragma pack(push, 1)
class /*VFT*/ CActionClear_vtbl
{
	void(__thiscall * ~CAction)(CAction* this);
	void(__thiscall* Action)(CAction* this, CPlayer*);
};
#pragma pack(pop)

/* 2863 */
#pragma pack(push, 1)
class CActionGState : CAction
{
};
#pragma pack(pop)

/* 2864 */
#pragma pack(push, 1)
class /*VFT*/ CActionGState_vtbl
{
	void(__thiscall * ~CAction)(CAction* this);
	void(__thiscall* Action)(CAction* this, CPlayer*);
};
#pragma pack(pop)

/* 2865 */
#pragma pack(push, 1)
class CActionGuide : CAction
{
};
#pragma pack(pop)

/* 2866 */
#pragma pack(push, 1)
class /*VFT*/ CActionGuide_vtbl
{
	void(__thiscall * ~CAction)(CAction* this);
	void(__thiscall* Action)(CAction* this, CPlayer*);
};
#pragma pack(pop)

/* 2867 */
#pragma pack(push, 1)
class CActionRedistribute : CAction
{
};
#pragma pack(pop)

/* 2868 */
#pragma pack(push, 1)
class /*VFT*/ CActionRedistribute_vtbl
{
	void(__thiscall * ~CAction)(CAction* this);
	void(__thiscall* Action)(CAction* this, CPlayer*);
};
#pragma pack(pop)

/* 2869 */
#pragma pack(push, 1)
class CActionTeleport : CAction
{
	int m_nTelMap;
	int m_nTelX;
	int m_nTelY;
};
#pragma pack(pop)

/* 2870 */
#pragma pack(push, 1)
class /*VFT*/ CActionTeleport_vtbl
{
	void(__thiscall * ~CAction)(CAction* this);
	void(__thiscall* Action)(CAction* this, CPlayer*);
};
#pragma pack(pop)

/* 2871 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, CCondition*, int, CCondition* const*, CCondition* const&>
{
};
#pragma pack(pop)

/* 2872 */
#pragma pack(push, 1)
class std::_Bidit<CCondition*, int, CCondition* const*, CCondition* const&> : std::iterator<std::bidirectional_iterator_tag, CCondition*, int, CCondition* const*, CCondition* const&>
{
};
#pragma pack(pop)

/* 2873 */
#pragma pack(push, 1)
class std::list<CCondition*>::const_iterator : std::_Bidit<CCondition*, int, CCondition* const*, CCondition* const&>
{
	std::_List_nod<CCondition*>::_Node* _Ptr;
};
#pragma pack(pop)

/* 2874 */
#pragma pack(push, 1)
class std::list<CCondition*>::iterator : std::list<CCondition*>::const_iterator
{
};
#pragma pack(pop)

/* 2875 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, CAction*, int, CAction* const*, CAction* const&>
{
};
#pragma pack(pop)

/* 2876 */
#pragma pack(push, 1)
class std::_Bidit<CAction*, int, CAction* const*, CAction* const&> : std::iterator<std::bidirectional_iterator_tag, CAction*, int, CAction* const*, CAction* const&>
{
};
#pragma pack(pop)

/* 2877 */
#pragma pack(push, 1)
class std::list<CAction*>::const_iterator : std::_Bidit<CAction*, int, CAction* const*, CAction* const&>
{
	std::_List_nod<CAction*>::_Node* _Ptr;
};
#pragma pack(pop)

/* 2878 */
#pragma pack(push, 1)
class std::list<CAction*>::iterator : std::list<CAction*>::const_iterator
{
};
#pragma pack(pop)

/* 2879 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, CCase*, int, CCase* const*, CCase* const&>
{
};
#pragma pack(pop)

/* 2880 */
#pragma pack(push, 1)
class std::_Bidit<CCase*, int, CCase* const*, CCase* const&> : std::iterator<std::bidirectional_iterator_tag, CCase*, int, CCase* const*, CCase* const&>
{
};
#pragma pack(pop)

/* 2881 */
#pragma pack(push, 1)
class std::list<CCase*>::const_iterator : std::_Bidit<CCase*, int, CCase* const*, CCase* const&>
{
	std::_List_nod<CCase*>::_Node* _Ptr;
};
#pragma pack(pop)

/* 2882 */
#pragma pack(push, 1)
class std::list<CCase*>::iterator : std::list<CCase*>::const_iterator
{
};
#pragma pack(pop)

/* 2883 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 2884 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CQuest*> >::rebind<std::pair<int const, CQuest*> >
{
};
#pragma pack(pop)

/* 2885 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CQuest*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2886 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CQuest*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CQuest*, std::less<int>, std::allocator<std::pair<int const, CQuest*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2887 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CQuest*> >::rebind<int>
{
};
#pragma pack(pop)

/* 2888 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CQuest*> >::rebind<char>
{
};
#pragma pack(pop)

/* 2889 */
#pragma pack(push, 1)
class CObjectDB : CConfig
{
	const char* m_pszFileName;
};
#pragma pack(pop)

/* 2890 */
#pragma pack(push, 1)
class std::allocator<QUESTITEM>::rebind<QUESTITEM>
{
};
#pragma pack(pop)

/* 2891 */
#pragma pack(push, 1)
class std::allocator<CCondition*>::rebind<std::_List_nod<CCondition*>::_Node>
{
};
#pragma pack(pop)

/* 2892 */
#pragma pack(push, 1)
class std::allocator<CCondition*>::rebind<std::_List_nod<CCondition*>::_Node*>
{
};
#pragma pack(pop)

/* 2893 */
#pragma pack(push, 1)
class std::allocator<CCondition*>::rebind<CCondition*>
{
};
#pragma pack(pop)

/* 2894 */
#pragma pack(push, 1)
class std::allocator<CAction*>::rebind<std::_List_nod<CAction*>::_Node>
{
};
#pragma pack(pop)

/* 2895 */
#pragma pack(push, 1)
class std::allocator<CAction*>::rebind<std::_List_nod<CAction*>::_Node*>
{
};
#pragma pack(pop)

/* 2896 */
#pragma pack(push, 1)
class std::allocator<CAction*>::rebind<CAction*>
{
};
#pragma pack(pop)

/* 2897 */
#pragma pack(push, 1)
class std::allocator<CCase*>::rebind<std::_List_nod<CCase*>::_Node>
{
};
#pragma pack(pop)

/* 2898 */
#pragma pack(push, 1)
class std::allocator<CCase*>::rebind<std::_List_nod<CCase*>::_Node*>
{
};
#pragma pack(pop)

/* 2899 */
#pragma pack(push, 1)
class std::allocator<CCase*>::rebind<CCase*>
{
};
#pragma pack(pop)

/* 2900 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_List_nod<PKBULLETININFO>::_Node>
{
};
#pragma pack(pop)

/* 2901 */
#pragma pack(push, 1)
class std::allocator<std::_List_nod<PKBULLETININFO>::_Node> : std::_Allocator_base<std::_List_nod<PKBULLETININFO>::_Node>
{
};
#pragma pack(pop)

/* 2902 */
#pragma pack(push, 1)
class std::_List_nod<PKBULLETININFO>
{
	std::allocator<std::_List_nod<PKBULLETININFO>::_Node> _Alnod;
};
#pragma pack(pop)

/* 2903 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_List_nod<PKBULLETININFO>::_Node*>
{
};
#pragma pack(pop)

/* 2904 */
#pragma pack(push, 1)
class std::allocator<std::_List_nod<PKBULLETININFO>::_Node*> : std::_Allocator_base<std::_List_nod<PKBULLETININFO>::_Node*>
{
};
#pragma pack(pop)

/* 2905 */
#pragma pack(push, 1)
class std::_List_ptr<PKBULLETININFO> : std::_List_nod<PKBULLETININFO>
{
	std::allocator<std::_List_nod<PKBULLETININFO>::_Node*> _Alptr;
};
#pragma pack(pop)

/* 2906 */
#pragma pack(push, 1)
class std::_Allocator_base<PKBULLETININFO>
{
};
#pragma pack(pop)

/* 2907 */
#pragma pack(push, 1)
class std::allocator<PKBULLETININFO> : std::_Allocator_base<PKBULLETININFO>
{
};
#pragma pack(pop)

/* 2908 */
#pragma pack(push, 1)
class std::_List_val<PKBULLETININFO> : std::_List_ptr<PKBULLETININFO>
{
	std::allocator<PKBULLETININFO> _Alval;
};
#pragma pack(pop)

/* 2909 */
#pragma pack(push, 1)
class __declspec(align(2)) std::_List_nod<PKBULLETININFO>::_Node
{
	std::_List_nod<PKBULLETININFO>::_Node* _Next;
	std::_List_nod<PKBULLETININFO>::_Node* _Prev;
	PKBULLETININFO _Myval;
};
#pragma pack(pop)

/* 2910 */
#pragma pack(push, 1)
class std::list<PKBULLETININFO> : std::_List_val<PKBULLETININFO>
{
	__declspec(align(2)) std::_List_nod<PKBULLETININFO>::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 2911 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, PKBULLETININFO, int, PKBULLETININFO const*, PKBULLETININFO const&>
{
};
#pragma pack(pop)

/* 2912 */
#pragma pack(push, 1)
class std::_Bidit<PKBULLETININFO, int, PKBULLETININFO const*, PKBULLETININFO const&> : std::iterator<std::bidirectional_iterator_tag, PKBULLETININFO, int, PKBULLETININFO const*, PKBULLETININFO const&>
{
};
#pragma pack(pop)

/* 2913 */
#pragma pack(push, 1)
class std::list<PKBULLETININFO>::const_iterator : std::_Bidit<PKBULLETININFO, int, PKBULLETININFO const*, PKBULLETININFO const&>
{
	std::_List_nod<PKBULLETININFO>::_Node* _Ptr;
};
#pragma pack(pop)

/* 2914 */
#pragma pack(push, 1)
class std::list<PKBULLETININFO>::iterator : std::list<PKBULLETININFO>::const_iterator
{
};
#pragma pack(pop)

/* 2915 */
#pragma pack(push, 1)
class CPlayerObject : CIOObject
{
};
#pragma pack(pop)

/* 2916 */
#pragma pack(push, 1)
class /*VFT*/ CPlayerObject_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
};
#pragma pack(pop)

/* 2917 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, CNPC*, int, CNPC* const*, CNPC* const&>
{
};
#pragma pack(pop)

/* 2918 */
#pragma pack(push, 1)
class std::_Bidit<CNPC*, int, CNPC* const*, CNPC* const&> : std::iterator<std::bidirectional_iterator_tag, CNPC*, int, CNPC* const*, CNPC* const&>
{
};
#pragma pack(pop)

/* 2919 */
#pragma pack(push, 1)
class std::list<CNPC*>::const_iterator : std::_Bidit<CNPC*, int, CNPC* const*, CNPC* const&>
{
	std::_List_nod<CNPC*>::_Node* _Ptr;
};
#pragma pack(pop)

/* 2920 */
#pragma pack(push, 1)
class std::list<CNPC*>::iterator : std::list<CNPC*>::const_iterator
{
};
#pragma pack(pop)

/* 2921 */
#pragma pack(push, 1)
class CCalendar : CIOObject
{
};
#pragma pack(pop)

/* 2922 */
#pragma pack(push, 1)
class /*VFT*/ CCalendar_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
};
#pragma pack(pop)

/* 2923 */
#pragma pack(push, 1)
class std::allocator<CNPC*>::rebind<std::_List_nod<CNPC*>::_Node>
{
};
#pragma pack(pop)

/* 2924 */
#pragma pack(push, 1)
class std::allocator<CNPC*>::rebind<std::_List_nod<CNPC*>::_Node*>
{
};
#pragma pack(pop)

/* 2925 */
#pragma pack(push, 1)
class std::allocator<CNPC*>::rebind<CNPC*>
{
};
#pragma pack(pop)

/* 2926 */
#pragma pack(push, 1)
class std::allocator<PKBULLETININFO>::rebind<std::_List_nod<PKBULLETININFO>::_Node>
{
};
#pragma pack(pop)

/* 2927 */
#pragma pack(push, 1)
class std::allocator<PKBULLETININFO>::rebind<std::_List_nod<PKBULLETININFO>::_Node*>
{
};
#pragma pack(pop)

/* 2928 */
#pragma pack(push, 1)
class std::allocator<PKBULLETININFO>::rebind<PKBULLETININFO>
{
};
#pragma pack(pop)

/* 2929 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 2930 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2931 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2932 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> > : std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 2933 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2934 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2935 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 2936 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, CParty*> >
{
};
#pragma pack(pop)

/* 2937 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CParty*> > : std::_Allocator_base<std::pair<int const, CParty*> >
{
};
#pragma pack(pop)

/* 2938 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >
{
	std::allocator<std::pair<int const, CParty*> > _Alval;
};
#pragma pack(pop)

/* 2939 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::_Node* _Right;
	std::pair<int const, CParty*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 2940 */
#pragma pack(push, 1)
class std::pair<int const, CParty*>
{
	const int first;
	CParty* second;
};
#pragma pack(pop)

/* 2941 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 2942 */
#pragma pack(push, 1)
class std::map<int, CParty*> : std::_Tree<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >
{
};
#pragma pack(pop)

/* 2943 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CParty*>, int, std::pair<int const, CParty*> const*, std::pair<int const, CParty*> const&>
{
};
#pragma pack(pop)

/* 2944 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, CParty*>, int, std::pair<int const, CParty*> const*, std::pair<int const, CParty*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CParty*>, int, std::pair<int const, CParty*> const*, std::pair<int const, CParty*> const&>
{
};
#pragma pack(pop)

/* 2945 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, CParty*>, int, std::pair<int const, CParty*> const*, std::pair<int const, CParty*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 2946 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 2947 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 2948 */
#pragma pack(push, 1)
class std::pair<std::_Tree<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::iterator, std::_Tree<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::iterator>
{
	std::_Tree<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::iterator first;
	std::_Tree<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::iterator second;
};
#pragma pack(pop)

/* 2949 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CParty*> >::rebind<std::pair<int const, CParty*> >
{
};
#pragma pack(pop)

/* 2950 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CParty*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2951 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CParty*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CParty*, std::less<int>, std::allocator<std::pair<int const, CParty*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2952 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CParty*> >::rebind<int>
{
};
#pragma pack(pop)

/* 2953 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CParty*> >::rebind<char>
{
};
#pragma pack(pop)

/* 2954 */
#pragma pack(push, 1)
class std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0>
{
	iless comp;
};
#pragma pack(pop)

/* 2955 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2956 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2957 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> > : std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 2958 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2959 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2960 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 2961 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<char const* const, CBase*> >
{
};
#pragma pack(pop)

/* 2962 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, CBase*> > : std::_Allocator_base<std::pair<char const* const, CBase*> >
{
};
#pragma pack(pop)

/* 2963 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >
{
	std::allocator<std::pair<char const* const, CBase*> > _Alval;
};
#pragma pack(pop)

/* 2964 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >::_Node* _Right;
	std::pair<char const* const, CBase*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 2965 */
#pragma pack(push, 1)
class std::pair<char const* const, CBase*>
{
	const char* const first;
	CBase* second;
};
#pragma pack(pop)

/* 2966 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> > : std::_Tree_val<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 2967 */
#pragma pack(push, 1)
class std::map<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> > > : std::_Tree<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >
{
};
#pragma pack(pop)

/* 2968 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<char const* const, CBase*>, int, std::pair<char const* const, CBase*> const*, std::pair<char const* const, CBase*> const&>
{
};
#pragma pack(pop)

/* 2969 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<char const* const, CBase*>, int, std::pair<char const* const, CBase*> const*, std::pair<char const* const, CBase*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<char const* const, CBase*>, int, std::pair<char const* const, CBase*> const*, std::pair<char const* const, CBase*> const&>
{
};
#pragma pack(pop)

/* 2970 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >::const_iterator : std::_Bidit<std::pair<char const* const, CBase*>, int, std::pair<char const* const, CBase*> const*, std::pair<char const* const, CBase*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 2971 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 2972 */
#pragma pack(push, 1)
class std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0>
{
	iless comp;
};
#pragma pack(pop)

/* 2973 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2974 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2975 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> > : std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 2976 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2977 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2978 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> > : std::_Tree_nod<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 2979 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<char const* const, enum Symbol> >
{
};
#pragma pack(pop)

/* 2980 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, enum Symbol> > : std::_Allocator_base<std::pair<char const* const, enum Symbol> >
{
};
#pragma pack(pop)

/* 2981 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >
{
	std::allocator<std::pair<char const* const, enum Symbol> > _Alval;
};
#pragma pack(pop)

/* 2982 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >::_Node* _Right;
	std::pair<char const* const, enum Symbol> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 2983 */
#pragma pack(push, 1)
class std::pair<char const* const, enum Symbol>
{
	const char* const first;
	Symbol second;
};
#pragma pack(pop)

/* 2984 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> > : std::_Tree_val<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 2985 */
#pragma pack(push, 1)
class std::map<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> > > : std::_Tree<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >
{
};
#pragma pack(pop)

/* 2986 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<char const* const, enum Symbol>, int, std::pair<char const* const, enum Symbol> const*, std::pair<char const* const, enum Symbol> const&>
{
};
#pragma pack(pop)

/* 2987 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<char const* const, enum Symbol>, int, std::pair<char const* const, enum Symbol> const*, std::pair<char const* const, enum Symbol> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<char const* const, enum Symbol>, int, std::pair<char const* const, enum Symbol> const*, std::pair<char const* const, enum Symbol> const&>
{
};
#pragma pack(pop)

/* 2988 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >::const_iterator : std::_Bidit<std::pair<char const* const, enum Symbol>, int, std::pair<char const* const, enum Symbol> const*, std::pair<char const* const, enum Symbol> const&>
{
	std::_Tree_nod<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 2989 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 2990 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 2991 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2992 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 2993 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> > : std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 2994 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2995 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 2996 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 2997 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, CGroup*> >
{
};
#pragma pack(pop)

/* 2998 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGroup*> > : std::_Allocator_base<std::pair<int const, CGroup*> >
{
};
#pragma pack(pop)

/* 2999 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >
{
	std::allocator<std::pair<int const, CGroup*> > _Alval;
};
#pragma pack(pop)

/* 3000 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >::_Node* _Right;
	std::pair<int const, CGroup*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 3001 */
#pragma pack(push, 1)
class std::pair<int const, CGroup*>
{
	const int first;
	CGroup* second;
};
#pragma pack(pop)

/* 3002 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 3003 */
#pragma pack(push, 1)
class std::map<int, CGroup*> : std::_Tree<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >
{
};
#pragma pack(pop)

/* 3004 */
#pragma pack(push, 1)
class std::iterator<std::random_access_iterator_tag, ITEMDROPINFO, int, ITEMDROPINFO const*, ITEMDROPINFO const&>
{
};
#pragma pack(pop)

/* 3005 */
#pragma pack(push, 1)
class std::_Ranit<ITEMDROPINFO, int, ITEMDROPINFO const*, ITEMDROPINFO const&> : std::iterator<std::random_access_iterator_tag, ITEMDROPINFO, int, ITEMDROPINFO const*, ITEMDROPINFO const&>
{
};
#pragma pack(pop)

/* 3006 */
#pragma pack(push, 1)
class std::vector<ITEMDROPINFO>::const_iterator : std::_Ranit<ITEMDROPINFO, int, ITEMDROPINFO const*, ITEMDROPINFO const&>
{
	ITEMDROPINFO* _Myptr;
};
#pragma pack(pop)

/* 3007 */
#pragma pack(push, 1)
class std::vector<ITEMDROPINFO>::iterator : std::vector<ITEMDROPINFO>::const_iterator
{
};
#pragma pack(pop)

/* 3008 */
#pragma pack(push, 1)
class std::iterator<std::random_access_iterator_tag, ITEMGROUP, int, ITEMGROUP const*, ITEMGROUP const&>
{
};
#pragma pack(pop)

/* 3009 */
#pragma pack(push, 1)
class std::_Ranit<ITEMGROUP, int, ITEMGROUP const*, ITEMGROUP const&> : std::iterator<std::random_access_iterator_tag, ITEMGROUP, int, ITEMGROUP const*, ITEMGROUP const&>
{
};
#pragma pack(pop)

/* 3010 */
#pragma pack(push, 1)
class std::vector<ITEMGROUP>::const_iterator : std::_Ranit<ITEMGROUP, int, ITEMGROUP const*, ITEMGROUP const&>
{
	ITEMGROUP* _Myptr;
};
#pragma pack(pop)

/* 3011 */
#pragma pack(push, 1)
class std::vector<ITEMGROUP>::iterator : std::vector<ITEMGROUP>::const_iterator
{
};
#pragma pack(pop)

/* 3012 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CGroup*>, int, std::pair<int const, CGroup*> const*, std::pair<int const, CGroup*> const&>
{
};
#pragma pack(pop)

/* 3013 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, CGroup*>, int, std::pair<int const, CGroup*> const*, std::pair<int const, CGroup*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CGroup*>, int, std::pair<int const, CGroup*> const*, std::pair<int const, CGroup*> const&>
{
};
#pragma pack(pop)

/* 3014 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, CGroup*>, int, std::pair<int const, CGroup*> const*, std::pair<int const, CGroup*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 3015 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 3016 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGroup*> >::rebind<std::pair<int const, CGroup*> >
{
};
#pragma pack(pop)

/* 3017 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGroup*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3018 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGroup*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3019 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGroup*> >::rebind<int>
{
};
#pragma pack(pop)

/* 3020 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGroup*> >::rebind<char>
{
};
#pragma pack(pop)

/* 3021 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, CGroup*, std::less<int>, std::allocator<std::pair<int const, CGroup*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 3022 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 3023 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3024 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3025 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> > : std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 3026 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3027 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3028 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 3029 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, CGoods*> >
{
};
#pragma pack(pop)

/* 3030 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGoods*> > : std::_Allocator_base<std::pair<int const, CGoods*> >
{
};
#pragma pack(pop)

/* 3031 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >
{
	std::allocator<std::pair<int const, CGoods*> > _Alval;
};
#pragma pack(pop)

/* 3032 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >::_Node* _Right;
	std::pair<int const, CGoods*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 3040 */
#pragma pack(push, 1)
class std::pair<int const, CGoods*>
{
	const int first;
	CGoods* second;
};
#pragma pack(pop)

/* 3033 */
#pragma pack(push, 1)
class std::_Allocator_base<ITEMDETAIL>
{
};
#pragma pack(pop)

/* 3034 */
#pragma pack(push, 1)
class std::allocator<ITEMDETAIL> : std::_Allocator_base<ITEMDETAIL>
{
};
#pragma pack(pop)

/* 3035 */
#pragma pack(push, 1)
class std::_Vector_val<ITEMDETAIL>
{
	std::allocator<ITEMDETAIL> _Alval;
};
#pragma pack(pop)

/* 3037 */
#pragma pack(push, 1)
class std::vector<ITEMDETAIL> : std::_Vector_val<ITEMDETAIL>
{
	__declspec(align(4)) ITEMDETAIL* _Myfirst;
	ITEMDETAIL* _Mylast;
	ITEMDETAIL* _Myend;
};
#pragma pack(pop)

/* 3038 */
#pragma pack(push, 1)
class CGoods : CBase
{
	int m_nIndex;
	std::vector<ITEMDETAIL> m_vecDetail;
};
#pragma pack(pop)

/* 3036 */
#pragma pack(push, 1)
class ITEMDETAIL
{
	int nCode;
	int nPrefix;
	int nNum;
};
#pragma pack(pop)

/* 3039 */
#pragma pack(push, 1)
class /*VFT*/ CGoods_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
};
#pragma pack(pop)

/* 3041 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 3042 */
#pragma pack(push, 1)
class std::map<int, CGoods*> : std::_Tree<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >
{
};
#pragma pack(pop)

/* 3043 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CGoods*>, int, std::pair<int const, CGoods*> const*, std::pair<int const, CGoods*> const&>
{
};
#pragma pack(pop)

/* 3044 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, CGoods*>, int, std::pair<int const, CGoods*> const*, std::pair<int const, CGoods*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CGoods*>, int, std::pair<int const, CGoods*> const*, std::pair<int const, CGoods*> const&>
{
};
#pragma pack(pop)

/* 3045 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, CGoods*>, int, std::pair<int const, CGoods*> const*, std::pair<int const, CGoods*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 3046 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 3047 */
#pragma pack(push, 1)
class std::iterator<std::random_access_iterator_tag, ITEMDETAIL, int, ITEMDETAIL const*, ITEMDETAIL const&>
{
};
#pragma pack(pop)

/* 3048 */
#pragma pack(push, 1)
class std::_Ranit<ITEMDETAIL, int, ITEMDETAIL const*, ITEMDETAIL const&> : std::iterator<std::random_access_iterator_tag, ITEMDETAIL, int, ITEMDETAIL const*, ITEMDETAIL const&>
{
};
#pragma pack(pop)

/* 3049 */
#pragma pack(push, 1)
class std::vector<ITEMDETAIL>::const_iterator : std::_Ranit<ITEMDETAIL, int, ITEMDETAIL const*, ITEMDETAIL const&>
{
	ITEMDETAIL* _Myptr;
};
#pragma pack(pop)

/* 3050 */
#pragma pack(push, 1)
class std::vector<ITEMDETAIL>::iterator : std::vector<ITEMDETAIL>::const_iterator
{
};
#pragma pack(pop)

/* 3051 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGoods*> >::rebind<std::pair<int const, CGoods*> >
{
};
#pragma pack(pop)

/* 3052 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGoods*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3053 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGoods*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3054 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGoods*> >::rebind<int>
{
};
#pragma pack(pop)

/* 3055 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGoods*> >::rebind<char>
{
};
#pragma pack(pop)

/* 3056 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, CGoods*, std::less<int>, std::allocator<std::pair<int const, CGoods*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 3057 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 3058 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, enum Symbol> >::rebind<std::pair<char const* const, enum Symbol> >
{
};
#pragma pack(pop)

/* 3059 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, enum Symbol> >::rebind<std::_Tree_nod<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3060 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, enum Symbol> >::rebind<std::_Tree_nod<std::_Tmap_traits<char const*, enum Symbol, iless, std::allocator<std::pair<char const* const, enum Symbol> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3061 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, enum Symbol> >::rebind<char const*>
{
};
#pragma pack(pop)

/* 3062 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, enum Symbol> >::rebind<char>
{
};
#pragma pack(pop)

/* 3063 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 3064 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, CBase*> >::rebind<std::pair<char const* const, CBase*> >
{
};
#pragma pack(pop)

/* 3065 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, CBase*> >::rebind<std::_Tree_nod<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3066 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, CBase*> >::rebind<std::_Tree_nod<std::_Tmap_traits<char const*, CBase*, iless, std::allocator<std::pair<char const* const, CBase*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3067 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, CBase*> >::rebind<char const*>
{
};
#pragma pack(pop)

/* 3068 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, CBase*> >::rebind<char>
{
};
#pragma pack(pop)

/* 3069 */
#pragma pack(push, 1)
class std::allocator<ITEMDROPINFO>::rebind<ITEMDROPINFO>
{
};
#pragma pack(pop)

/* 3070 */
#pragma pack(push, 1)
class std::allocator<ITEMGROUP>::rebind<ITEMGROUP>
{
};
#pragma pack(pop)

/* 3071 */
#pragma pack(push, 1)
class std::allocator<ITEMDETAIL>::rebind<ITEMDETAIL>
{
};
#pragma pack(pop)

/* 3072 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 3073 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3074 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3075 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> > : std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 3076 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3077 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3078 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 3079 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, CGenNPC*> >
{
};
#pragma pack(pop)

/* 3080 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGenNPC*> > : std::_Allocator_base<std::pair<int const, CGenNPC*> >
{
};
#pragma pack(pop)

/* 3081 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >
{
	std::allocator<std::pair<int const, CGenNPC*> > _Alval;
};
#pragma pack(pop)

/* 3082 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >::_Node* _Right;
	std::pair<int const, CGenNPC*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 3083 */
#pragma pack(push, 1)
class std::pair<int const, CGenNPC*>
{
	const int first;
	CGenNPC* second;
};
#pragma pack(pop)

/* 3084 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 3085 */
#pragma pack(push, 1)
class std::map<int, CGenNPC*> : std::_Tree<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >
{
};
#pragma pack(pop)

/* 3086 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CGenNPC*>, int, std::pair<int const, CGenNPC*> const*, std::pair<int const, CGenNPC*> const&>
{
};
#pragma pack(pop)

/* 3087 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, CGenNPC*>, int, std::pair<int const, CGenNPC*> const*, std::pair<int const, CGenNPC*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CGenNPC*>, int, std::pair<int const, CGenNPC*> const*, std::pair<int const, CGenNPC*> const&>
{
};
#pragma pack(pop)

/* 3088 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, CGenNPC*>, int, std::pair<int const, CGenNPC*> const*, std::pair<int const, CGenNPC*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 3089 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 3090 */
#pragma pack(push, 1)
class CNPCObject : CIOObject
{
	CIOCriticalSection m_lockLink[2];
	CLink m_link[2];
};
#pragma pack(pop)

/* 3091 */
#pragma pack(push, 1)
class /*VFT*/ CNPCObject_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
};
#pragma pack(pop)

/* 3092 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 3093 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3094 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3095 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> > : std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 3096 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3097 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3098 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 3099 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, CNPC*> >
{
};
#pragma pack(pop)

/* 3100 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CNPC*> > : std::_Allocator_base<std::pair<int const, CNPC*> >
{
};
#pragma pack(pop)

/* 3101 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >
{
	std::allocator<std::pair<int const, CNPC*> > _Alval;
};
#pragma pack(pop)

/* 3102 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::_Node* _Right;
	std::pair<int const, CNPC*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 3103 */
#pragma pack(push, 1)
class std::pair<int const, CNPC*>
{
	const int first;
	CNPC* second;
};
#pragma pack(pop)

/* 3104 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 3105 */
#pragma pack(push, 1)
class std::map<int, CNPC*> : std::_Tree<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >
{
};
#pragma pack(pop)

/* 3106 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CNPC*>, int, std::pair<int const, CNPC*> const*, std::pair<int const, CNPC*> const&>
{
};
#pragma pack(pop)

/* 3107 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, CNPC*>, int, std::pair<int const, CNPC*> const*, std::pair<int const, CNPC*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CNPC*>, int, std::pair<int const, CNPC*> const*, std::pair<int const, CNPC*> const&>
{
};
#pragma pack(pop)

/* 3108 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, CNPC*>, int, std::pair<int const, CNPC*> const*, std::pair<int const, CNPC*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 3109 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 3110 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 3111 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3112 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3113 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> > : std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 3114 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3115 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3116 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 3117 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, CInitNPC*> >
{
};
#pragma pack(pop)

/* 3118 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CInitNPC*> > : std::_Allocator_base<std::pair<int const, CInitNPC*> >
{
};
#pragma pack(pop)

/* 3119 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >
{
	std::allocator<std::pair<int const, CInitNPC*> > _Alval;
};
#pragma pack(pop)

/* 3120 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >::_Node* _Right;
	std::pair<int const, CInitNPC*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 3121 */
#pragma pack(push, 1)
class std::pair<int const, CInitNPC*>
{
	const int first;
	CInitNPC* second;
};
#pragma pack(pop)

/* 3122 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 3123 */
#pragma pack(push, 1)
class std::map<int, CInitNPC*> : std::_Tree<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >
{
};
#pragma pack(pop)

/* 3124 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CInitNPC*>, int, std::pair<int const, CInitNPC*> const*, std::pair<int const, CInitNPC*> const&>
{
};
#pragma pack(pop)

/* 3125 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, CInitNPC*>, int, std::pair<int const, CInitNPC*> const*, std::pair<int const, CInitNPC*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CInitNPC*>, int, std::pair<int const, CInitNPC*> const*, std::pair<int const, CInitNPC*> const&>
{
};
#pragma pack(pop)

/* 3126 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, CInitNPC*>, int, std::pair<int const, CInitNPC*> const*, std::pair<int const, CInitNPC*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 3127 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 3128 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 3129 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CInitNPC*> >::rebind<std::pair<int const, CInitNPC*> >
{
};
#pragma pack(pop)

/* 3130 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CInitNPC*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3131 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CInitNPC*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CInitNPC*, std::less<int>, std::allocator<std::pair<int const, CInitNPC*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3132 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CInitNPC*> >::rebind<int>
{
};
#pragma pack(pop)

/* 3133 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CInitNPC*> >::rebind<char>
{
};
#pragma pack(pop)

/* 3134 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 3135 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGenNPC*> >::rebind<std::pair<int const, CGenNPC*> >
{
};
#pragma pack(pop)

/* 3136 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGenNPC*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3137 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGenNPC*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CGenNPC*, std::less<int>, std::allocator<std::pair<int const, CGenNPC*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3138 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGenNPC*> >::rebind<int>
{
};
#pragma pack(pop)

/* 3139 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGenNPC*> >::rebind<char>
{
};
#pragma pack(pop)

/* 3140 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 3141 */
#pragma pack(push, 1)
class std::pair<std::_Tree<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::iterator, std::_Tree<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::iterator>
{
	std::_Tree<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::iterator first;
	std::_Tree<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::iterator second;
};
#pragma pack(pop)

/* 3142 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CNPC*> >::rebind<std::pair<int const, CNPC*> >
{
};
#pragma pack(pop)

/* 3143 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CNPC*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3144 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CNPC*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CNPC*, std::less<int>, std::allocator<std::pair<int const, CNPC*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3145 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CNPC*> >::rebind<int>
{
};
#pragma pack(pop)

/* 3146 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CNPC*> >::rebind<char>
{
};
#pragma pack(pop)

/* 3147 */
#pragma pack(push, 1)
class CMonsterObject : CIOObject
{
	CIOCriticalSection m_lockLink[2];
	CLink m_link[2];
	int bDoBigBirdMotherSpwan;
};
#pragma pack(pop)

/* 3148 */
#pragma pack(push, 1)
class /*VFT*/ CMonsterObject_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
};
#pragma pack(pop)

/* 3149 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 3150 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3151 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3152 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> > : std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 3153 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3154 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3155 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 3156 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, CInitMonster*> >
{
};
#pragma pack(pop)

/* 3157 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CInitMonster*> > : std::_Allocator_base<std::pair<int const, CInitMonster*> >
{
};
#pragma pack(pop)

/* 3158 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >
{
	std::allocator<std::pair<int const, CInitMonster*> > _Alval;
};
#pragma pack(pop)

/* 3159 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >::_Node* _Right;
	std::pair<int const, CInitMonster*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 3160 */
#pragma pack(push, 1)
class std::pair<int const, CInitMonster*>
{
	const int first;
	CInitMonster* second;
};
#pragma pack(pop)

/* 3161 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 3162 */
#pragma pack(push, 1)
class std::map<int, CInitMonster*> : std::_Tree<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >
{
};
#pragma pack(pop)

/* 3163 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CInitMonster*>, int, std::pair<int const, CInitMonster*> const*, std::pair<int const, CInitMonster*> const&>
{
};
#pragma pack(pop)

/* 3164 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, CInitMonster*>, int, std::pair<int const, CInitMonster*> const*, std::pair<int const, CInitMonster*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CInitMonster*>, int, std::pair<int const, CInitMonster*> const*, std::pair<int const, CInitMonster*> const&>
{
};
#pragma pack(pop)

/* 3165 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, CInitMonster*>, int, std::pair<int const, CInitMonster*> const*, std::pair<int const, CInitMonster*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 3166 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 3167 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 3168 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3169 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3170 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> > : std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 3171 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3172 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3173 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 3174 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, CGenMonster*> >
{
};
#pragma pack(pop)

/* 3175 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGenMonster*> > : std::_Allocator_base<std::pair<int const, CGenMonster*> >
{
};
#pragma pack(pop)

/* 3176 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >
{
	std::allocator<std::pair<int const, CGenMonster*> > _Alval;
};
#pragma pack(pop)

/* 3177 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >::_Node* _Right;
	std::pair<int const, CGenMonster*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 3178 */
#pragma pack(push, 1)
class std::pair<int const, CGenMonster*>
{
	const int first;
	CGenMonster* second;
};
#pragma pack(pop)

/* 3179 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 3180 */
#pragma pack(push, 1)
class std::map<int, CGenMonster*> : std::_Tree<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >
{
};
#pragma pack(pop)

/* 3181 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CGenMonster*>, int, std::pair<int const, CGenMonster*> const*, std::pair<int const, CGenMonster*> const&>
{
};
#pragma pack(pop)

/* 3182 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, CGenMonster*>, int, std::pair<int const, CGenMonster*> const*, std::pair<int const, CGenMonster*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CGenMonster*>, int, std::pair<int const, CGenMonster*> const*, std::pair<int const, CGenMonster*> const&>
{
};
#pragma pack(pop)

/* 3183 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, CGenMonster*>, int, std::pair<int const, CGenMonster*> const*, std::pair<int const, CGenMonster*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 3184 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 3185 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 3186 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3187 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3188 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> > : std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 3189 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3190 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3191 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 3192 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, CMonster*> >
{
};
#pragma pack(pop)

/* 3193 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CMonster*> > : std::_Allocator_base<std::pair<int const, CMonster*> >
{
};
#pragma pack(pop)

/* 3194 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >
{
	std::allocator<std::pair<int const, CMonster*> > _Alval;
};
#pragma pack(pop)

/* 3195 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::_Node* _Right;
	std::pair<int const, CMonster*> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 3196 */
#pragma pack(push, 1)
class std::pair<int const, CMonster*>
{
	const int first;
	CMonster* second;
};
#pragma pack(pop)

/* 3197 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> > : std::_Tree_val<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 3198 */
#pragma pack(push, 1)
class std::map<int, CMonster*> : std::_Tree<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >
{
};
#pragma pack(pop)

/* 3199 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CMonster*>, int, std::pair<int const, CMonster*> const*, std::pair<int const, CMonster*> const&>
{
};
#pragma pack(pop)

/* 3200 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, CMonster*>, int, std::pair<int const, CMonster*> const*, std::pair<int const, CMonster*> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, CMonster*>, int, std::pair<int const, CMonster*> const*, std::pair<int const, CMonster*> const&>
{
};
#pragma pack(pop)

/* 3201 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::const_iterator : std::_Bidit<std::pair<int const, CMonster*>, int, std::pair<int const, CMonster*> const*, std::pair<int const, CMonster*> const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 3202 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 3203 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<CParty* const, int>, int, std::pair<CParty* const, int> const*, std::pair<CParty* const, int> const&>
{
};
#pragma pack(pop)

/* 3204 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<CParty* const, int>, int, std::pair<CParty* const, int> const*, std::pair<CParty* const, int> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<CParty* const, int>, int, std::pair<CParty* const, int> const*, std::pair<CParty* const, int> const&>
{
};
#pragma pack(pop)

/* 3205 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >::const_iterator : std::_Bidit<std::pair<CParty* const, int>, int, std::pair<CParty* const, int> const*, std::pair<CParty* const, int> const&>
{
	std::_Tree_nod<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 3206 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 3207 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, CMonster*, int, CMonster* const*, CMonster* const&>
{
};
#pragma pack(pop)

/* 3208 */
#pragma pack(push, 1)
class std::_Bidit<CMonster*, int, CMonster* const*, CMonster* const&> : std::iterator<std::bidirectional_iterator_tag, CMonster*, int, CMonster* const*, CMonster* const&>
{
};
#pragma pack(pop)

/* 3209 */
#pragma pack(push, 1)
class std::list<CMonster*>::const_iterator : std::_Bidit<CMonster*, int, CMonster* const*, CMonster* const&>
{
	std::_List_nod<CMonster*>::_Node* _Ptr;
};
#pragma pack(pop)

/* 3210 */
#pragma pack(push, 1)
class std::list<CMonster*>::iterator : std::list<CMonster*>::const_iterator
{
};
#pragma pack(pop)

/* 3211 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 3212 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CInitMonster*> >::rebind<std::pair<int const, CInitMonster*> >
{
};
#pragma pack(pop)

/* 3213 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CInitMonster*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3214 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CInitMonster*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CInitMonster*, std::less<int>, std::allocator<std::pair<int const, CInitMonster*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3215 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CInitMonster*> >::rebind<int>
{
};
#pragma pack(pop)

/* 3216 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CInitMonster*> >::rebind<char>
{
};
#pragma pack(pop)

/* 3217 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 3218 */
#pragma pack(push, 1)
class std::pair<std::_Tree<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::iterator, std::_Tree<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::iterator>
{
	std::_Tree<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::iterator first;
	std::_Tree<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::iterator second;
};
#pragma pack(pop)

/* 3219 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CMonster*> >::rebind<std::pair<int const, CMonster*> >
{
};
#pragma pack(pop)

/* 3220 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CMonster*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3221 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CMonster*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CMonster*, std::less<int>, std::allocator<std::pair<int const, CMonster*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3222 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CMonster*> >::rebind<int>
{
};
#pragma pack(pop)

/* 3223 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CMonster*> >::rebind<char>
{
};
#pragma pack(pop)

/* 3224 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 3225 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGenMonster*> >::rebind<std::pair<int const, CGenMonster*> >
{
};
#pragma pack(pop)

/* 3226 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGenMonster*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3227 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGenMonster*> >::rebind<std::_Tree_nod<std::_Tmap_traits<int, CGenMonster*, std::less<int>, std::allocator<std::pair<int const, CGenMonster*> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3228 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGenMonster*> >::rebind<int>
{
};
#pragma pack(pop)

/* 3229 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, CGenMonster*> >::rebind<char>
{
};
#pragma pack(pop)

/* 3230 */
#pragma pack(push, 1)
class std::allocator<CMonster*>::rebind<std::_List_nod<CMonster*>::_Node>
{
};
#pragma pack(pop)

/* 3231 */
#pragma pack(push, 1)
class std::allocator<CMonster*>::rebind<std::_List_nod<CMonster*>::_Node*>
{
};
#pragma pack(pop)

/* 3232 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 3233 */
#pragma pack(push, 1)
class std::allocator<std::pair<CParty* const, int> >::rebind<std::pair<CParty* const, int> >
{
};
#pragma pack(pop)

/* 3234 */
#pragma pack(push, 1)
class std::allocator<std::pair<CParty* const, int> >::rebind<std::_Tree_nod<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3235 */
#pragma pack(push, 1)
class std::allocator<std::pair<CParty* const, int> >::rebind<std::_Tree_nod<std::_Tmap_traits<CParty*, int, std::less<CParty*>, std::allocator<std::pair<CParty* const, int> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3236 */
#pragma pack(push, 1)
class std::allocator<std::pair<CParty* const, int> >::rebind<CParty*>
{
};
#pragma pack(pop)

/* 3237 */
#pragma pack(push, 1)
class std::allocator<std::pair<CParty* const, int> >::rebind<char>
{
};
#pragma pack(pop)

/* 3238 */
#pragma pack(push, 1)
class std::_Allocator_base<CParty*>
{
};
#pragma pack(pop)

/* 3239 */
#pragma pack(push, 1)
class std::allocator<CParty*> : std::_Allocator_base<CParty*>
{
};
#pragma pack(pop)

/* 3240 */
#pragma pack(push, 1)
class std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0>
{
	std::less<int> comp;
};
#pragma pack(pop)

/* 3241 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3242 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3243 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> > : std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 3244 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3245 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3246 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> > : std::_Tree_nod<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 3247 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<int const, std::string > >
{
};
#pragma pack(pop)

/* 3248 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, std::string > > : std::_Allocator_base<std::pair<int const, std::string > >
{
};
#pragma pack(pop)

/* 3249 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> > : std::_Tree_ptr<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >
{
	std::allocator<std::pair<int const, std::string > > _Alval;
};
#pragma pack(pop)

/* 3250 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >::_Node* _Right;
	std::pair<int const, std::string > _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 3251 */
#pragma pack(push, 1)
class std::pair<int const, std::string >
{
	const int first;
	std::string second;
};
#pragma pack(pop)

/* 3252 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> > : std::_Tree_val<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 3253 */
#pragma pack(push, 1)
class std::map<int, std::string> : std::_Tree<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >
{
};
#pragma pack(pop)

/* 3254 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<int const, std::string >, int, std::pair<int const, std::string > const*, std::pair<int const, std::string > const&>
{
};
#pragma pack(pop)

/* 3255 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<int const, std::string >, int, std::pair<int const, std::string > const*, std::pair<int const, std::string > const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<int const, std::string >, int, std::pair<int const, std::string > const*, std::pair<int const, std::string > const&>
{
};
#pragma pack(pop)

/* 3256 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >::const_iterator : std::_Bidit<std::pair<int const, std::string >, int, std::pair<int const, std::string > const*, std::pair<int const, std::string > const&>
{
	std::_Tree_nod<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 3257 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >::iterator : std::_Tree<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 3258 */
#pragma pack(push, 1)
class CLog
{
};
#pragma pack(pop)

/* 3259 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, std::string > >::rebind<std::pair<int const, std::string > >
{
};
#pragma pack(pop)

/* 3260 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, std::string > >::rebind<std::_Tree_nod<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3261 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, std::string > >::rebind<std::_Tree_nod<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3262 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, std::string > >::rebind<int>
{
};
#pragma pack(pop)

/* 3263 */
#pragma pack(push, 1)
class std::allocator<std::pair<int const, std::string > >::rebind<char>
{
};
#pragma pack(pop)

/* 3264 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<int, std::string, std::less<int>, std::allocator<std::pair<int const, std::string > >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 3265 */
#pragma pack(push, 1)
class CMainConfig
{
};
#pragma pack(pop)

/* 3266 */
#pragma pack(push, 1)
class CItemOrnament : CItem
{
};
#pragma pack(pop)

/* 3267 */
#pragma pack(push, 1)
class /*VFT*/ CItemOrnament_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	void(__thiscall* PutInfo)(CItem* this, char**, int);
	_BYTE gap4C[4];
	void(__thiscall* Init)(CItem* this, int, char**);
	void(__thiscall* SetWearState)(CItem* this, CPlayer*);
	int(__thiscall* Trash)(CItem* this, CPlayer*, int);
	void(__thiscall* Erase)(CItem* this, int);
	void(__thiscall* PutOn)(CItem* this, CPlayer*);
	void(__thiscall* PutOff)(CItem* this, CPlayer*);
	void(__thiscall* ApplySpec)(CItem* this, CPlayer*);
	void(__thiscall* FreeSpec)(CItem* this, CPlayer*);
	_BYTE gap70[4];
	void(__thiscall* Insert)(CItem* this, int, int);
	int(__thiscall* UpdateNum)(CItem* this, CPlayer*, int, int);
	void(__thiscall* Drop)(CItem* this, CChar*, const tagPOINT*, const tagPOINT*, int, int, int);
	int(__thiscall* Use)(CItem* this, CPlayer*);
	CItem* (__thiscall* Trade)(CItem* this, CPlayer*, int, int);
	int(__thiscall* CanSell)(CItem* this, int);
	int(__thiscall* CanTrade)(CItem* this, int, CPlayer*, CPlayer*);
	int(__thiscall* CanDrop)(CItem* this, int, CPlayer*);
	int(__thiscall* CanMerge)(CItem* this, CItem*);
	int(__thiscall* StorageIn)(CItem* this, CPlayer*, int);
	int(__thiscall* StorageOut)(CItem* this, CPlayer*, int, int, int*);
	void(__thiscall* ForcedStorageIn)(CItem* this, int, int, char*, int);
	int(__thiscall* IsMoney)(CItem* this);
	int(__thiscall* IsBroken)(CItem* this);
	int(__thiscall* Enchant)(CItem* this, CPlayer*, CItem*);
	int(__thiscall* Charming)(CItem* this, CPlayer*, int);
	int(__thiscall* CharmingCheat)(CItem* this, CPlayer*, int, int);
	int(__thiscall* Repair)(CItem* this, CPlayer*);
	int(__thiscall* ChangePrefix)(CItem* this, CPlayer*, int, int*, int*);
	int(__thiscall* Protect)(CItem* this, CPlayer*);
	int(__thiscall* IsQuestItem)(CItem* this);
	int(__thiscall* GetSellMoney)(CItem* this, int);
	void(__thiscall* SetEtc)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeDestroy)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeRateUp)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeLevel)(CItem* this, CPlayer*);
};
#pragma pack(pop)

/* 3268 */
#pragma pack(push, 1)
class CItemGeneral : CItem
{
};
#pragma pack(pop)

/* 3269 */
#pragma pack(push, 1)
class /*VFT*/ CItemGeneral_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	void(__thiscall* PutInfo)(CItem* this, char**, int);
	_BYTE gap4C[4];
	void(__thiscall* Init)(CItem* this, int, char**);
	void(__thiscall* SetWearState)(CItem* this, CPlayer*);
	int(__thiscall* Trash)(CItem* this, CPlayer*, int);
	void(__thiscall* Erase)(CItem* this, int);
	void(__thiscall* PutOn)(CItem* this, CPlayer*);
	void(__thiscall* PutOff)(CItem* this, CPlayer*);
	void(__thiscall* ApplySpec)(CItem* this, CPlayer*);
	void(__thiscall* FreeSpec)(CItem* this, CPlayer*);
	_BYTE gap70[4];
	void(__thiscall* Insert)(CItem* this, int, int);
	int(__thiscall* UpdateNum)(CItem* this, CPlayer*, int, int);
	void(__thiscall* Drop)(CItem* this, CChar*, const tagPOINT*, const tagPOINT*, int, int, int);
	int(__thiscall* Use)(CItem* this, CPlayer*);
	CItem* (__thiscall* Trade)(CItem* this, CPlayer*, int, int);
	int(__thiscall* CanSell)(CItem* this, int);
	int(__thiscall* CanTrade)(CItem* this, int, CPlayer*, CPlayer*);
	int(__thiscall* CanDrop)(CItem* this, int, CPlayer*);
	int(__thiscall* CanMerge)(CItem* this, CItem*);
	int(__thiscall* StorageIn)(CItem* this, CPlayer*, int);
	int(__thiscall* StorageOut)(CItem* this, CPlayer*, int, int, int*);
	void(__thiscall* ForcedStorageIn)(CItem* this, int, int, char*, int);
	int(__thiscall* IsMoney)(CItem* this);
	int(__thiscall* IsBroken)(CItem* this);
	int(__thiscall* Enchant)(CItem* this, CPlayer*, CItem*);
	int(__thiscall* Charming)(CItem* this, CPlayer*, int);
	int(__thiscall* CharmingCheat)(CItem* this, CPlayer*, int, int);
	int(__thiscall* Repair)(CItem* this, CPlayer*);
	int(__thiscall* ChangePrefix)(CItem* this, CPlayer*, int, int*, int*);
	int(__thiscall* Protect)(CItem* this, CPlayer*);
	int(__thiscall* IsQuestItem)(CItem* this);
	int(__thiscall* GetSellMoney)(CItem* this, int);
	void(__thiscall* SetEtc)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeDestroy)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeRateUp)(CItem* this, CPlayer*);
	void(__thiscall* UpgradeLevel)(CItem* this, CPlayer*);
};
#pragma pack(pop)

/* 3270 */
#pragma pack(push, 1)
class std::_Allocator_base<CIOSocket::CIOTimer>
{
};
#pragma pack(pop)

/* 3271 */
#pragma pack(push, 1)
class std::allocator<CIOSocket::CIOTimer> : std::_Allocator_base<CIOSocket::CIOTimer>
{
};
#pragma pack(pop)

/* 3272 */
#pragma pack(push, 1)
class std::_Vector_val<CIOSocket::CIOTimer>
{
	std::allocator<CIOSocket::CIOTimer> _Alval;
};
#pragma pack(pop)

/* 3273 */
#pragma pack(push, 1)
class std::vector<CIOSocket::CIOTimer> : std::_Vector_val<CIOSocket::CIOTimer>
{
	__declspec(align(4)) CIOSocket::CIOTimer* _Myfirst;
	CIOSocket::CIOTimer* _Mylast;
	CIOSocket::CIOTimer* _Myend;
};
#pragma pack(pop)

/* 3274 */
#pragma pack(push, 1)
class std::binary_function<CIOSocket::CIOTimer, CIOSocket::CIOTimer, bool>
{
};
#pragma pack(pop)

/* 3275 */
#pragma pack(push, 1)
class std::less<CIOSocket::CIOTimer> : std::binary_function<CIOSocket::CIOTimer, CIOSocket::CIOTimer, bool>
{
};
#pragma pack(pop)

/* 3276 */
#pragma pack(push, 1)
class __declspec(align(4)) std::priority_queue<CIOSocket::CIOTimer>
{
	std::vector<CIOSocket::CIOTimer> c;
	std::less<CIOSocket::CIOTimer> comp;
};
#pragma pack(pop)

/* 3277 */
#pragma pack(push, 1)
class std::iterator<std::random_access_iterator_tag, CIOSocket::CIOTimer, int, CIOSocket::CIOTimer const*, CIOSocket::CIOTimer const&>
{
};
#pragma pack(pop)

/* 3278 */
#pragma pack(push, 1)
class std::_Ranit<CIOSocket::CIOTimer, int, CIOSocket::CIOTimer const*, CIOSocket::CIOTimer const&> : std::iterator<std::random_access_iterator_tag, CIOSocket::CIOTimer, int, CIOSocket::CIOTimer const*, CIOSocket::CIOTimer const&>
{
};
#pragma pack(pop)

/* 3279 */
#pragma pack(push, 1)
class std::vector<CIOSocket::CIOTimer>::const_iterator : std::_Ranit<CIOSocket::CIOTimer, int, CIOSocket::CIOTimer const*, CIOSocket::CIOTimer const&>
{
	CIOSocket::CIOTimer* _Myptr;
};
#pragma pack(pop)

/* 3280 */
#pragma pack(push, 1)
class std::vector<CIOSocket::CIOTimer>::iterator : std::vector<CIOSocket::CIOTimer>::const_iterator
{
};
#pragma pack(pop)

/* 3281 */
#pragma pack(push, 1)
class std::allocator<CIOSocket::CIOTimer>::rebind<CIOSocket::CIOTimer>
{
};
#pragma pack(pop)

/* 3282 */
#pragma pack(push, 1)
class GetExceptionDescription::__l2::ExceptionNames
{
	unsigned int ExceptionCode;
	char* ExceptionName;
};
#pragma pack(pop)

/* 3283 */
#pragma pack(push, 1)
class std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0>
{
	iless comp;
};
#pragma pack(pop)

/* 3284 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3285 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >::_Node> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3286 */
#pragma pack(push, 1)
class std::_Tree_nod<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> > : std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0>
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >::_Node> _Alnod;
};
#pragma pack(pop)

/* 3287 */
#pragma pack(push, 1)
class std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3288 */
#pragma pack(push, 1)
class std::allocator<std::_Tree_nod<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >::_Node*> : std::_Allocator_base<std::_Tree_nod<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3289 */
#pragma pack(push, 1)
class std::_Tree_ptr<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> > : std::_Tree_nod<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >
{
	std::allocator<std::_Tree_nod<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >::_Node*> _Alptr;
};
#pragma pack(pop)

/* 3290 */
#pragma pack(push, 1)
class std::_Allocator_base<std::pair<char const* const, int> >
{
};
#pragma pack(pop)

/* 3291 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, int> > : std::_Allocator_base<std::pair<char const* const, int> >
{
};
#pragma pack(pop)

/* 3292 */
#pragma pack(push, 1)
class std::_Tree_val<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> > : std::_Tree_ptr<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >
{
	std::allocator<std::pair<char const* const, int> > _Alval;
};
#pragma pack(pop)

/* 3293 */
#pragma pack(push, 1)
class __declspec(align(4)) std::_Tree_nod<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >::_Node
{
	std::_Tree_nod<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >::_Node* _Left;
	std::_Tree_nod<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >::_Node* _Parent;
	std::_Tree_nod<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >::_Node* _Right;
	std::pair<char const* const, int> _Myval;
	char _Color;
	char _Isnil;
};
#pragma pack(pop)

/* 3294 */
#pragma pack(push, 1)
class std::pair<char const* const, int>
{
	const char* const first;
	int second;
};
#pragma pack(pop)

/* 3295 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> > : std::_Tree_val<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >
{
	std::_Tree_nod<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >::_Node* _Myhead;
	unsigned int _Mysize;
};
#pragma pack(pop)

/* 3296 */
#pragma pack(push, 1)
class std::map<char const*, int, iless, std::allocator<std::pair<char const* const, int> > > : std::_Tree<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >
{
};
#pragma pack(pop)

/* 3297 */
#pragma pack(push, 1)
class std::iterator<std::bidirectional_iterator_tag, std::pair<char const* const, int>, int, std::pair<char const* const, int> const*, std::pair<char const* const, int> const&>
{
};
#pragma pack(pop)

/* 3298 */
#pragma pack(push, 1)
class std::_Bidit<std::pair<char const* const, int>, int, std::pair<char const* const, int> const*, std::pair<char const* const, int> const&> : std::iterator<std::bidirectional_iterator_tag, std::pair<char const* const, int>, int, std::pair<char const* const, int> const*, std::pair<char const* const, int> const&>
{
};
#pragma pack(pop)

/* 3299 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >::const_iterator : std::_Bidit<std::pair<char const* const, int>, int, std::pair<char const* const, int> const*, std::pair<char const* const, int> const&>
{
	std::_Tree_nod<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >::_Node* _Ptr;
};
#pragma pack(pop)

/* 3300 */
#pragma pack(push, 1)
class std::_Tree<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >::iterator : std::_Tree<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >::const_iterator
{
};
#pragma pack(pop)

/* 3301 */
#pragma pack(push, 1)
class __declspec(align(4)) std::pair<std::_Tree<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >::iterator, bool>
{
	std::_Tree<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >::iterator first;
	bool second;
};
#pragma pack(pop)

/* 3302 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, int> >::rebind<std::pair<char const* const, int> >
{
};
#pragma pack(pop)

/* 3303 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, int> >::rebind<std::_Tree_nod<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >::_Node>
{
};
#pragma pack(pop)

/* 3304 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, int> >::rebind<std::_Tree_nod<std::_Tmap_traits<char const*, int, iless, std::allocator<std::pair<char const* const, int> >, 0> >::_Node*>
{
};
#pragma pack(pop)

/* 3305 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, int> >::rebind<char const*>
{
};
#pragma pack(pop)

/* 3306 */
#pragma pack(push, 1)
class std::allocator<std::pair<char const* const, int> >::rebind<char>
{
};
#pragma pack(pop)

/* 3307 */
#pragma pack(push, 1)
class CASTLEOBJECT
{
	int nCID;
	int nIndex;
	int nMap;
	tagPOINT ptPixel;
	tagPOINT ptDir;
};
#pragma pack(pop)

/* 3308 */
#pragma pack(push, 1)
class std::pair<int, CAlliance*>
{
	int first;
	CAlliance* second;
};
#pragma pack(pop)

/* 3309 */
#pragma pack(push, 1)
class std::pair<int, CCastle*>
{
	int first;
	CCastle* second;
};
#pragma pack(pop)

/* 3310 */
#pragma pack(push, 1)
class std::pair<int, CGuild*>
{
	int first;
	CGuild* second;
};
#pragma pack(pop)

/* 3311 */
#pragma pack(push, 1)
class std::pair<int, stMember*>
{
	int first;
	stMember* second;
};
#pragma pack(pop)

/* 3312 */
#pragma pack(push, 1)
class CMemoryPool<CFindPath::NODE>::CPool
{
	CFindPath::NODE* m_pT;
	CIOSpinLock m_lock;
};
#pragma pack(pop)

/* 3313 */
#pragma pack(push, 1)
class CMemoryPool<CFindPath::NODE>
{
};
#pragma pack(pop)

/* 3316 */
#pragma pack(push, 1)
union $BEC26492A4560F3C3DE0425E15FBAC1A
{
	CIOBuffer* m_pBuf;
	CDBPacket* m_pNext;
};
#pragma pack(pop)

/* 3314 */
#pragma pack(push, 1)
class CDBPacket : CIOObject
{
	$BEC26492A4560F3C3DE0425E15FBAC1A ___u1;
};
#pragma pack(pop)

/* 3315 */
#pragma pack(push, 1)
class /*VFT*/ CDBPacket_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
};
#pragma pack(pop)

/* 3317 */
#pragma pack(push, 1)
class CMemoryPool<CDBPacket>::CPool
{
	CDBPacket* m_pT;
	CIOSpinLock m_lock;
};
#pragma pack(pop)

/* 3318 */
#pragma pack(push, 1)
class CMemoryPool<CDBPacket>
{
};
#pragma pack(pop)

/* 3319 */
#pragma pack(push, 1)
class CMemoryPool<CBaseList>::CPool
{
	CBaseList* m_pT;
	CIOSpinLock m_lock;
};
#pragma pack(pop)

/* 3320 */
#pragma pack(push, 1)
class CMemoryPool<CBaseList>
{
};
#pragma pack(pop)

/* 3323 */
#pragma pack(push, 1)
union $B83E2B04595FD5E0589932BAF97320FA
{
	CIOBuffer* m_pBuf;
	CAuthPacket* m_pNext;
};
#pragma pack(pop)

/* 3321 */
#pragma pack(push, 1)
class CAuthPacket : CIOObject
{
	$B83E2B04595FD5E0589932BAF97320FA ___u1;
};
#pragma pack(pop)

/* 3322 */
#pragma pack(push, 1)
class /*VFT*/ CAuthPacket_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
};
#pragma pack(pop)

/* 3324 */
#pragma pack(push, 1)
class CMemoryPool<CAuthPacket>::CPool
{
	CAuthPacket* m_pT;
	CIOSpinLock m_lock;
};
#pragma pack(pop)

/* 3325 */
#pragma pack(push, 1)
class CMemoryPool<CAuthPacket>
{
};
#pragma pack(pop)

/* 3326 */
#pragma pack(push, 1)
class std::wstreambuf
{
	std::wstreambuf_vtbl* __vftable /*VFT*/;
	std::_Mutex _Mylock;
	wchar_t* _Gfirst;
	wchar_t* _Pfirst;
	wchar_t** _IGfirst;
	wchar_t** _IPfirst;
	wchar_t* _Gnext;
	wchar_t* _Pnext;
	wchar_t** _IGnext;
	wchar_t** _IPnext;
	int _Gcount;
	int _Pcount;
	int* _IGcount;
	int* _IPcount;
	std::locale* _Plocale;
};
#pragma pack(pop)

/* 3327 */
#pragma pack(push, 1)
class /*VFT*/ std::wstreambuf_vtbl
{
	void(__thiscall * ~basic_streambuf<wchar_t, std::char_traits<wchar_t> >)(std::wstreambuf* this);
	unsigned __int16(__thiscall* overflow)(std::wstreambuf* this, unsigned __int16);
	unsigned __int16(__thiscall* pbackfail)(std::wstreambuf* this, unsigned __int16);
	int(__thiscall* showmanyc)(std::wstreambuf* this);
	unsigned __int16(__thiscall* underflow)(std::wstreambuf* this);
	unsigned __int16(__thiscall* uflow)(std::wstreambuf* this);
	int(__thiscall* xsgetn)(std::wstreambuf* this, wchar_t*, int);
	int(__thiscall* xsputn)(std::wstreambuf* this, const wchar_t*, int);
	std::fpos<int>* (__thiscall* seekoff)(std::wstreambuf* this, std::fpos<int>* result, int, int, int);
	std::fpos<int>* (__thiscall* seekpos)(std::wstreambuf* this, std::fpos<int>* result, std::fpos<int>, int);
	std::wstreambuf* (__thiscall* setbuf)(std::wstreambuf* this, wchar_t*, int);
	int(__thiscall* sync)(std::wstreambuf* this);
	void(__thiscall* imbue)(std::wstreambuf* this, const std::locale*);
};
#pragma pack(pop)

/* 3328 */
#pragma pack(push, 1)
class std::char_traits<wchar_t>
{
};
#pragma pack(pop)

/* 3329 */
#pragma pack(push, 1)
class std::ctype<wchar_t> : std::ctype_base
{
	_Ctypevec _Ctype;
	_Cvtvec _Cvt;
};
#pragma pack(pop)

/* 3330 */
#pragma pack(push, 1)
class /*VFT*/ std::ctype<wchar_t>_vtbl
{
	void(__thiscall * ~facet)(std::locale::facet* this);
	_BYTE gap4[4];
	bool(__thiscall* do_is)(std::ctype<wchar_t>* this, __int16, wchar_t);
	const wchar_t* (__thiscall* do_scan_is)(std::ctype<wchar_t>* this, __int16, const wchar_t*, const wchar_t*);
	const wchar_t* (__thiscall* do_scan_not)(std::ctype<wchar_t>* this, __int16, const wchar_t*, const wchar_t*);
	_BYTE gap14[4];
	wchar_t(__thiscall* do_tolower)(std::ctype<wchar_t>* this, wchar_t);
	_BYTE gap1C[4];
	wchar_t(__thiscall* do_toupper)(std::ctype<wchar_t>* this, wchar_t);
	_BYTE gap24[4];
	wchar_t(__thiscall* do_widen)(std::ctype<wchar_t>* this, char);
	_BYTE gap2C[4];
	char(__thiscall* do_narrow)(std::ctype<wchar_t>* this, wchar_t, char);
};
#pragma pack(pop)

/* 3331 */
#pragma pack(push, 1)
class std::wostream
{
	_BYTE gap0[56];
};
#pragma pack(pop)

/* 3332 */
#pragma pack(push, 1)
class /*VFT*/ std::wostream_vtbl
{
	void* (__thiscall* __vecDelDtor)(std::wostream* this, unsigned int);
};
#pragma pack(pop)

/* 3333 */
#pragma pack(push, 1)
class __declspec(align(4)) std::wios : std::ios_base
{
	std::wstreambuf* _Mystrbuf;
	std::wostream* _Tiestr;
	wchar_t _Fillch;
};
#pragma pack(pop)

/* 3334 */
#pragma pack(push, 1)
class /*VFT*/ std::wios_vtbl
{
	void(__thiscall * ~ios_base)(std::ios_base* this);
};
#pragma pack(pop)

/* 3335 */
#pragma pack(push, 1)
class __declspec(align(4)) std::wistream
{
	_BYTE gap0[4];
	int _Chcount;
	_BYTE gap8[52];
};
#pragma pack(pop)

/* 3336 */
#pragma pack(push, 1)
class /*VFT*/ std::wistream_vtbl
{
	void* (__thiscall* __vecDelDtor)(std::wistream* this, unsigned int);
};
#pragma pack(pop)

/* 3337 */
#pragma pack(push, 1)
class std::wistream::_Sentry_base
{
	std::wistream* _Myistr;
};
#pragma pack(pop)

/* 3338 */
#pragma pack(push, 1)
class __declspec(align(4)) std::wistream::sentry : std::wistream::_Sentry_base
{
	bool _Ok;
};
#pragma pack(pop)

/* 3339 */
#pragma pack(push, 1)
class std::codecvt<wchar_t, char, int> : std::codecvt_base
{
	_Cvtvec _Cvt;
};
#pragma pack(pop)

/* 3340 */
#pragma pack(push, 1)
class /*VFT*/ std::codecvt<wchar_t, char, int>_vtbl
{
	void(__thiscall * ~facet)(std::locale::facet* this);
	bool(__thiscall* do_always_noconv)(std::codecvt_base* this);
	int(__thiscall* do_max_length)(std::codecvt_base* this);
	int(__thiscall* do_encoding)(std::codecvt_base* this);
	int(__thiscall* do_in)(std::codecvt<wchar_t, char, int>* this, int*, const char*, const char*, const char**, wchar_t*, wchar_t*, wchar_t**);
	int(__thiscall* do_out)(std::codecvt<wchar_t, char, int>* this, int*, const wchar_t*, const wchar_t*, const wchar_t**, char*, char*, char**);
	int(__thiscall* do_unshift)(std::codecvt<wchar_t, char, int>* this, int*, char*, char*, char**);
	int(__thiscall* do_length)(std::codecvt<wchar_t, char, int>* this, const int*, const char*, const char*, unsigned int);
};
#pragma pack(pop)

/* 3341 */
#pragma pack(push, 1)
class std::wostream::_Sentry_base
{
	std::wostream* _Myostr;
};
#pragma pack(pop)

/* 3342 */
#pragma pack(push, 1)
class __declspec(align(4)) std::wostream::sentry : std::wostream::_Sentry_base
{
	bool _Ok;
};
#pragma pack(pop)

/* 3343 */
#pragma pack(push, 1)
class _FloatOutclass
{
	__int16 exp;
	char sign;
	char ManLen;
	char man[22];
};
#pragma pack(pop)

/* 3344 */
#pragma pack(push, 1)
class _LDOUBLE
{
	unsigned __int8 ld[10];
};
#pragma pack(pop)

/* 3345 */
#pragma pack(push, 1)
class FpFormatDescriptor
{
	int max_exp;
	int min_exp;
	int precision;
	int exp_width;
	int format_width;
	int bias;
};
#pragma pack(pop)

/* 3346 */
#pragma pack(push, 1)
class DOUBLE
{
	long double x;
};
#pragma pack(pop)

/* 3347 */
#pragma pack(push, 1)
class FLOAT
{
	float f;
};
#pragma pack(pop)

/* 3348 */
#pragma pack(push, 1)
class _strflt
{
	int sign;
	int decpt;
	int flag;
	char* mantissa;
};
#pragma pack(pop)

/* 3349 */
#pragma pack(push, 1)
class transitiondate
{
	int yr;
	int yd;
	int ms;
};
#pragma pack(pop)

/* 3350 */
#pragma pack(push, 1)
union FT
{
	unsigned __int64 ft_scalar;
	_FILETIME ft_class;
};
#pragma pack(pop)

/* 3351 */
#pragma pack(push, 1)
class __lc_time_data
{
	char* wday_abbr[7];
	char* wday[7];
	char* month_abbr[12];
	char* month[12];
	char* ampm[2];
	char* ww_sdatefmt;
	char* ww_ldatefmt;
	char* ww_timefmt;
	unsigned int ww_lcid;
	int ww_caltype;
	int refcount;
};
#pragma pack(pop)

/* 3352 */
#pragma pack(push, 1)
class threadlocaleinfoclass
{
	int refcount;
	unsigned int lc_codepage;
	unsigned int lc_collate_cp;
	unsigned int lc_handle[6];
	int lc_clike;
	int mb_cur_max;
	int* lconv_intl_refcount;
	int* lconv_num_refcount;
	int* lconv_mon_refcount;
	lconv* lconv;
	lconv* lconv_intl;
	int* ctype1_refcount;
	unsigned __int16* ctype1;
	const unsigned __int16* pctype;
	__lc_time_data* lc_time_curr;
	__lc_time_data* lc_time_intl;
};
#pragma pack(pop)

/* 3353 */
#pragma pack(push, 1)
class __declspec(align(4)) threadmbcinfoclass
{
	int refcount;
	int mbcodepage;
	int ismbcodepage;
	int mblcid;
	unsigned __int16 mbulinfo[6];
	char mbctype[257];
	char mbcasemap[256];
};
#pragma pack(pop)

/* 3354 */
#pragma pack(push, 1)
class _tiddata
{
	unsigned int _tid;
	unsigned int _thandle;
	int _terrno;
	unsigned int _tdoserrno;
	unsigned int _fpds;
	unsigned int _holdrand;
	char* _token;
	unsigned __int16* _wtoken;
	unsigned __int8* _mtoken;
	char* _errmsg;
	unsigned __int16* _werrmsg;
	char* _namebuf0;
	unsigned __int16* _wnamebuf0;
	char* _namebuf1;
	unsigned __int16* _wnamebuf1;
	char* _asctimebuf;
	unsigned __int16* _wasctimebuf;
	void* _gmtimebuf;
	char* _cvtbuf;
	void* _initaddr;
	void* _initarg;
	void* _pxcptacttab;
	void* _tpxcptinfoptrs;
	int _tfpecode;
	threadmbcinfoclass* ptmbcinfo;
	threadlocaleinfoclass* ptlocinfo;
	unsigned int _NLG_dwCode;
	void* _terminate;
	void* _unexpected;
	void* _translator;
	void* _purecall;
	void* _curexception;
	void* _curcontext;
	int _ProcessingThrow;
	void* _pFrameInfoChain;
};
#pragma pack(pop)

/* 3355 */
#pragma pack(push, 1)
union $D307371786BE94A0C6123084F46E0A35
{
	char sz[512];
};
#pragma pack(pop)

/* 3356 */
#pragma pack(push, 1)
union $1666015E7427B1C69D4B5CCC0A26058C
{
	char* sz;
	unsigned __int16* wz;
};
#pragma pack(pop)

/* 3357 */
#pragma pack(push, 1)
class _count_string
{
	__int16 Length;
	__int16 MaximumLength;
	char* Buffer;
};
#pragma pack(pop)

/* 3358 */
#pragma pack(push, 1)
class ioinfo
{
	int osfhnd;
	char osfile;
	char pipech;
	__declspec(align(4)) int lockinitflag;
	_RTL_CRITICAL_SECTION lock;
};
#pragma pack(pop)

/* 3359 */
#pragma pack(push, 1)
class _XCPT_ACTION
{
	unsigned int XcptNum;
	int SigNum;
	void(__cdecl* XcptAction)(int);
};
#pragma pack(pop)

/* 3360 */
#pragma pack(push, 1)
class $A8076EB7FC9AECC8916068071FF899B2
{
	_RTL_CRITICAL_SECTION* lock;
	$D283E5A92EBEB600100C8EBC9C67A011 kind;
};
#pragma pack(pop)

/* 3361 */
#pragma pack(push, 1)
class rterrmsgs
{
	int rterrno;
	char* rterrtxt;
};
#pragma pack(pop)

/* 3362 */
#pragma pack(push, 1)
class tagLC_ID
{
	unsigned __int16 wLanguage;
	unsigned __int16 wCountry;
	unsigned __int16 wCodePage;
};
#pragma pack(pop)

/* 3363 */
#pragma pack(push, 1)
class tagLC_STRINGS
{
	char szLanguage[64];
	char szCountry[64];
	char szCodePage[16];
};
#pragma pack(pop)

/* 3364 */
#pragma pack(push, 1)
class _is_ctype_compatible
{
	unsigned int id;
	int is_clike;
};
#pragma pack(pop)

/* 3365 */
#pragma pack(push, 1)
class tagRGLOCINFO
{
	unsigned int lcid;
	char chILanguage[8];
	char* pchSEngLanguage;
	char chSAbbrevLangName[4];
	char* pchSEngCountry;
	char chSAbbrevCtryName[4];
	char chIDefaultCodepage[8];
	char chIDefaultAnsiCodepage[8];
};
#pragma pack(pop)

/* 3366 */
#pragma pack(push, 1)
class tagLOCALETAB
{
	char* szName;
	char chAbbrev[4];
};
#pragma pack(pop)

/* 3367 */
#pragma pack(push, 1)
class __declspec(align(32)) _JMP_BUF
{
	unsigned int saved_ebp;
	unsigned int saved_ebx;
	unsigned int saved_edi;
	unsigned int saved_esi;
	unsigned int saved_esp;
	unsigned int saved_return;
	unsigned int saved_xregistration;
	unsigned int saved_trylevel;
	unsigned int version_cookie;
	unsigned int unwind_func;
	unsigned int unwind_data;
};
#pragma pack(pop)

/* 3368 */
#pragma pack(push, 1)
class _EXCEPTION_REGISTRATION
{
	unsigned int prev;
	unsigned int handler;
};
#pragma pack(pop)

/* 3369 */
#pragma pack(push, 1)
class _NLG_INFO
{
	unsigned int dwSig;
	unsigned int uoffDestination;
	unsigned int dwCode;
	unsigned int uoffFramePointer;
};
#pragma pack(pop)

/* 3370 */
#pragma pack(push, 1)
class _C9_EXCEPTION_REGISTRATION
{
	unsigned int er_prev;
	unsigned int er_handler;
	unsigned int scopetable;
	unsigned int trylevel;
};
#pragma pack(pop)

/* 3371 */
#pragma pack(push, 1)
class _EXCEPTION_REGISTRATION_COMMON
{
	_BYTE gap0[8];
	unsigned int scopetable;
	unsigned int trylevel;
};
#pragma pack(pop)

/* 3372 */
#pragma pack(push, 1)
class code_page_info
{
	int code_page;
	unsigned __int16 mbulinfo[6];
	unsigned __int8 rgrange[4][8];
};
#pragma pack(pop)

/* 3373 */
#pragma pack(push, 1)
class $9286F5650706568195D3F823BD313251
{
	unsigned int lowerhalf;
	int upperhalf;
};
#pragma pack(pop)

/* 3374 */
#pragma pack(push, 1)
union doubleint
{
	__int64 bigint;
	$9286F5650706568195D3F823BD313251 twoints;
};
#pragma pack(pop)

/* 3375 */
#pragma pack(push, 1)
class tagEntry
{
	int sizeFront;
	tagEntry* pEntryNext;
	tagEntry* pEntryPrev;
};
#pragma pack(pop)

/* 3376 */
#pragma pack(push, 1)
class tagListHead
{
	tagEntry* pEntryNext;
	tagEntry* pEntryPrev;
};
#pragma pack(pop)

/* 3377 */
#pragma pack(push, 1)
class tagGroup
{
	int cntEntries;
	tagListHead listHead[64];
};
#pragma pack(pop)

/* 3378 */
#pragma pack(push, 1)
class tagRegion
{
	int indGroupUse;
	char cntRegionSize[64];
	unsigned int bitvGroupHi[32];
	unsigned int bitvGroupLo[32];
	tagGroup grpHeadList[32];
};
#pragma pack(pop)

/* 3379 */
#pragma pack(push, 1)
class tagHeader
{
	unsigned int bitvEntryHi;
	unsigned int bitvEntryLo;
	unsigned int bitvCommit;
	void* pHeapData;
	tagRegion* pRegion;
};
#pragma pack(pop)

/* 3380 */
#pragma pack(push, 1)
class tagEntryEnd
{
	int sizeBack;
};
#pragma pack(pop)

/* 3381 */
#pragma pack(push, 1)
class TypeDescriptor
{
	unsigned int hash;
	void* spare;
	char name[];
};
#pragma pack(pop)

/* 3382 */
#pragma pack(push, 1)
class PMD
{
	int mdisp;
	int pdisp;
	int vdisp;
};
#pragma pack(pop)

/* 3383 */
#pragma pack(push, 1)
class _s_CatchableType
{
	unsigned int properties;
	TypeDescriptor* pType;
	PMD thisDisplacement;
	int sizeOrOffset;
	void(__cdecl* copyFunction)();
};
#pragma pack(pop)

/* 3384 */
#pragma pack(push, 1)
class _s_CatchableTypeArray
{
	int nCatchableTypes;
	const _s_CatchableType* arrayOfCatchableTypes[];
};
#pragma pack(pop)

/* 3385 */
#pragma pack(push, 1)
class _s_HandlerType
{
	unsigned int adjectives;
	TypeDescriptor* pType;
	int dispCatchObj;
	void* addressOfHandler;
};
#pragma pack(pop)

/* 3386 */
#pragma pack(push, 1)
class _s_ESTypeList
{
	int nCount;
	const _s_HandlerType* pTypeArray;
};
#pragma pack(pop)

/* 3387 */
#pragma pack(push, 1)
class _s_ThrowInfo
{
	unsigned int attributes;
	void(__cdecl* pmfnUnwind)();
	int (*pForwardCompat)(...);
	const _s_CatchableTypeArray* pCatchableTypeArray;
};
#pragma pack(pop)

/* 3388 */
#pragma pack(push, 1)
class _s_UnwindMapEntry
{
	int toState;
	void(__cdecl* action)();
};
#pragma pack(pop)

/* 3389 */
#pragma pack(push, 1)
class _s_TryBlockMapEntry
{
	int tryLow;
	int tryHigh;
	int catchHigh;
	int nCatches;
	const _s_HandlerType* pHandlerArray;
};
#pragma pack(pop)

/* 3390 */
#pragma pack(push, 1)
class _s_FuncInfo
{
	unsigned __int32 magicNumber : 29;
	unsigned __int32 bbtFlags : 3;
	int maxState;
	const _s_UnwindMapEntry* pUnwindMap;
	unsigned int nTryBlocks;
	const _s_TryBlockMapEntry* pTryBlockMap;
	unsigned int nIPMapEntries;
	void* pIPtoStateMap;
	const _s_ESTypeList* pESTypeList;
};
#pragma pack(pop)

/* 3391 */
#pragma pack(push, 1)
class EHExceptionRecord::EHParameters
{
	unsigned int magicNumber;
	void* pExceptionObject;
	const _s_ThrowInfo* pThrowInfo;
};
#pragma pack(pop)

/* 3392 */
#pragma pack(push, 1)
class EHExceptionRecord
{
	unsigned int ExceptionCode;
	unsigned int ExceptionFlags;
	_EXCEPTION_RECORD* ExceptionRecord;
	void* ExceptionAddress;
	unsigned int NumberParameters;
	EHExceptionRecord::EHParameters params;
};
#pragma pack(pop)

/* 3393 */
#pragma pack(push, 1)
class CatchGuardRN
{
	EHRegistrationNode* pNext;
	void* pFrameHandler;
	unsigned int RandomCookie;
	const _s_FuncInfo* pFuncInfo;
	EHRegistrationNode* pRN;
	int CatchDepth;
};
#pragma pack(pop)

/* 3394 */
#pragma pack(push, 1)
class TranslatorGuardRN
{
	EHRegistrationNode* pNext;
	void* pFrameHandler;
	unsigned int RandomCookie;
	const _s_FuncInfo* pFuncInfo;
	EHRegistrationNode* pRN;
	int CatchDepth;
	EHRegistrationNode* pMarkerRN;
	void* ESP;
	void* EBP;
	int DidUnwind;
};
#pragma pack(pop)

/* 3395 */
#pragma pack(push, 1)
class FrameInfo
{
	void* pExceptionObject;
	FrameInfo* pNext;
};
#pragma pack(pop)

/* 3396 */
#pragma pack(push, 1)
class __JUMP_BUFFER
{
	unsigned int Ebp;
	unsigned int Ebx;
	unsigned int Edi;
	unsigned int Esi;
	unsigned int Esp;
	unsigned int Eip;
	unsigned int Registration;
	unsigned int TryLevel;
	unsigned int Cookie;
	unsigned int UnwindFunc;
	unsigned int UnwindData[6];
};
#pragma pack(pop)

/* 3397 */
#pragma pack(push, 1)
class errentry
{
	unsigned int oscode;
	int errnocode;
};
#pragma pack(pop)

/* 3398 */
#pragma pack(push, 1)
class /*VFT*/ CMonster_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	void(__thiscall* SetTarget)(CMonster* this, CChar*);
	void(__thiscall* SetProperty)(CMonster* this, CInitMonster*);
	void(__thiscall* Add)(CMonster* this, CChar*);
	void(__thiscall* Remove)(CMonster* this);
	void(__thiscall* AI)(CMonster* this);
	void(__thiscall* Tick)(CMonster* this);
	void(__thiscall* AddHostility)(CMonster* this, CChar*, int, int);
	void(__thiscall* SetGuild)(CMonster* this, int, char*);
	int(__thiscall* GetGID)(CMonster* this);
	char* (__thiscall* GetGuildName)(CMonster* this);
	void(__thiscall* ResetNextMove)(CMonster* this, unsigned int, int);
	void(__thiscall* Summon)(CMonster* this, int, int, int, int);
	void(__thiscall* Die)(CMonster* this, CChar*, int, int*, int*);
	char* (__thiscall* GetOperatorName)(CMonster* this);
};
#pragma pack(pop)

/* 3399 */
#pragma pack(push, 1)
class /*VFT*/ CMonsterNotReal_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	void(__thiscall* SetTarget)(CMonster* this, CChar*);
	void(__thiscall* SetProperty)(CMonster* this, CInitMonster*);
	void(__thiscall* Add)(CMonster* this, CChar*);
	void(__thiscall* Remove)(CMonster* this);
	void(__thiscall* AI)(CMonster* this);
	void(__thiscall* Tick)(CMonster* this);
	void(__thiscall* AddHostility)(CMonster* this, CChar*, int, int);
	void(__thiscall* SetGuild)(CMonster* this, int, char*);
	int(__thiscall* GetGID)(CMonster* this);
	char* (__thiscall* GetGuildName)(CMonster* this);
	void(__thiscall* ResetNextMove)(CMonster* this, unsigned int, int);
	void(__thiscall* Summon)(CMonster* this, int, int, int, int);
	void(__thiscall* Die)(CMonster* this, CChar*, int, int*, int*);
	char* (__thiscall* GetOperatorName)(CMonster* this);
};
#pragma pack(pop)

/* 3400 */
#pragma pack(push, 1)
class /*VFT*/ CMonsterReal_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	void(__thiscall* SetTarget)(CMonster* this, CChar*);
	void(__thiscall* SetProperty)(CMonster* this, CInitMonster*);
	void(__thiscall* Add)(CMonster* this, CChar*);
	void(__thiscall* Remove)(CMonster* this);
	void(__thiscall* AI)(CMonster* this);
	void(__thiscall* Tick)(CMonster* this);
	void(__thiscall* AddHostility)(CMonster* this, CChar*, int, int);
	void(__thiscall* SetGuild)(CMonster* this, int, char*);
	int(__thiscall* GetGID)(CMonster* this);
	char* (__thiscall* GetGuildName)(CMonster* this);
	void(__thiscall* ResetNextMove)(CMonster* this, unsigned int, int);
	void(__thiscall* Summon)(CMonster* this, int, int, int, int);
	void(__thiscall* Die)(CMonster* this, CChar*, int, int*, int*);
	char* (__thiscall* GetOperatorName)(CMonster* this);
	void(__thiscall* Attack)(CMonsterReal* this);
	void(__thiscall* Move)(CMonsterReal* this);
	int(__thiscall* IsIgnore)(CMonsterReal* this);
	void(__thiscall* Reaction)(CMonsterReal* this, int, int);
};
#pragma pack(pop)

/* 3401 */
#pragma pack(push, 1)
class /*VFT*/ CMonsterSiegeGunBall_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	void(__thiscall* SetTarget)(CMonster* this, CChar*);
	void(__thiscall* SetProperty)(CMonster* this, CInitMonster*);
	void(__thiscall* Add)(CMonster* this, CChar*);
	void(__thiscall* Remove)(CMonster* this);
	void(__thiscall* AI)(CMonster* this);
	void(__thiscall* Tick)(CMonster* this);
	void(__thiscall* AddHostility)(CMonster* this, CChar*, int, int);
	void(__thiscall* SetGuild)(CMonster* this, int, char*);
	int(__thiscall* GetGID)(CMonster* this);
	char* (__thiscall* GetGuildName)(CMonster* this);
	void(__thiscall* ResetNextMove)(CMonster* this, unsigned int, int);
	void(__thiscall* Summon)(CMonster* this, int, int, int, int);
	void(__thiscall* Die)(CMonster* this, CChar*, int, int*, int*);
	char* (__thiscall* GetOperatorName)(CMonster* this);
	void(__thiscall* Attack)(CMonsterReal* this);
	void(__thiscall* Move)(CMonsterReal* this);
	int(__thiscall* IsIgnore)(CMonsterReal* this);
	void(__thiscall* Reaction)(CMonsterReal* this, int, int);
};
#pragma pack(pop)

/* 3402 */
#pragma pack(push, 1)
class /*VFT*/ CMonsterSiegeGunRuins_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	void(__thiscall* SetTarget)(CMonster* this, CChar*);
	void(__thiscall* SetProperty)(CMonster* this, CInitMonster*);
	void(__thiscall* Add)(CMonster* this, CChar*);
	void(__thiscall* Remove)(CMonster* this);
	void(__thiscall* AI)(CMonster* this);
	void(__thiscall* Tick)(CMonster* this);
	void(__thiscall* AddHostility)(CMonster* this, CChar*, int, int);
	void(__thiscall* SetGuild)(CMonster* this, int, char*);
	int(__thiscall* GetGID)(CMonster* this);
	char* (__thiscall* GetGuildName)(CMonster* this);
	void(__thiscall* ResetNextMove)(CMonster* this, unsigned int, int);
	void(__thiscall* Summon)(CMonster* this, int, int, int, int);
	void(__thiscall* Die)(CMonster* this, CChar*, int, int*, int*);
	char* (__thiscall* GetOperatorName)(CMonster* this);
	void(__thiscall* Attack)(CMonsterReal* this);
	void(__thiscall* Move)(CMonsterReal* this);
	int(__thiscall* IsIgnore)(CMonsterReal* this);
	void(__thiscall* Reaction)(CMonsterReal* this, int, int);
};
#pragma pack(pop)

/* 3403 */
#pragma pack(push, 1)
class /*VFT*/ CMonsterSiegeGun_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	void(__thiscall* SetTarget)(CMonster* this, CChar*);
	void(__thiscall* SetProperty)(CMonster* this, CInitMonster*);
	void(__thiscall* Add)(CMonster* this, CChar*);
	void(__thiscall* Remove)(CMonster* this);
	void(__thiscall* AI)(CMonster* this);
	void(__thiscall* Tick)(CMonster* this);
	void(__thiscall* AddHostility)(CMonster* this, CChar*, int, int);
	void(__thiscall* SetGuild)(CMonster* this, int, char*);
	int(__thiscall* GetGID)(CMonster* this);
	char* (__thiscall* GetGuildName)(CMonster* this);
	void(__thiscall* ResetNextMove)(CMonster* this, unsigned int, int);
	void(__thiscall* Summon)(CMonster* this, int, int, int, int);
	void(__thiscall* Die)(CMonster* this, CChar*, int, int*, int*);
	char* (__thiscall* GetOperatorName)(CMonster* this);
	void(__thiscall* Attack)(CMonsterReal* this);
	void(__thiscall* Move)(CMonsterReal* this);
	int(__thiscall* IsIgnore)(CMonsterReal* this);
	void(__thiscall* Reaction)(CMonsterReal* this, int, int);
};
#pragma pack(pop)

/* 3404 */
#pragma pack(push, 1)
class /*VFT*/ CMonsterTowerBoss_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	void(__thiscall* SetTarget)(CMonster* this, CChar*);
	void(__thiscall* SetProperty)(CMonster* this, CInitMonster*);
	void(__thiscall* Add)(CMonster* this, CChar*);
	void(__thiscall* Remove)(CMonster* this);
	void(__thiscall* AI)(CMonster* this);
	void(__thiscall* Tick)(CMonster* this);
	void(__thiscall* AddHostility)(CMonster* this, CChar*, int, int);
	void(__thiscall* SetGuild)(CMonster* this, int, char*);
	int(__thiscall* GetGID)(CMonster* this);
	char* (__thiscall* GetGuildName)(CMonster* this);
	void(__thiscall* ResetNextMove)(CMonster* this, unsigned int, int);
	void(__thiscall* Summon)(CMonster* this, int, int, int, int);
	void(__thiscall* Die)(CMonster* this, CChar*, int, int*, int*);
	char* (__thiscall* GetOperatorName)(CMonster* this);
	void(__thiscall* Attack)(CMonsterReal* this);
	void(__thiscall* Move)(CMonsterReal* this);
	int(__thiscall* IsIgnore)(CMonsterReal* this);
	void(__thiscall* Reaction)(CMonsterReal* this, int, int);
};
#pragma pack(pop)

/* 3405 */
#pragma pack(push, 1)
class /*VFT*/ CMonsterBigBirdMaster_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	void(__thiscall* SetTarget)(CMonster* this, CChar*);
	void(__thiscall* SetProperty)(CMonster* this, CInitMonster*);
	void(__thiscall* Add)(CMonster* this, CChar*);
	void(__thiscall* Remove)(CMonster* this);
	void(__thiscall* AI)(CMonster* this);
	void(__thiscall* Tick)(CMonster* this);
	void(__thiscall* AddHostility)(CMonster* this, CChar*, int, int);
	void(__thiscall* SetGuild)(CMonster* this, int, char*);
	int(__thiscall* GetGID)(CMonster* this);
	char* (__thiscall* GetGuildName)(CMonster* this);
	void(__thiscall* ResetNextMove)(CMonster* this, unsigned int, int);
	void(__thiscall* Summon)(CMonster* this, int, int, int, int);
	void(__thiscall* Die)(CMonster* this, CChar*, int, int*, int*);
	char* (__thiscall* GetOperatorName)(CMonster* this);
	void(__thiscall* Attack)(CMonsterReal* this);
	void(__thiscall* Move)(CMonsterReal* this);
	int(__thiscall* IsIgnore)(CMonsterReal* this);
	void(__thiscall* Reaction)(CMonsterReal* this, int, int);
};
#pragma pack(pop)

/* 3406 */
#pragma pack(push, 1)
class /*VFT*/ CMonsterBigBirdMother_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	void(__thiscall* SetTarget)(CMonster* this, CChar*);
	void(__thiscall* SetProperty)(CMonster* this, CInitMonster*);
	void(__thiscall* Add)(CMonster* this, CChar*);
	void(__thiscall* Remove)(CMonster* this);
	void(__thiscall* AI)(CMonster* this);
	void(__thiscall* Tick)(CMonster* this);
	void(__thiscall* AddHostility)(CMonster* this, CChar*, int, int);
	void(__thiscall* SetGuild)(CMonster* this, int, char*);
	int(__thiscall* GetGID)(CMonster* this);
	char* (__thiscall* GetGuildName)(CMonster* this);
	void(__thiscall* ResetNextMove)(CMonster* this, unsigned int, int);
	void(__thiscall* Summon)(CMonster* this, int, int, int, int);
	void(__thiscall* Die)(CMonster* this, CChar*, int, int*, int*);
	char* (__thiscall* GetOperatorName)(CMonster* this);
	void(__thiscall* Attack)(CMonsterReal* this);
	void(__thiscall* Move)(CMonsterReal* this);
	int(__thiscall* IsIgnore)(CMonsterReal* this);
	void(__thiscall* Reaction)(CMonsterReal* this, int, int);
	void(__thiscall* OnSummon)(CMonsterBigBirdMother* this);
};
#pragma pack(pop)

/* 3407 */
#pragma pack(push, 1)
class /*VFT*/ CMonsterBlackBug_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	void(__thiscall* SetTarget)(CMonster* this, CChar*);
	void(__thiscall* SetProperty)(CMonster* this, CInitMonster*);
	void(__thiscall* Add)(CMonster* this, CChar*);
	void(__thiscall* Remove)(CMonster* this);
	void(__thiscall* AI)(CMonster* this);
	void(__thiscall* Tick)(CMonster* this);
	void(__thiscall* AddHostility)(CMonster* this, CChar*, int, int);
	void(__thiscall* SetGuild)(CMonster* this, int, char*);
	int(__thiscall* GetGID)(CMonster* this);
	char* (__thiscall* GetGuildName)(CMonster* this);
	void(__thiscall* ResetNextMove)(CMonster* this, unsigned int, int);
	void(__thiscall* Summon)(CMonster* this, int, int, int, int);
	void(__thiscall* Die)(CMonster* this, CChar*, int, int*, int*);
	char* (__thiscall* GetOperatorName)(CMonster* this);
	void(__thiscall* Attack)(CMonsterReal* this);
	void(__thiscall* Move)(CMonsterReal* this);
	int(__thiscall* IsIgnore)(CMonsterReal* this);
	void(__thiscall* Reaction)(CMonsterReal* this, int, int);
};
#pragma pack(pop)

/* 3408 */
#pragma pack(push, 1)
class /*VFT*/ CMonsterCocoon_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	void(__thiscall* SetTarget)(CMonster* this, CChar*);
	void(__thiscall* SetProperty)(CMonster* this, CInitMonster*);
	void(__thiscall* Add)(CMonster* this, CChar*);
	void(__thiscall* Remove)(CMonster* this);
	void(__thiscall* AI)(CMonster* this);
	void(__thiscall* Tick)(CMonster* this);
	void(__thiscall* AddHostility)(CMonster* this, CChar*, int, int);
	void(__thiscall* SetGuild)(CMonster* this, int, char*);
	int(__thiscall* GetGID)(CMonster* this);
	char* (__thiscall* GetGuildName)(CMonster* this);
	void(__thiscall* ResetNextMove)(CMonster* this, unsigned int, int);
	void(__thiscall* Summon)(CMonster* this, int, int, int, int);
	void(__thiscall* Die)(CMonster* this, CChar*, int, int*, int*);
	char* (__thiscall* GetOperatorName)(CMonster* this);
	void(__thiscall* Attack)(CMonsterReal* this);
	void(__thiscall* Move)(CMonsterReal* this);
	int(__thiscall* IsIgnore)(CMonsterReal* this);
	void(__thiscall* Reaction)(CMonsterReal* this, int, int);
};
#pragma pack(pop)

/* 3409 */
#pragma pack(push, 1)
class /*VFT*/ CMonsterEgg_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	void(__thiscall* SetTarget)(CMonster* this, CChar*);
	void(__thiscall* SetProperty)(CMonster* this, CInitMonster*);
	void(__thiscall* Add)(CMonster* this, CChar*);
	void(__thiscall* Remove)(CMonster* this);
	void(__thiscall* AI)(CMonster* this);
	void(__thiscall* Tick)(CMonster* this);
	void(__thiscall* AddHostility)(CMonster* this, CChar*, int, int);
	void(__thiscall* SetGuild)(CMonster* this, int, char*);
	int(__thiscall* GetGID)(CMonster* this);
	char* (__thiscall* GetGuildName)(CMonster* this);
	void(__thiscall* ResetNextMove)(CMonster* this, unsigned int, int);
	void(__thiscall* Summon)(CMonster* this, int, int, int, int);
	void(__thiscall* Die)(CMonster* this, CChar*, int, int*, int*);
	char* (__thiscall* GetOperatorName)(CMonster* this);
	void(__thiscall* Attack)(CMonsterReal* this);
	void(__thiscall* Move)(CMonsterReal* this);
	int(__thiscall* IsIgnore)(CMonsterReal* this);
	void(__thiscall* Reaction)(CMonsterReal* this, int, int);
};
#pragma pack(pop)

/* 3410 */
#pragma pack(push, 1)
class /*VFT*/ CMonsterFireFlower_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	void(__thiscall* SetTarget)(CMonster* this, CChar*);
	void(__thiscall* SetProperty)(CMonster* this, CInitMonster*);
	void(__thiscall* Add)(CMonster* this, CChar*);
	void(__thiscall* Remove)(CMonster* this);
	void(__thiscall* AI)(CMonster* this);
	void(__thiscall* Tick)(CMonster* this);
	void(__thiscall* AddHostility)(CMonster* this, CChar*, int, int);
	void(__thiscall* SetGuild)(CMonster* this, int, char*);
	int(__thiscall* GetGID)(CMonster* this);
	char* (__thiscall* GetGuildName)(CMonster* this);
	void(__thiscall* ResetNextMove)(CMonster* this, unsigned int, int);
	void(__thiscall* Summon)(CMonster* this, int, int, int, int);
	void(__thiscall* Die)(CMonster* this, CChar*, int, int*, int*);
	char* (__thiscall* GetOperatorName)(CMonster* this);
	void(__thiscall* Attack)(CMonsterReal* this);
	void(__thiscall* Move)(CMonsterReal* this);
	int(__thiscall* IsIgnore)(CMonsterReal* this);
	void(__thiscall* Reaction)(CMonsterReal* this, int, int);
};
#pragma pack(pop)

/* 3411 */
#pragma pack(push, 1)
class /*VFT*/ CMonsterGuildWar_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	void(__thiscall* SetTarget)(CMonster* this, CChar*);
	void(__thiscall* SetProperty)(CMonster* this, CInitMonster*);
	void(__thiscall* Add)(CMonster* this, CChar*);
	void(__thiscall* Remove)(CMonster* this);
	void(__thiscall* AI)(CMonster* this);
	void(__thiscall* Tick)(CMonster* this);
	void(__thiscall* AddHostility)(CMonster* this, CChar*, int, int);
	void(__thiscall* SetGuild)(CMonster* this, int, char*);
	int(__thiscall* GetGID)(CMonster* this);
	char* (__thiscall* GetGuildName)(CMonster* this);
	void(__thiscall* ResetNextMove)(CMonster* this, unsigned int, int);
	void(__thiscall* Summon)(CMonster* this, int, int, int, int);
	void(__thiscall* Die)(CMonster* this, CChar*, int, int*, int*);
	char* (__thiscall* GetOperatorName)(CMonster* this);
};
#pragma pack(pop)

/* 3412 */
#pragma pack(push, 1)
class /*VFT*/ CMonsterInactive_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	void(__thiscall* SetTarget)(CMonster* this, CChar*);
	void(__thiscall* SetProperty)(CMonster* this, CInitMonster*);
	void(__thiscall* Add)(CMonster* this, CChar*);
	void(__thiscall* Remove)(CMonster* this);
	void(__thiscall* AI)(CMonster* this);
	void(__thiscall* Tick)(CMonster* this);
	void(__thiscall* AddHostility)(CMonster* this, CChar*, int, int);
	void(__thiscall* SetGuild)(CMonster* this, int, char*);
	int(__thiscall* GetGID)(CMonster* this);
	char* (__thiscall* GetGuildName)(CMonster* this);
	void(__thiscall* ResetNextMove)(CMonster* this, unsigned int, int);
	void(__thiscall* Summon)(CMonster* this, int, int, int, int);
	void(__thiscall* Die)(CMonster* this, CChar*, int, int*, int*);
	char* (__thiscall* GetOperatorName)(CMonster* this);
};
#pragma pack(pop)

/* 3413 */
#pragma pack(push, 1)
class /*VFT*/ CMonsterItem_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	void(__thiscall* SetTarget)(CMonster* this, CChar*);
	void(__thiscall* SetProperty)(CMonster* this, CInitMonster*);
	void(__thiscall* Add)(CMonster* this, CChar*);
	void(__thiscall* Remove)(CMonster* this);
	void(__thiscall* AI)(CMonster* this);
	void(__thiscall* Tick)(CMonster* this);
	void(__thiscall* AddHostility)(CMonster* this, CChar*, int, int);
	void(__thiscall* SetGuild)(CMonster* this, int, char*);
	int(__thiscall* GetGID)(CMonster* this);
	char* (__thiscall* GetGuildName)(CMonster* this);
	void(__thiscall* ResetNextMove)(CMonster* this, unsigned int, int);
	void(__thiscall* Summon)(CMonster* this, int, int, int, int);
	void(__thiscall* Die)(CMonster* this, CChar*, int, int*, int*);
	char* (__thiscall* GetOperatorName)(CMonster* this);
};
#pragma pack(pop)

/* 3414 */
#pragma pack(push, 1)
class /*VFT*/ CMonsterMagic_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	void(__thiscall* SetTarget)(CMonster* this, CChar*);
	void(__thiscall* SetProperty)(CMonster* this, CInitMonster*);
	void(__thiscall* Add)(CMonster* this, CChar*);
	void(__thiscall* Remove)(CMonster* this);
	void(__thiscall* AI)(CMonster* this);
	void(__thiscall* Tick)(CMonster* this);
	void(__thiscall* AddHostility)(CMonster* this, CChar*, int, int);
	void(__thiscall* SetGuild)(CMonster* this, int, char*);
	int(__thiscall* GetGID)(CMonster* this);
	char* (__thiscall* GetGuildName)(CMonster* this);
	void(__thiscall* ResetNextMove)(CMonster* this, unsigned int, int);
	void(__thiscall* Summon)(CMonster* this, int, int, int, int);
	void(__thiscall* Die)(CMonster* this, CChar*, int, int*, int*);
	char* (__thiscall* GetOperatorName)(CMonster* this);
};
#pragma pack(pop)

/* 3415 */
#pragma pack(push, 1)
class /*VFT*/ CMonsterMaguniMaster_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	void(__thiscall* SetTarget)(CMonster* this, CChar*);
	void(__thiscall* SetProperty)(CMonster* this, CInitMonster*);
	void(__thiscall* Add)(CMonster* this, CChar*);
	void(__thiscall* Remove)(CMonster* this);
	void(__thiscall* AI)(CMonster* this);
	void(__thiscall* Tick)(CMonster* this);
	void(__thiscall* AddHostility)(CMonster* this, CChar*, int, int);
	void(__thiscall* SetGuild)(CMonster* this, int, char*);
	int(__thiscall* GetGID)(CMonster* this);
	char* (__thiscall* GetGuildName)(CMonster* this);
	void(__thiscall* ResetNextMove)(CMonster* this, unsigned int, int);
	void(__thiscall* Summon)(CMonster* this, int, int, int, int);
	void(__thiscall* Die)(CMonster* this, CChar*, int, int*, int*);
	char* (__thiscall* GetOperatorName)(CMonster* this);
	void(__thiscall* Attack)(CMonsterReal* this);
	void(__thiscall* Move)(CMonsterReal* this);
	int(__thiscall* IsIgnore)(CMonsterReal* this);
	void(__thiscall* Reaction)(CMonsterReal* this, int, int);
};
#pragma pack(pop)

/* 3416 */
#pragma pack(push, 1)
class /*VFT*/ CMonsterMaguni_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	void(__thiscall* SetTarget)(CMonster* this, CChar*);
	void(__thiscall* SetProperty)(CMonster* this, CInitMonster*);
	void(__thiscall* Add)(CMonster* this, CChar*);
	void(__thiscall* Remove)(CMonster* this);
	void(__thiscall* AI)(CMonster* this);
	void(__thiscall* Tick)(CMonster* this);
	void(__thiscall* AddHostility)(CMonster* this, CChar*, int, int);
	void(__thiscall* SetGuild)(CMonster* this, int, char*);
	int(__thiscall* GetGID)(CMonster* this);
	char* (__thiscall* GetGuildName)(CMonster* this);
	void(__thiscall* ResetNextMove)(CMonster* this, unsigned int, int);
	void(__thiscall* Summon)(CMonster* this, int, int, int, int);
	void(__thiscall* Die)(CMonster* this, CChar*, int, int*, int*);
	char* (__thiscall* GetOperatorName)(CMonster* this);
	void(__thiscall* Attack)(CMonsterReal* this);
	void(__thiscall* Move)(CMonsterReal* this);
	int(__thiscall* IsIgnore)(CMonsterReal* this);
	void(__thiscall* Reaction)(CMonsterReal* this, int, int);
};
#pragma pack(pop)

/* 3417 */
#pragma pack(push, 1)
class /*VFT*/ CMonsterMaguniWithSkillOnly_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	void(__thiscall* SetTarget)(CMonster* this, CChar*);
	void(__thiscall* SetProperty)(CMonster* this, CInitMonster*);
	void(__thiscall* Add)(CMonster* this, CChar*);
	void(__thiscall* Remove)(CMonster* this);
	void(__thiscall* AI)(CMonster* this);
	void(__thiscall* Tick)(CMonster* this);
	void(__thiscall* AddHostility)(CMonster* this, CChar*, int, int);
	void(__thiscall* SetGuild)(CMonster* this, int, char*);
	int(__thiscall* GetGID)(CMonster* this);
	char* (__thiscall* GetGuildName)(CMonster* this);
	void(__thiscall* ResetNextMove)(CMonster* this, unsigned int, int);
	void(__thiscall* Summon)(CMonster* this, int, int, int, int);
	void(__thiscall* Die)(CMonster* this, CChar*, int, int*, int*);
	char* (__thiscall* GetOperatorName)(CMonster* this);
	void(__thiscall* Attack)(CMonsterReal* this);
	void(__thiscall* Move)(CMonsterReal* this);
	int(__thiscall* IsIgnore)(CMonsterReal* this);
	void(__thiscall* Reaction)(CMonsterReal* this, int, int);
};
#pragma pack(pop)

/* 3418 */
#pragma pack(push, 1)
class /*VFT*/ CMonsterMaguniWithSkill_vtbl
{
	void(__thiscall * ~CIOObject)(CIOObject* this);
	void(__thiscall* OnFree)(CIOObject* this);
	void(__thiscall* OnTimer)(CIOObject* this, int);
	void(__thiscall* OnTimerCallback)(CIOObject* this, int);
	void(__thiscall* OnWaitCallback)(CIOObject* this);
	void(__thiscall* OnIOCallback)(CIOObject* this, int, unsigned int, _OVERLAPPED*);
	CBase* (__thiscall* Copy)(CBase* this);
	int(__thiscall* Set)(CBase* this, Symbol, lisp::var);
	int(__thiscall* OnLoad)(CBase* this);
	void(__thiscall* OnDelete)(CBase* this);
	void(__thiscall* SendPacket)(CBase* this, CIOBuffer*);
	void(__thiscall* SendDelete)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendMove)(CBase* this, CBase*, CIOBuffer*);
	void(__thiscall* SendCreate)(CBase* this, CBase*, CIOBuffer*);
	int(__thiscall* Index)(CBase* this, int);
	int(__thiscall* IsPlayer)(CBase* this);
	int(__thiscall* IsMonster)(CBase* this);
	int(__thiscall* IsItem)(CBase* this);
	int(__thiscall* Damage)(CChar* this, CChar*, int, int*, int*, int*, CSkill*);
	void(__thiscall* InfoDie)(CChar* this, int, int);
	void(__thiscall* Defense)(CChar* this, CChar*);
	void(__thiscall* ReviseProperty)(CChar* this);
	void (*UpdateProperty)(CChar* this, int, int, ...);
	void (*UpdatePrtyPt)(CChar* this, int, int, ...);
	void (*UpdatePrtyPer)(CChar* this, int, int, ...);
	void(__thiscall* AddGState)(CChar* this, int);
	void(__thiscall* AddMState)(CChar* this, __int64);
	void(__thiscall* AddBState)(CChar* this, __int64, int);
	void(__thiscall* SubGState)(CChar* this, int);
	void(__thiscall* AddMStateEx)(CChar* this, int);
	void(__thiscall* SubMStateEx)(CChar* this, int);
	void(__thiscall* SubMState)(CChar* this, __int64);
	void(__thiscall* SubBState)(CChar* this, __int64);
	void(__thiscall* RemoveHostility)(CChar* this, CChar*);
	int(__thiscall* GetFinalDefense)(CChar* this, CChar*);
	int(__thiscall* GetFinalAbsorb)(CChar* this, CChar*);
	int(__thiscall* GetFinalResist)(CChar* this, CChar*, int);
	int(__thiscall* CheckBlock)(CChar* this, CChar*);
	unsigned int(__thiscall* GetMSpeed)(CChar* this, int);
	int(__thiscall* GetAttackType)(CChar* this);
	void(__thiscall* PKKill)(CChar* this, CPlayer*);
	unsigned int(__thiscall* GetDropItemMask)(CChar* this);
	int(__thiscall* GetPalsyDamage)(CChar* this, CChar*);
	void(__thiscall* UpdateChild)(CChar* this, int);
	int(__thiscall* CanAttack)(CChar* this, CChar*, int);
	int(__thiscall* AddBuff)(CChar* this, CBuff*);
	unsigned int(__thiscall* GetBuffRemain)(CChar* this, int);
	void(__thiscall* SetTarget)(CMonster* this, CChar*);
	void(__thiscall* SetProperty)(CMonster* this, CInitMonster*);
	void(__thiscall* Add)(CMonster* this, CChar*);
	void(__thiscall* Remove)(CMonster* this);
	void(__thiscall* AI)(CMonster* this);
	void(__thiscall* Tick)(CMonster* this);
	void(__thiscall* AddHostility)(CMonster* this, CChar*, int, int);
	void(__thiscall* SetGuild)(CMonster* this, int, char*);
	int(__thiscall* GetGID)(CMonster* this);
	char* (__thiscall* GetGuildName)(CMonster* this);
	void(__thiscall* ResetNextMove)(CMonster* this, unsigned int, int);
	void(__thiscall* Summon)(CMonster* this, int, int, int, int);
	void(__thiscall* Die)(CMonster* this, CChar*, int, int*, int*);
	char* (__thiscall* GetOperatorName)(CMonster* this);
	void(__thiscall* Attack)(CMonsterReal* this);
	void(__thiscall* Move)(CMonsterReal* this);
	int(__thiscall* IsIgnore)(CMonsterReal* this);
	void(__thiscall* Reaction)(CMonsterReal* this, int, int);
};
#pragma pack(pop)

/* 3420 */
typedef const _s_ThrowInfo ThrowInfo;

/* 3419 */
typedef ThrowInfo _ThrowInfo;

/* 3421 */
enum MACRO_SOL
{
	SOL_SOCKET = 0xFFFF,
};

/* 3422 */
enum MACRO_SO
{
	SO_DEBUG = 0x1,
	SO_ACCEPTCONN = 0x2,
	SO_REUSEADDR = 0x4,
	SO_KEEPALIVE = 0x8,
	SO_DONTROUTE = 0x10,
	SO_BROADCAST = 0x20,
	SO_USELOOPBACK = 0x40,
	SO_LINGER = 0x80,
	SO_OOBINLINE = 0x100,
	SO_DONTLINGER = 0xFFFFFF7F,
	SO_EXCLUSIVEADDRUSE = 0xFFFFFFFB,
	SO_SNDBUF = 0x1001,
	SO_RCVBUF = 0x1002,
	SO_SNDLOWAT = 0x1003,
	SO_RCVLOWAT = 0x1004,
	SO_SNDTIMEO = 0x1005,
	SO_RCVTIMEO = 0x1006,
	SO_ERROR = 0x1007,
	SO_TYPE = 0x1008,
	SO_BSP_STATE = 0x1009,
	SO_GROUP_ID = 0x2001,
	SO_GROUP_PRIORITY = 0x2002,
	SO_MAX_MSG_SIZE = 0x2003,
	SO_CONDITIONAL_ACCEPT = 0x3002,
	SO_PAUSE_ACCEPT = 0x3003,
	SO_COMPARTMENT_ID = 0x3004,
};

/* 3423 */
enum MACRO_WSA_QOS : __int64
{
	WSA_QOS_RECEIVERS = 11005,
	WSA_QOS_SENDERS = 11006,
	WSA_QOS_NO_SENDERS = 11007,
	WSA_QOS_NO_RECEIVERS = 11008,
	WSA_QOS_REQUEST_CONFIRMED = 11009,
	WSA_QOS_ADMISSION_FAILURE = 11010,
	WSA_QOS_POLICY_FAILURE = 11011,
	WSA_QOS_BAD_STYLE = 11012,
	WSA_QOS_BAD_OBJECT = 11013,
	WSA_QOS_TRAFFIC_CTRL_ERROR = 11014,
	WSA_QOS_GENERIC_ERROR = 11015,
	WSA_WAIT_EVENT_0 = 0,
};

/* 3424 */
enum MACRO_WSAECONNRESET
{
	WSAECONNRESET = 10054,
};

/* 3425 */
enum MACRO_WSAECONNABORTED
{
	WSAECONNABORTED = 10053,
};

/* 3426 */
enum MACRO_WSAESHUTDOWN
{
	WSAESHUTDOWN = 10058,
};

/* 3427 */
enum MACRO_WSA : __int64
{
	WSA_IO_PENDING = 997,
	WSA_IO_INCOMPLETE = 996,
	WSA_INVALID_HANDLE = 6,
	WSA_INVALID_PARAMETER = 87,
	WSA_NOT_ENOUGH_MEMORY = 8,
	WSA_OPERATION_ABORTED = 995,
	WSA_INVALID_EVENT = 0,
	WSA_MAXIMUM_WAIT_EVENTS = 64,
	WSA_WAIT_FAILED = 4294967295,
	WSA_WAIT_TIMEOUT = 258,
	WSA_INFINITE = -1,
};

/* 3429 */
typedef _IMAGE_NT_HEADERS IMAGE_NT_HEADERS32;

/* 3428 */
typedef IMAGE_NT_HEADERS32 IMAGE_NT_HEADERS;

